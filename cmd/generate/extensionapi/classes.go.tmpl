{{ $view := . -}}
package gdextension

/*------------------------------------------------------------------------------
//   This code was generated by template classes.go.tmpl.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "classes.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

//revive:disable

// #include <godot/gdnative_interface.h>
// #include "classes.callbacks.gen.h"
// #include <stdio.h>
// #include <stdlib.h>
import "C"
import (
	"unsafe"

	. "github.com/godot-go/godot-go/pkg/gdnative"
	"github.com/godot-go/godot-go/pkg/log"
	"go.uber.org/zap"
)

// classes
{{ range $i, $c := $view.Classes -}}

type {{ goClassStructName $c.Name }} struct {
	{{ if $c.Inherits }}
	{{ goClassStructName $c.Inherits }}
	{{ else }}
	WrappedImpl
	{{ end }}
}

func NewGDNativeClassFrom{{ $c.Name }}Owner(owner *GodotObject) GDNativeClass {
	inst := &{{ goClassStructName $c.Name }}{}
	inst.Owner = owner

	return (GDNativeClass)(inst)
}

func New{{ $c.Name }}WithGodotOwnerObject(owner *GodotObject) {{ $c.Name }} {
	inst := &{{ goClassStructName $c.Name }}{}
	inst.Owner = owner

	return inst
}

{{ if $c.Methods -}}

// section: methods
func (cx *{{ goClassStructName $c.Name }}) GetClassName() TypeName {
	return TypeName("{{ $c.Name }}")
}

func (cx *{{ goClassStructName $c.Name }}) GetParentClassName() TypeName {
	return TypeName("{{ $c.Inherits }}")
}

{{ range $j, $m := $c.Methods -}}
{{ $fnReturnType := goReturnType $m.ReturnValue.Type }}
{{ $hasSomeArguments := (or $m.Arguments $m.IsVararg) }}

{{ if $m.IsVirtual -}}
{{/* TODO: deal with virtual functions */}}
{{ else -}}
/* {{ goMethodName $m.Name }} implements {{ $c.Name }}.{{ $m.Name }}:
 * is_vararg = {{ $m.IsVararg }}, is_static = {{ $m.IsStatic }}, is_virtual = {{ $m.IsVirtual }},
 * return_type = {{ $m.ReturnValue.Type }}, return_meta = {{ $m.ReturnValue.Meta }}
 */
func (cx *{{ goClassStructName $c.Name }}) {{ goMethodName $m.Name }}(
{{range $k, $a := $m.Arguments -}}
{{ goArgumentName $a.Name }} {{ goArgumentType $a.Type }},
{{end -}}
{{- if $m.IsVararg }}varargs ...Variant,{{ end -}}
) {{ $fnReturnType }} {
    {{/* TODO: refactor for static instantiation */}}
	fn := GDNativeInterface_classdb_get_method_bind(
		internal.gdnInterface, "{{ $c.Name }}", "{{ $m.Name }}", {{ $m.Hash }})

	if fn == nil {
		panic("could not find method function {{ $c.Name }}.{{ $m.Name }} ({{ $m.Hash }})")
	}

	{{/* init return type */}}
	{{ if $fnReturnType -}}
	{{ if $view.ContainsClassName $fnReturnType -}}
	var ret {{ goClassStructName $fnReturnType }}
	{{ else -}}
	var ret {{ $fnReturnType }}
	{{ end -}}
	{{ if $m.IsVararg}}
	retPtr := (GDNativeVariantPtr)(unsafe.Pointer(&ret))
	{{ else -}}
	retPtr := (GDNativeTypePtr)(unsafe.Pointer(&ret))
	{{ end -}}
	{{- else -}}
	{{ if $m.IsVararg}}
	retPtr := (GDNativeVariantPtr)(nullptr)
	{{ else -}}
	retPtr := (GDNativeTypePtr)(nullptr)
	{{ end -}}
	{{- end }}

	{{ if $m.IsVararg -}}
	callArgCount := {{ len $m.Arguments }} + len(varargs)
	{{ else -}}
	callArgCount := {{ len $m.Arguments }}
	{{ end -}}

	sz := unsafe.Sizeof(nullptr) * uintptr(callArgCount)

	argBytes := unsafe.Pointer(C.malloc(C.size_t(sz)))

	{{ if $hasSomeArguments -}}
	argsPtr := (*[MAX_ARG_COUNT]unsafe.Pointer)(argBytes)
	{{ end -}}

	{{ if $m.IsVararg -}}
	{{ range $j, $a := $m.Arguments -}}
	arg{{ $j }} := {{ goVariantConstructor $a.Type (goArgumentName $a.Name) }}
	argsPtr[{{ $j }}] = unsafe.Pointer(&arg{{ $j }})
	{{ end -}}
	{{ else -}}
	{{ range $j, $a := $m.Arguments -}}
		argsPtr[{{ $j }}] = unsafe.Pointer(&{{ goArgumentName $a.Name }})
	{{ end -}}
	{{ end -}}

    {{ if $m.IsVararg -}}
    for i := range varargs {
        argsPtr[i + {{ len $m.Arguments }}] = unsafe.Pointer(&varargs[i]) // variant
    }
    {{ end -}}

	cOwner := (GDNativeObjectPtr)(unsafe.Pointer(cx.GetGodotObjectOwner()))

	{{ if $m.IsVararg -}}
	var err GDNativeCallError

	GDNativeInterface_object_method_bind_call(internal.gdnInterface, fn, cOwner, (*GDNativeVariantPtr)(unsafe.Pointer(argsPtr)), (GDNativeInt)(callArgCount), retPtr, &err)

	if !err.Ok() {
		log.Panic("method bind call error", zap.Error(&err))
	}
	{{ else -}}
	cArgs := (*GDNativeTypePtr)(argBytes)

	GDNativeInterface_object_method_bind_ptrcall(internal.gdnInterface, fn, cOwner, cArgs, retPtr)
	{{ end -}}

	{{ with $fnReturnType -}}
	C.free(argBytes)
	{{ if $view.ContainsClassName $fnReturnType -}}
	return &ret
	{{ else -}}
	return ret
	{{ end -}}
	{{- end }}
}
{{ end -}}
{{ end -}} {{/* if $m.IsVirtual */}}

{{ end -}} {{/* range $j, $m := $c.Methods */}}

{{ end -}}
