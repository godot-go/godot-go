package builtin

/*------------------------------------------------------------------------------
//   This code was generated by template builtinclasses.go.tmpl.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "builtinclasses.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

//revive:disable

// #include <godot/gdextension_interface.h>
// #include <stdio.h>
// #include <stdlib.h>
import "C"
import (
	"runtime"
	"unsafe"

	"github.com/godot-go/godot-go/pkg/log"

	. "github.com/godot-go/godot-go/pkg/ffi"
)

type GDBuiltInClass interface {
	NativeConstPtr() GDExtensionConstTypePtr
	NativePtr() GDExtensionTypePtr
}

type GDBuiltInDestroyableClass interface {
	GDBuiltInClass
	Destroy()
}

const (
	StringSize             = 8
	Vector2Size            = 8
	Vector2iSize           = 8
	Rect2Size              = 16
	Rect2iSize             = 16
	Vector3Size            = 12
	Vector3iSize           = 12
	Transform2DSize        = 24
	Vector4Size            = 16
	Vector4iSize           = 16
	PlaneSize              = 16
	QuaternionSize         = 16
	AABBSize               = 24
	BasisSize              = 36
	Transform3DSize        = 48
	ProjectionSize         = 64
	ColorSize              = 16
	StringNameSize         = 8
	NodePathSize           = 8
	RIDSize                = 8
	CallableSize           = 16
	SignalSize             = 16
	DictionarySize         = 8
	ArraySize              = 8
	PackedByteArraySize    = 16
	PackedInt32ArraySize   = 16
	PackedInt64ArraySize   = 16
	PackedFloat32ArraySize = 16
	PackedFloat64ArraySize = 16
	PackedStringArraySize  = 16
	PackedVector2ArraySize = 16
	PackedVector3ArraySize = 16
	PackedColorArraySize   = 16
	PackedVector4ArraySize = 16
)

var (
	StringEncoder             argumentEncoder[String, String]
	Vector2Encoder            argumentEncoder[Vector2, Vector2]
	Vector2iEncoder           argumentEncoder[Vector2i, Vector2i]
	Rect2Encoder              argumentEncoder[Rect2, Rect2]
	Rect2iEncoder             argumentEncoder[Rect2i, Rect2i]
	Vector3Encoder            argumentEncoder[Vector3, Vector3]
	Vector3iEncoder           argumentEncoder[Vector3i, Vector3i]
	Transform2DEncoder        argumentEncoder[Transform2D, Transform2D]
	Vector4Encoder            argumentEncoder[Vector4, Vector4]
	Vector4iEncoder           argumentEncoder[Vector4i, Vector4i]
	PlaneEncoder              argumentEncoder[Plane, Plane]
	QuaternionEncoder         argumentEncoder[Quaternion, Quaternion]
	AABBEncoder               argumentEncoder[AABB, AABB]
	BasisEncoder              argumentEncoder[Basis, Basis]
	Transform3DEncoder        argumentEncoder[Transform3D, Transform3D]
	ProjectionEncoder         argumentEncoder[Projection, Projection]
	ColorEncoder              argumentEncoder[Color, Color]
	StringNameEncoder         argumentEncoder[StringName, StringName]
	NodePathEncoder           argumentEncoder[NodePath, NodePath]
	RIDEncoder                argumentEncoder[RID, RID]
	CallableEncoder           argumentEncoder[Callable, Callable]
	SignalEncoder             argumentEncoder[Signal, Signal]
	DictionaryEncoder         argumentEncoder[Dictionary, Dictionary]
	ArrayEncoder              argumentEncoder[Array, Array]
	PackedByteArrayEncoder    argumentEncoder[PackedByteArray, PackedByteArray]
	PackedInt32ArrayEncoder   argumentEncoder[PackedInt32Array, PackedInt32Array]
	PackedInt64ArrayEncoder   argumentEncoder[PackedInt64Array, PackedInt64Array]
	PackedFloat32ArrayEncoder argumentEncoder[PackedFloat32Array, PackedFloat32Array]
	PackedFloat64ArrayEncoder argumentEncoder[PackedFloat64Array, PackedFloat64Array]
	PackedStringArrayEncoder  argumentEncoder[PackedStringArray, PackedStringArray]
	PackedVector2ArrayEncoder argumentEncoder[PackedVector2Array, PackedVector2Array]
	PackedVector3ArrayEncoder argumentEncoder[PackedVector3Array, PackedVector3Array]
	PackedColorArrayEncoder   argumentEncoder[PackedColorArray, PackedColorArray]
	PackedVector4ArrayEncoder argumentEncoder[PackedVector4Array, PackedVector4Array]
)

func initBuiltinClassEncoders() {
	StringEncoder = createBuiltinClassEncoder[String](GDEXTENSION_VARIANT_TYPE_STRING, StringSize)
	Vector2Encoder = createBuiltinClassEncoder[Vector2](GDEXTENSION_VARIANT_TYPE_VECTOR2, Vector2Size)
	Vector2iEncoder = createBuiltinClassEncoder[Vector2i](GDEXTENSION_VARIANT_TYPE_VECTOR2I, Vector2iSize)
	Rect2Encoder = createBuiltinClassEncoder[Rect2](GDEXTENSION_VARIANT_TYPE_RECT2, Rect2Size)
	Rect2iEncoder = createBuiltinClassEncoder[Rect2i](GDEXTENSION_VARIANT_TYPE_RECT2I, Rect2iSize)
	Vector3Encoder = createBuiltinClassEncoder[Vector3](GDEXTENSION_VARIANT_TYPE_VECTOR3, Vector3Size)
	Vector3iEncoder = createBuiltinClassEncoder[Vector3i](GDEXTENSION_VARIANT_TYPE_VECTOR3I, Vector3iSize)
	Transform2DEncoder = createBuiltinClassEncoder[Transform2D](GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, Transform2DSize)
	Vector4Encoder = createBuiltinClassEncoder[Vector4](GDEXTENSION_VARIANT_TYPE_VECTOR4, Vector4Size)
	Vector4iEncoder = createBuiltinClassEncoder[Vector4i](GDEXTENSION_VARIANT_TYPE_VECTOR4I, Vector4iSize)
	PlaneEncoder = createBuiltinClassEncoder[Plane](GDEXTENSION_VARIANT_TYPE_PLANE, PlaneSize)
	QuaternionEncoder = createBuiltinClassEncoder[Quaternion](GDEXTENSION_VARIANT_TYPE_QUATERNION, QuaternionSize)
	AABBEncoder = createBuiltinClassEncoder[AABB](GDEXTENSION_VARIANT_TYPE_AABB, AABBSize)
	BasisEncoder = createBuiltinClassEncoder[Basis](GDEXTENSION_VARIANT_TYPE_BASIS, BasisSize)
	Transform3DEncoder = createBuiltinClassEncoder[Transform3D](GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, Transform3DSize)
	ProjectionEncoder = createBuiltinClassEncoder[Projection](GDEXTENSION_VARIANT_TYPE_PROJECTION, ProjectionSize)
	ColorEncoder = createBuiltinClassEncoder[Color](GDEXTENSION_VARIANT_TYPE_COLOR, ColorSize)
	StringNameEncoder = createBuiltinClassEncoder[StringName](GDEXTENSION_VARIANT_TYPE_STRING_NAME, StringNameSize)
	NodePathEncoder = createBuiltinClassEncoder[NodePath](GDEXTENSION_VARIANT_TYPE_NODE_PATH, NodePathSize)
	RIDEncoder = createBuiltinClassEncoder[RID](GDEXTENSION_VARIANT_TYPE_RID, RIDSize)
	CallableEncoder = createBuiltinClassEncoder[Callable](GDEXTENSION_VARIANT_TYPE_CALLABLE, CallableSize)
	SignalEncoder = createBuiltinClassEncoder[Signal](GDEXTENSION_VARIANT_TYPE_SIGNAL, SignalSize)
	DictionaryEncoder = createBuiltinClassEncoder[Dictionary](GDEXTENSION_VARIANT_TYPE_DICTIONARY, DictionarySize)
	ArrayEncoder = createBuiltinClassEncoder[Array](GDEXTENSION_VARIANT_TYPE_ARRAY, ArraySize)
	PackedByteArrayEncoder = createBuiltinClassEncoder[PackedByteArray](GDEXTENSION_VARIANT_TYPE_PACKED_BYTE_ARRAY, PackedByteArraySize)
	PackedInt32ArrayEncoder = createBuiltinClassEncoder[PackedInt32Array](GDEXTENSION_VARIANT_TYPE_PACKED_INT32_ARRAY, PackedInt32ArraySize)
	PackedInt64ArrayEncoder = createBuiltinClassEncoder[PackedInt64Array](GDEXTENSION_VARIANT_TYPE_PACKED_INT64_ARRAY, PackedInt64ArraySize)
	PackedFloat32ArrayEncoder = createBuiltinClassEncoder[PackedFloat32Array](GDEXTENSION_VARIANT_TYPE_PACKED_FLOAT32_ARRAY, PackedFloat32ArraySize)
	PackedFloat64ArrayEncoder = createBuiltinClassEncoder[PackedFloat64Array](GDEXTENSION_VARIANT_TYPE_PACKED_FLOAT64_ARRAY, PackedFloat64ArraySize)
	PackedStringArrayEncoder = createBuiltinClassEncoder[PackedStringArray](GDEXTENSION_VARIANT_TYPE_PACKED_STRING_ARRAY, PackedStringArraySize)
	PackedVector2ArrayEncoder = createBuiltinClassEncoder[PackedVector2Array](GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR2_ARRAY, PackedVector2ArraySize)
	PackedVector3ArrayEncoder = createBuiltinClassEncoder[PackedVector3Array](GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR3_ARRAY, PackedVector3ArraySize)
	PackedColorArrayEncoder = createBuiltinClassEncoder[PackedColorArray](GDEXTENSION_VARIANT_TYPE_PACKED_COLOR_ARRAY, PackedColorArraySize)
	PackedVector4ArrayEncoder = createBuiltinClassEncoder[PackedVector4Array](GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, PackedVector4ArraySize)
}

// built-in classes

var _ GDBuiltInDestroyableClass = &String{}

/*
 * String
 * indexingReturnType: String
 * isKeyed: false
 * hasDestructor: true
 */
type String [8]uint8

func (c *String) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *String) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewString, index: 0
func NewString() String {
	cx := String{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalStringMethodBindings.constructor_0, ptr)
	return cx
}

// NewString, index: 2
func NewStringWithStringName(from StringName) String {
	cx := String{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// StringName
	// StringNameEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalStringMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewString, index: 3
func NewStringWithNodePath(from NodePath) String {
	cx := String{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// NodePath
	// NodePathEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalStringMethodBindings.constructor_2, ptr, args[0])
	return cx
}

func (cx *String) Destroy() {
	md := (GDExtensionPtrDestructor)(globalStringMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewStringWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) String {
	ret := String{}
	typedSrc := (*String)(src)

	for i := 0; i < 8; i++ {
		ret[i] = typedSrc[i]
	}

	return (String)(ret)
}
func copyStringWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*String)(dst)
	typedSrc := (*String)(src)

	for i := 0; i < 8; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* CasecmpTo : casecmp_to
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) CasecmpTo(to String) int64 {
	mb := globalStringMethodBindings.method_casecmp_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* NocasecmpTo : nocasecmp_to
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) NocasecmpTo(to String) int64 {
	mb := globalStringMethodBindings.method_nocasecmp_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* NaturalcasecmpTo : naturalcasecmp_to
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) NaturalcasecmpTo(to String) int64 {
	mb := globalStringMethodBindings.method_naturalcasecmp_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* NaturalnocasecmpTo : naturalnocasecmp_to
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) NaturalnocasecmpTo(to String) int64 {
	mb := globalStringMethodBindings.method_naturalnocasecmp_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* FilecasecmpTo : filecasecmp_to
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) FilecasecmpTo(to String) int64 {
	mb := globalStringMethodBindings.method_filecasecmp_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* FilenocasecmpTo : filenocasecmp_to
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) FilenocasecmpTo(to String) int64 {
	mb := globalStringMethodBindings.method_filenocasecmp_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Length : length
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) Length() int64 {
	mb := globalStringMethodBindings.method_length
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* Substr : substr
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Substr(from int64, len int64) String {
	mb := globalStringMethodBindings.method_substr
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(from)

	args[1] = Int64Encoder.EncodeTypePtr(len)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetSlice : get_slice
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) GetSlice(delimiter String, slice int64) String {
	mb := globalStringMethodBindings.method_get_slice
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&delimiter))

	args[1] = Int64Encoder.EncodeTypePtr(slice)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetSlicec : get_slicec
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) GetSlicec(delimiter int64, slice int64) String {
	mb := globalStringMethodBindings.method_get_slicec
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(delimiter)

	args[1] = Int64Encoder.EncodeTypePtr(slice)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetSliceCount : get_slice_count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) GetSliceCount(delimiter String) int64 {
	mb := globalStringMethodBindings.method_get_slice_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&delimiter))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Find : find
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) Find(what String, from int64) int64 {
	mb := globalStringMethodBindings.method_find
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Findn : findn
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) Findn(what String, from int64) int64 {
	mb := globalStringMethodBindings.method_findn
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Count : count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) Count(what String, from int64, to int64) int64 {
	mb := globalStringMethodBindings.method_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 3
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	args[2] = Int64Encoder.EncodeTypePtr(to)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Countn : countn
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) Countn(what String, from int64, to int64) int64 {
	mb := globalStringMethodBindings.method_countn
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 3
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	args[2] = Int64Encoder.EncodeTypePtr(to)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rfind : rfind
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) Rfind(what String, from int64) int64 {
	mb := globalStringMethodBindings.method_rfind
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rfindn : rfindn
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) Rfindn(what String, from int64) int64 {
	mb := globalStringMethodBindings.method_rfindn
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Match : match
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) Match(expr String) bool {
	mb := globalStringMethodBindings.method_match
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&expr))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Matchn : matchn
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) Matchn(expr String) bool {
	mb := globalStringMethodBindings.method_matchn
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&expr))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* BeginsWith : begins_with
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) BeginsWith(text String) bool {
	mb := globalStringMethodBindings.method_begins_with
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&text))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* EndsWith : ends_with
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) EndsWith(text String) bool {
	mb := globalStringMethodBindings.method_ends_with
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&text))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsSubsequenceOf : is_subsequence_of
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) IsSubsequenceOf(text String) bool {
	mb := globalStringMethodBindings.method_is_subsequence_of
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&text))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsSubsequenceOfn : is_subsequence_ofn
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) IsSubsequenceOfn(text String) bool {
	mb := globalStringMethodBindings.method_is_subsequence_ofn
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&text))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Bigrams : bigrams
 * is_vararg = false, is_static = false
 * goReturnType(PackedStringArray) -> PackedStringArray
 */
func (cx *String) Bigrams() PackedStringArray {
	mb := globalStringMethodBindings.method_bigrams
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedStringArray](mb, bx, nil)
	return ret
}

/* Similarity : similarity
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *String) Similarity(text String) float32 {
	mb := globalStringMethodBindings.method_similarity
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&text))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Format : format
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Format(values Variant, placeholder String) String {
	mb := globalStringMethodBindings.method_format
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&values))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&placeholder))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Replace : replace
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Replace(what String, forwhat String) String {
	mb := globalStringMethodBindings.method_replace
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&forwhat))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Replacen : replacen
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Replacen(what String, forwhat String) String {
	mb := globalStringMethodBindings.method_replacen
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&forwhat))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Repeat : repeat
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Repeat(count int64) String {
	mb := globalStringMethodBindings.method_repeat
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(count)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Reverse : reverse
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Reverse() String {
	mb := globalStringMethodBindings.method_reverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Insert : insert
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Insert(position int64, what String) String {
	mb := globalStringMethodBindings.method_insert
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(position)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Erase : erase
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Erase(position int64, chars int64) String {
	mb := globalStringMethodBindings.method_erase
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(position)

	args[1] = Int64Encoder.EncodeTypePtr(chars)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Capitalize : capitalize
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Capitalize() String {
	mb := globalStringMethodBindings.method_capitalize
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* ToCamelCase : to_camel_case
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) ToCamelCase() String {
	mb := globalStringMethodBindings.method_to_camel_case
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* ToPascalCase : to_pascal_case
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) ToPascalCase() String {
	mb := globalStringMethodBindings.method_to_pascal_case
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* ToSnakeCase : to_snake_case
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) ToSnakeCase() String {
	mb := globalStringMethodBindings.method_to_snake_case
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Split : split
 * is_vararg = false, is_static = false
 * goReturnType(PackedStringArray) -> PackedStringArray
 */
func (cx *String) Split(delimiter String, allow_empty bool, maxsplit int64) PackedStringArray {
	mb := globalStringMethodBindings.method_split
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 3
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&delimiter))

	args[1] = BoolEncoder.EncodeTypePtr(allow_empty)

	args[2] = Int64Encoder.EncodeTypePtr(maxsplit)

	ret := CallBuiltinMethodPtrRet[PackedStringArray](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rsplit : rsplit
 * is_vararg = false, is_static = false
 * goReturnType(PackedStringArray) -> PackedStringArray
 */
func (cx *String) Rsplit(delimiter String, allow_empty bool, maxsplit int64) PackedStringArray {
	mb := globalStringMethodBindings.method_rsplit
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 3
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&delimiter))

	args[1] = BoolEncoder.EncodeTypePtr(allow_empty)

	args[2] = Int64Encoder.EncodeTypePtr(maxsplit)

	ret := CallBuiltinMethodPtrRet[PackedStringArray](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* SplitFloats : split_floats
 * is_vararg = false, is_static = false
 * goReturnType(PackedFloat64Array) -> PackedFloat64Array
 */
func (cx *String) SplitFloats(delimiter String, allow_empty bool) PackedFloat64Array {
	mb := globalStringMethodBindings.method_split_floats
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&delimiter))

	args[1] = BoolEncoder.EncodeTypePtr(allow_empty)

	ret := CallBuiltinMethodPtrRet[PackedFloat64Array](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Join : join
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Join(parts PackedStringArray) String {
	mb := globalStringMethodBindings.method_join
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&parts))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* ToUpper : to_upper
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) ToUpper() String {
	mb := globalStringMethodBindings.method_to_upper
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* ToLower : to_lower
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) ToLower() String {
	mb := globalStringMethodBindings.method_to_lower
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Left : left
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Left(length int64) String {
	mb := globalStringMethodBindings.method_left
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(length)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Right : right
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Right(length int64) String {
	mb := globalStringMethodBindings.method_right
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(length)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* StripEdges : strip_edges
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) StripEdges(left bool, right bool) String {
	mb := globalStringMethodBindings.method_strip_edges
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = BoolEncoder.EncodeTypePtr(left)

	args[1] = BoolEncoder.EncodeTypePtr(right)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* StripEscapes : strip_escapes
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) StripEscapes() String {
	mb := globalStringMethodBindings.method_strip_escapes
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Lstrip : lstrip
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Lstrip(chars String) String {
	mb := globalStringMethodBindings.method_lstrip
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&chars))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rstrip : rstrip
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Rstrip(chars String) String {
	mb := globalStringMethodBindings.method_rstrip
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&chars))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetExtension : get_extension
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) GetExtension() String {
	mb := globalStringMethodBindings.method_get_extension
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* GetBasename : get_basename
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) GetBasename() String {
	mb := globalStringMethodBindings.method_get_basename
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* PathJoin : path_join
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) PathJoin(file String) String {
	mb := globalStringMethodBindings.method_path_join
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&file))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* UnicodeAt : unicode_at
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) UnicodeAt(at int64) int64 {
	mb := globalStringMethodBindings.method_unicode_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(at)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Indent : indent
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Indent(prefix String) String {
	mb := globalStringMethodBindings.method_indent
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&prefix))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Dedent : dedent
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Dedent() String {
	mb := globalStringMethodBindings.method_dedent
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Hash : hash
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) Hash() int64 {
	mb := globalStringMethodBindings.method_hash
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* Md5Text : md5_text
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Md5Text() String {
	mb := globalStringMethodBindings.method_md5_text
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Sha1Text : sha1_text
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Sha1Text() String {
	mb := globalStringMethodBindings.method_sha1_text
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Sha256Text : sha256_text
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Sha256Text() String {
	mb := globalStringMethodBindings.method_sha256_text
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Md5Buffer : md5_buffer
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *String) Md5Buffer() PackedByteArray {
	mb := globalStringMethodBindings.method_md5_buffer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* Sha1Buffer : sha1_buffer
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *String) Sha1Buffer() PackedByteArray {
	mb := globalStringMethodBindings.method_sha1_buffer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* Sha256Buffer : sha256_buffer
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *String) Sha256Buffer() PackedByteArray {
	mb := globalStringMethodBindings.method_sha256_buffer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* IsEmpty : is_empty
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) IsEmpty() bool {
	mb := globalStringMethodBindings.method_is_empty
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Contains : contains
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) Contains(what String) bool {
	mb := globalStringMethodBindings.method_contains
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Containsn : containsn
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) Containsn(what String) bool {
	mb := globalStringMethodBindings.method_containsn
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsAbsolutePath : is_absolute_path
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) IsAbsolutePath() bool {
	mb := globalStringMethodBindings.method_is_absolute_path
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsRelativePath : is_relative_path
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) IsRelativePath() bool {
	mb := globalStringMethodBindings.method_is_relative_path
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* SimplifyPath : simplify_path
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) SimplifyPath() String {
	mb := globalStringMethodBindings.method_simplify_path
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* GetBaseDir : get_base_dir
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) GetBaseDir() String {
	mb := globalStringMethodBindings.method_get_base_dir
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* GetFile : get_file
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) GetFile() String {
	mb := globalStringMethodBindings.method_get_file
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* XmlEscape : xml_escape
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) XmlEscape(escape_quotes bool) String {
	mb := globalStringMethodBindings.method_xml_escape
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = BoolEncoder.EncodeTypePtr(escape_quotes)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* XmlUnescape : xml_unescape
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) XmlUnescape() String {
	mb := globalStringMethodBindings.method_xml_unescape
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* UriEncode : uri_encode
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) UriEncode() String {
	mb := globalStringMethodBindings.method_uri_encode
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* UriDecode : uri_decode
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) UriDecode() String {
	mb := globalStringMethodBindings.method_uri_decode
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* CEscape : c_escape
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) CEscape() String {
	mb := globalStringMethodBindings.method_c_escape
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* CUnescape : c_unescape
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) CUnescape() String {
	mb := globalStringMethodBindings.method_c_unescape
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* JsonEscape : json_escape
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) JsonEscape() String {
	mb := globalStringMethodBindings.method_json_escape
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* ValidateNodeName : validate_node_name
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) ValidateNodeName() String {
	mb := globalStringMethodBindings.method_validate_node_name
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* ValidateFilename : validate_filename
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) ValidateFilename() String {
	mb := globalStringMethodBindings.method_validate_filename
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* IsValidIdentifier : is_valid_identifier
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) IsValidIdentifier() bool {
	mb := globalStringMethodBindings.method_is_valid_identifier
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsValidInt : is_valid_int
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) IsValidInt() bool {
	mb := globalStringMethodBindings.method_is_valid_int
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsValidFloat : is_valid_float
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) IsValidFloat() bool {
	mb := globalStringMethodBindings.method_is_valid_float
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsValidHexNumber : is_valid_hex_number
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) IsValidHexNumber(with_prefix bool) bool {
	mb := globalStringMethodBindings.method_is_valid_hex_number
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = BoolEncoder.EncodeTypePtr(with_prefix)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsValidHtmlColor : is_valid_html_color
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) IsValidHtmlColor() bool {
	mb := globalStringMethodBindings.method_is_valid_html_color
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsValidIpAddress : is_valid_ip_address
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) IsValidIpAddress() bool {
	mb := globalStringMethodBindings.method_is_valid_ip_address
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsValidFilename : is_valid_filename
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *String) IsValidFilename() bool {
	mb := globalStringMethodBindings.method_is_valid_filename
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* ToInt : to_int
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) ToInt() int64 {
	mb := globalStringMethodBindings.method_to_int
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* ToFloat : to_float
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *String) ToFloat() float32 {
	mb := globalStringMethodBindings.method_to_float
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* HexToInt : hex_to_int
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) HexToInt() int64 {
	mb := globalStringMethodBindings.method_hex_to_int
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* BinToInt : bin_to_int
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *String) BinToInt() int64 {
	mb := globalStringMethodBindings.method_bin_to_int
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* Lpad : lpad
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Lpad(min_length int64, character String) String {
	mb := globalStringMethodBindings.method_lpad
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(min_length)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&character))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rpad : rpad
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) Rpad(min_length int64, character String) String {
	mb := globalStringMethodBindings.method_rpad
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(min_length)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&character))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* PadDecimals : pad_decimals
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) PadDecimals(digits int64) String {
	mb := globalStringMethodBindings.method_pad_decimals
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(digits)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* PadZeros : pad_zeros
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) PadZeros(digits int64) String {
	mb := globalStringMethodBindings.method_pad_zeros
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(digits)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* TrimPrefix : trim_prefix
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) TrimPrefix(prefix String) String {
	mb := globalStringMethodBindings.method_trim_prefix
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&prefix))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* TrimSuffix : trim_suffix
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *String) TrimSuffix(suffix String) String {
	mb := globalStringMethodBindings.method_trim_suffix
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&suffix))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* ToAsciiBuffer : to_ascii_buffer
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *String) ToAsciiBuffer() PackedByteArray {
	mb := globalStringMethodBindings.method_to_ascii_buffer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* ToUtf8Buffer : to_utf8_buffer
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *String) ToUtf8Buffer() PackedByteArray {
	mb := globalStringMethodBindings.method_to_utf8_buffer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* ToUtf16Buffer : to_utf16_buffer
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *String) ToUtf16Buffer() PackedByteArray {
	mb := globalStringMethodBindings.method_to_utf16_buffer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* ToUtf32Buffer : to_utf32_buffer
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *String) ToUtf32Buffer() PackedByteArray {
	mb := globalStringMethodBindings.method_to_utf32_buffer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* HexDecode : hex_decode
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *String) HexDecode() PackedByteArray {
	mb := globalStringMethodBindings.method_hex_decode
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* ToWcharBuffer : to_wchar_buffer
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *String) ToWcharBuffer() PackedByteArray {
	mb := globalStringMethodBindings.method_to_wchar_buffer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* NumScientific : num_scientific
 * is_vararg = false, is_static = true
 * goReturnType(String) -> String
 */
func (cx *String) NumScientific(number float32) String {
	mb := globalStringMethodBindings.method_num_scientific
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(number)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Num : num
 * is_vararg = false, is_static = true
 * goReturnType(String) -> String
 */
func (cx *String) Num(number float32, decimals int64) String {
	mb := globalStringMethodBindings.method_num
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(number)

	args[1] = Int64Encoder.EncodeTypePtr(decimals)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* NumInt64 : num_int64
 * is_vararg = false, is_static = true
 * goReturnType(String) -> String
 */
func (cx *String) NumInt64(number int64, base int64, capitalize_hex bool) String {
	mb := globalStringMethodBindings.method_num_int64
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 3
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(number)

	args[1] = Int64Encoder.EncodeTypePtr(base)

	args[2] = BoolEncoder.EncodeTypePtr(capitalize_hex)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* NumUint64 : num_uint64
 * is_vararg = false, is_static = true
 * goReturnType(String) -> String
 */
func (cx *String) NumUint64(number int64, base int64, capitalize_hex bool) String {
	mb := globalStringMethodBindings.method_num_uint64
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 3
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(number)

	args[1] = Int64Encoder.EncodeTypePtr(base)

	args[2] = BoolEncoder.EncodeTypePtr(capitalize_hex)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Chr : chr
 * is_vararg = false, is_static = true
 * goReturnType(String) -> String
 */
func (cx *String) Chr(char int64) String {
	mb := globalStringMethodBindings.method_chr
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(char)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* HumanizeSize : humanize_size
 * is_vararg = false, is_static = true
 * goReturnType(String) -> String
 */
func (cx *String) HumanizeSize(size int64) String {
	mb := globalStringMethodBindings.method_humanize_size
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(size)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *String) GetIndexed(i int64) String {
	var ret String
	CallFunc_GDExtensionPtrIndexedGetter(
		globalStringMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *String) SetIndexed(i int64, value String) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalStringMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members
// Equal_Variant operator
func (cx *String) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *String) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Module_Variant operator
func (cx *String) Module_Variant(right Variant) String {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Variant, lt, rt)
}

// Not operator
func (cx *String) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_not, lt, rt)
}

// Module_bool operator
func (cx *String) Module_bool(right bool) String {
	lt := cx.NativeConstPtr()
	eRight := BoolEncoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_bool, lt, rt)
}

// Module_int operator
func (cx *String) Module_int(right int64) String {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_int, lt, rt)
}

// Module_float operator
func (cx *String) Module_float(right float32) String {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_float, lt, rt)
}

// Equal_String operator
func (cx *String) Equal_String(right String) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_equal_String, lt, rt)
}

// Not_equal_String operator
func (cx *String) Not_equal_String(right String) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_not_equal_String, lt, rt)
}

// Less_String operator
func (cx *String) Less_String(right String) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_less_String, lt, rt)
}

// Less_equal_String operator
func (cx *String) Less_equal_String(right String) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_less_equal_String, lt, rt)
}

// Greater_String operator
func (cx *String) Greater_String(right String) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_greater_String, lt, rt)
}

// Greater_equal_String operator
func (cx *String) Greater_equal_String(right String) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_greater_equal_String, lt, rt)
}

// Add_String operator
func (cx *String) Add_String(right String) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_add_String, lt, rt)
}

// Module_String operator
func (cx *String) Module_String(right String) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_String, lt, rt)
}

// In_String operator
func (cx *String) In_String(right String) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_in_String, lt, rt)
}

// Module_Vector2 operator
func (cx *String) Module_Vector2(right Vector2) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Vector2, lt, rt)
}

// Module_Vector2i operator
func (cx *String) Module_Vector2i(right Vector2i) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Vector2i, lt, rt)
}

// Module_Rect2 operator
func (cx *String) Module_Rect2(right Rect2) String {
	lt := cx.NativeConstPtr()
	eRight := Rect2Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Rect2, lt, rt)
}

// Module_Rect2i operator
func (cx *String) Module_Rect2i(right Rect2i) String {
	lt := cx.NativeConstPtr()
	eRight := Rect2iEncoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Rect2i, lt, rt)
}

// Module_Vector3 operator
func (cx *String) Module_Vector3(right Vector3) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Vector3, lt, rt)
}

// Module_Vector3i operator
func (cx *String) Module_Vector3i(right Vector3i) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Vector3i, lt, rt)
}

// Module_Transform2D operator
func (cx *String) Module_Transform2D(right Transform2D) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Transform2D, lt, rt)
}

// Module_Vector4 operator
func (cx *String) Module_Vector4(right Vector4) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Vector4, lt, rt)
}

// Module_Vector4i operator
func (cx *String) Module_Vector4i(right Vector4i) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Vector4i, lt, rt)
}

// Module_Plane operator
func (cx *String) Module_Plane(right Plane) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Plane, lt, rt)
}

// Module_Quaternion operator
func (cx *String) Module_Quaternion(right Quaternion) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Quaternion, lt, rt)
}

// Module_AABB operator
func (cx *String) Module_AABB(right AABB) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_AABB, lt, rt)
}

// Module_Basis operator
func (cx *String) Module_Basis(right Basis) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Basis, lt, rt)
}

// Module_Transform3D operator
func (cx *String) Module_Transform3D(right Transform3D) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Transform3D, lt, rt)
}

// Module_Projection operator
func (cx *String) Module_Projection(right Projection) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Projection, lt, rt)
}

// Module_Color operator
func (cx *String) Module_Color(right Color) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Color, lt, rt)
}

// Equal_StringName operator
func (cx *String) Equal_StringName(right StringName) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_equal_StringName, lt, rt)
}

// Not_equal_StringName operator
func (cx *String) Not_equal_StringName(right StringName) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_not_equal_StringName, lt, rt)
}

// Add_StringName operator
func (cx *String) Add_StringName(right StringName) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_add_StringName, lt, rt)
}

// Module_StringName operator
func (cx *String) Module_StringName(right StringName) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_StringName, lt, rt)
}

// In_StringName operator
func (cx *String) In_StringName(right StringName) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_in_StringName, lt, rt)
}

// Module_NodePath operator
func (cx *String) Module_NodePath(right NodePath) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_NodePath, lt, rt)
}

// Module_Object operator
func (cx *String) Module_Object(right Object) String {
	lt := cx.NativeConstPtr()
	eRight := ObjectEncoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Object, lt, rt)
}

// In_Object operator
func (cx *String) In_Object(right Object) bool {
	lt := cx.NativeConstPtr()
	eRight := ObjectEncoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_in_Object, lt, rt)
}

// Module_Callable operator
func (cx *String) Module_Callable(right Callable) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Callable, lt, rt)
}

// Module_Signal operator
func (cx *String) Module_Signal(right Signal) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Signal, lt, rt)
}

// Module_Dictionary operator
func (cx *String) Module_Dictionary(right Dictionary) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Dictionary, lt, rt)
}

// In_Dictionary operator
func (cx *String) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_in_Dictionary, lt, rt)
}

// Module_Array operator
func (cx *String) Module_Array(right Array) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_Array, lt, rt)
}

// In_Array operator
func (cx *String) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_in_Array, lt, rt)
}

// Module_PackedByteArray operator
func (cx *String) Module_PackedByteArray(right PackedByteArray) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_PackedByteArray, lt, rt)
}

// Module_PackedInt32Array operator
func (cx *String) Module_PackedInt32Array(right PackedInt32Array) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_PackedInt32Array, lt, rt)
}

// Module_PackedInt64Array operator
func (cx *String) Module_PackedInt64Array(right PackedInt64Array) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_PackedInt64Array, lt, rt)
}

// Module_PackedFloat32Array operator
func (cx *String) Module_PackedFloat32Array(right PackedFloat32Array) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_PackedFloat32Array, lt, rt)
}

// Module_PackedFloat64Array operator
func (cx *String) Module_PackedFloat64Array(right PackedFloat64Array) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_PackedFloat64Array, lt, rt)
}

// Module_PackedStringArray operator
func (cx *String) Module_PackedStringArray(right PackedStringArray) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_PackedStringArray, lt, rt)
}

// In_PackedStringArray operator
func (cx *String) In_PackedStringArray(right PackedStringArray) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringMethodBindings.operator_in_PackedStringArray, lt, rt)
}

// Module_PackedVector2Array operator
func (cx *String) Module_PackedVector2Array(right PackedVector2Array) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_PackedVector2Array, lt, rt)
}

// Module_PackedVector3Array operator
func (cx *String) Module_PackedVector3Array(right PackedVector3Array) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_PackedVector3Array, lt, rt)
}

// Module_PackedColorArray operator
func (cx *String) Module_PackedColorArray(right PackedColorArray) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_PackedColorArray, lt, rt)
}

// Module_PackedVector4Array operator
func (cx *String) Module_PackedVector4Array(right PackedVector4Array) String {
	lt := cx.NativeConstPtr()
	eRight := PackedVector4ArrayEncoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[String](globalStringMethodBindings.operator_module_PackedVector4Array, lt, rt)
}

var _ GDBuiltInClass = &Vector2{}

/*
 * Vector2
 * indexingReturnType: float
 * isKeyed: false
 * hasDestructor: false
 */
type Vector2 [8]uint8

func (c *Vector2) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Vector2) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewVector2, index: 0
func NewVector2() Vector2 {
	cx := Vector2{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalVector2MethodBindings.constructor_0, ptr)
	return cx
}

// NewVector2, index: 1
func NewVector2WithVector2(from Vector2) Vector2 {
	cx := Vector2{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Vector2
	// Vector2Encoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalVector2MethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewVector2, index: 2
func NewVector2WithVector2i(from Vector2i) Vector2 {
	cx := Vector2{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Vector2i
	// Vector2iEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalVector2MethodBindings.constructor_2, ptr, args[0])
	return cx
}

// NewVector2, index: 3
func NewVector2WithFloat32Float32(x float32, y float32) Vector2 {
	cx := Vector2{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [2]GDExtensionConstTypePtr
	// float
	args[0] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(x))
	// float
	args[1] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(y))
	CallBuiltinConstructor(globalVector2MethodBindings.constructor_3, ptr, args[0], args[1])
	return cx
}

// copy funuctions
func NewVector2WithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Vector2 {
	ret := Vector2{}
	typedSrc := (*Vector2)(src)

	for i := 0; i < 8; i++ {
		ret[i] = typedSrc[i]
	}

	return (Vector2)(ret)
}
func copyVector2WithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Vector2)(dst)
	typedSrc := (*Vector2)(src)

	for i := 0; i < 8; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Angle : angle
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector2) Angle() float32 {
	mb := globalVector2MethodBindings.method_angle
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* AngleTo : angle_to
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector2) AngleTo(to Vector2) float32 {
	mb := globalVector2MethodBindings.method_angle_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* AngleToPoint : angle_to_point
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector2) AngleToPoint(to Vector2) float32 {
	mb := globalVector2MethodBindings.method_angle_to_point
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DirectionTo : direction_to
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) DirectionTo(to Vector2) Vector2 {
	mb := globalVector2MethodBindings.method_direction_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DistanceTo : distance_to
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector2) DistanceTo(to Vector2) float32 {
	mb := globalVector2MethodBindings.method_distance_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DistanceSquaredTo : distance_squared_to
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector2) DistanceSquaredTo(to Vector2) float32 {
	mb := globalVector2MethodBindings.method_distance_squared_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Length : length
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector2) Length() float32 {
	mb := globalVector2MethodBindings.method_length
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* LengthSquared : length_squared
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector2) LengthSquared() float32 {
	mb := globalVector2MethodBindings.method_length_squared
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* LimitLength : limit_length
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) LimitLength(length float32) Vector2 {
	mb := globalVector2MethodBindings.method_limit_length
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(length)

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Normalized : normalized
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Normalized() Vector2 {
	mb := globalVector2MethodBindings.method_normalized
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, nil)
	return ret
}

/* IsNormalized : is_normalized
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Vector2) IsNormalized() bool {
	mb := globalVector2MethodBindings.method_is_normalized
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsEqualApprox : is_equal_approx
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Vector2) IsEqualApprox(to Vector2) bool {
	mb := globalVector2MethodBindings.method_is_equal_approx
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsZeroApprox : is_zero_approx
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Vector2) IsZeroApprox() bool {
	mb := globalVector2MethodBindings.method_is_zero_approx
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsFinite : is_finite
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Vector2) IsFinite() bool {
	mb := globalVector2MethodBindings.method_is_finite
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Posmod : posmod
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Posmod(mod float32) Vector2 {
	mb := globalVector2MethodBindings.method_posmod
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(mod)

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Posmodv : posmodv
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Posmodv(modv Vector2) Vector2 {
	mb := globalVector2MethodBindings.method_posmodv
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&modv))

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Project : project
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Project(b Vector2) Vector2 {
	mb := globalVector2MethodBindings.method_project
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&b))

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Lerp : lerp
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Lerp(to Vector2, weight float32) Vector2 {
	mb := globalVector2MethodBindings.method_lerp
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	args[1] = Float32Encoder.EncodeTypePtr(weight)

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Slerp : slerp
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Slerp(to Vector2, weight float32) Vector2 {
	mb := globalVector2MethodBindings.method_slerp
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	args[1] = Float32Encoder.EncodeTypePtr(weight)

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* CubicInterpolate : cubic_interpolate
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) CubicInterpolate(b Vector2, pre_a Vector2, post_b Vector2, weight float32) Vector2 {
	mb := globalVector2MethodBindings.method_cubic_interpolate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 4
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&b))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&pre_a))

	args[2] = (GDExtensionTypePtr)(unsafe.Pointer(&post_b))

	args[3] = Float32Encoder.EncodeTypePtr(weight)

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* CubicInterpolateInTime : cubic_interpolate_in_time
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) CubicInterpolateInTime(b Vector2, pre_a Vector2, post_b Vector2, weight float32, b_t float32, pre_a_t float32, post_b_t float32) Vector2 {
	mb := globalVector2MethodBindings.method_cubic_interpolate_in_time
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 7
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&b))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&pre_a))

	args[2] = (GDExtensionTypePtr)(unsafe.Pointer(&post_b))

	args[3] = Float32Encoder.EncodeTypePtr(weight)

	args[4] = Float32Encoder.EncodeTypePtr(b_t)

	args[5] = Float32Encoder.EncodeTypePtr(pre_a_t)

	args[6] = Float32Encoder.EncodeTypePtr(post_b_t)

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* BezierInterpolate : bezier_interpolate
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) BezierInterpolate(control_1 Vector2, control_2 Vector2, end Vector2, t float32) Vector2 {
	mb := globalVector2MethodBindings.method_bezier_interpolate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 4
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&control_1))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&control_2))

	args[2] = (GDExtensionTypePtr)(unsafe.Pointer(&end))

	args[3] = Float32Encoder.EncodeTypePtr(t)

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* BezierDerivative : bezier_derivative
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) BezierDerivative(control_1 Vector2, control_2 Vector2, end Vector2, t float32) Vector2 {
	mb := globalVector2MethodBindings.method_bezier_derivative
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 4
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&control_1))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&control_2))

	args[2] = (GDExtensionTypePtr)(unsafe.Pointer(&end))

	args[3] = Float32Encoder.EncodeTypePtr(t)

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* MaxAxisIndex : max_axis_index
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector2) MaxAxisIndex() int64 {
	mb := globalVector2MethodBindings.method_max_axis_index
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* MinAxisIndex : min_axis_index
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector2) MinAxisIndex() int64 {
	mb := globalVector2MethodBindings.method_min_axis_index
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* MoveToward : move_toward
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) MoveToward(to Vector2, delta float32) Vector2 {
	mb := globalVector2MethodBindings.method_move_toward
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	args[1] = Float32Encoder.EncodeTypePtr(delta)

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rotated : rotated
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Rotated(angle float32) Vector2 {
	mb := globalVector2MethodBindings.method_rotated
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(angle)

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Orthogonal : orthogonal
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Orthogonal() Vector2 {
	mb := globalVector2MethodBindings.method_orthogonal
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, nil)
	return ret
}

/* Floor : floor
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Floor() Vector2 {
	mb := globalVector2MethodBindings.method_floor
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, nil)
	return ret
}

/* Ceil : ceil
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Ceil() Vector2 {
	mb := globalVector2MethodBindings.method_ceil
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, nil)
	return ret
}

/* Round : round
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Round() Vector2 {
	mb := globalVector2MethodBindings.method_round
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, nil)
	return ret
}

/* Aspect : aspect
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector2) Aspect() float32 {
	mb := globalVector2MethodBindings.method_aspect
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* Dot : dot
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector2) Dot(with Vector2) float32 {
	mb := globalVector2MethodBindings.method_dot
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Slide : slide
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Slide(n Vector2) Vector2 {
	mb := globalVector2MethodBindings.method_slide
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&n))

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Bounce : bounce
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Bounce(n Vector2) Vector2 {
	mb := globalVector2MethodBindings.method_bounce
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&n))

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Reflect : reflect
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Reflect(line Vector2) Vector2 {
	mb := globalVector2MethodBindings.method_reflect
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&line))

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Cross : cross
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector2) Cross(with Vector2) float32 {
	mb := globalVector2MethodBindings.method_cross
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Abs : abs
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Abs() Vector2 {
	mb := globalVector2MethodBindings.method_abs
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, nil)
	return ret
}

/* Sign : sign
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Sign() Vector2 {
	mb := globalVector2MethodBindings.method_sign
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, nil)
	return ret
}

/* Clamp : clamp
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Clamp(min Vector2, max Vector2) Vector2 {
	mb := globalVector2MethodBindings.method_clamp
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&min))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&max))

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clampf : clampf
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Clampf(min float32, max float32) Vector2 {
	mb := globalVector2MethodBindings.method_clampf
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(min)

	args[1] = Float32Encoder.EncodeTypePtr(max)

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Snapped : snapped
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Snapped(step Vector2) Vector2 {
	mb := globalVector2MethodBindings.method_snapped
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&step))

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Snappedf : snappedf
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Snappedf(step float32) Vector2 {
	mb := globalVector2MethodBindings.method_snappedf
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(step)

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Min : min
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Min(with Vector2) Vector2 {
	mb := globalVector2MethodBindings.method_min
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Minf : minf
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Minf(with float32) Vector2 {
	mb := globalVector2MethodBindings.method_minf
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(with)

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Max : max
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Max(with Vector2) Vector2 {
	mb := globalVector2MethodBindings.method_max
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Maxf : maxf
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) Maxf(with float32) Vector2 {
	mb := globalVector2MethodBindings.method_maxf
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(with)

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* FromAngle : from_angle
 * is_vararg = false, is_static = true
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector2) FromAngle(angle float32) Vector2 {
	mb := globalVector2MethodBindings.method_from_angle
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(angle)

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *Vector2) GetIndexed(i int64) float32 {
	var ret float32
	CallFunc_GDExtensionPtrIndexedGetter(
		globalVector2MethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *Vector2) SetIndexed(i int64, value float32) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalVector2MethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members

func (cx *Vector2) MemberGetx() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalVector2MethodBindings.member_x_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Vector2) MemberGety() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalVector2MethodBindings.member_y_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

// Equal_Variant operator
func (cx *Vector2) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalVector2MethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Vector2) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalVector2MethodBindings.operator_not_equal_Variant, lt, rt)
}

// Negate operator
func (cx *Vector2) Negate() Vector2 {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Vector2](globalVector2MethodBindings.operator_negate, lt, rt)
}

// Positive operator
func (cx *Vector2) Positive() Vector2 {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Vector2](globalVector2MethodBindings.operator_positive, lt, rt)
}

// Not operator
func (cx *Vector2) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalVector2MethodBindings.operator_not, lt, rt)
}

// Multiply_int operator
func (cx *Vector2) Multiply_int(right int64) Vector2 {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector2](globalVector2MethodBindings.operator_multiply_int, lt, rt)
}

// Divide_int operator
func (cx *Vector2) Divide_int(right int64) Vector2 {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector2](globalVector2MethodBindings.operator_divide_int, lt, rt)
}

// Multiply_float operator
func (cx *Vector2) Multiply_float(right float32) Vector2 {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector2](globalVector2MethodBindings.operator_multiply_float, lt, rt)
}

// Divide_float operator
func (cx *Vector2) Divide_float(right float32) Vector2 {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector2](globalVector2MethodBindings.operator_divide_float, lt, rt)
}

// Equal_Vector2 operator
func (cx *Vector2) Equal_Vector2(right Vector2) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2MethodBindings.operator_equal_Vector2, lt, rt)
}

// Not_equal_Vector2 operator
func (cx *Vector2) Not_equal_Vector2(right Vector2) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2MethodBindings.operator_not_equal_Vector2, lt, rt)
}

// Less_Vector2 operator
func (cx *Vector2) Less_Vector2(right Vector2) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2MethodBindings.operator_less_Vector2, lt, rt)
}

// Less_equal_Vector2 operator
func (cx *Vector2) Less_equal_Vector2(right Vector2) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2MethodBindings.operator_less_equal_Vector2, lt, rt)
}

// Greater_Vector2 operator
func (cx *Vector2) Greater_Vector2(right Vector2) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2MethodBindings.operator_greater_Vector2, lt, rt)
}

// Greater_equal_Vector2 operator
func (cx *Vector2) Greater_equal_Vector2(right Vector2) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2MethodBindings.operator_greater_equal_Vector2, lt, rt)
}

// Add_Vector2 operator
func (cx *Vector2) Add_Vector2(right Vector2) Vector2 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector2](globalVector2MethodBindings.operator_add_Vector2, lt, rt)
}

// Subtract_Vector2 operator
func (cx *Vector2) Subtract_Vector2(right Vector2) Vector2 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector2](globalVector2MethodBindings.operator_subtract_Vector2, lt, rt)
}

// Multiply_Vector2 operator
func (cx *Vector2) Multiply_Vector2(right Vector2) Vector2 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector2](globalVector2MethodBindings.operator_multiply_Vector2, lt, rt)
}

// Divide_Vector2 operator
func (cx *Vector2) Divide_Vector2(right Vector2) Vector2 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector2](globalVector2MethodBindings.operator_divide_Vector2, lt, rt)
}

// Multiply_Transform2D operator
func (cx *Vector2) Multiply_Transform2D(right Transform2D) Vector2 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector2](globalVector2MethodBindings.operator_multiply_Transform2D, lt, rt)
}

// In_Dictionary operator
func (cx *Vector2) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2MethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Vector2) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2MethodBindings.operator_in_Array, lt, rt)
}

// In_PackedVector2Array operator
func (cx *Vector2) In_PackedVector2Array(right PackedVector2Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2MethodBindings.operator_in_PackedVector2Array, lt, rt)
}

var _ GDBuiltInClass = &Vector2i{}

/*
 * Vector2i
 * indexingReturnType: int
 * isKeyed: false
 * hasDestructor: false
 */
type Vector2i [8]uint8

func (c *Vector2i) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Vector2i) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewVector2i, index: 0
func NewVector2i() Vector2i {
	cx := Vector2i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalVector2iMethodBindings.constructor_0, ptr)
	return cx
}

// NewVector2i, index: 1
func NewVector2iWithVector2i(from Vector2i) Vector2i {
	cx := Vector2i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Vector2i
	// Vector2iEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalVector2iMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewVector2i, index: 2
func NewVector2iWithVector2(from Vector2) Vector2i {
	cx := Vector2i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Vector2
	// Vector2Encoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalVector2iMethodBindings.constructor_2, ptr, args[0])
	return cx
}

// NewVector2i, index: 3
func NewVector2iWithInt64Int64(x int64, y int64) Vector2i {
	cx := Vector2i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [2]GDExtensionConstTypePtr
	// int
	args[0] = (GDExtensionConstTypePtr)(Int64Encoder.EncodeTypePtr(x))
	// int
	args[1] = (GDExtensionConstTypePtr)(Int64Encoder.EncodeTypePtr(y))
	CallBuiltinConstructor(globalVector2iMethodBindings.constructor_3, ptr, args[0], args[1])
	return cx
}

// copy funuctions
func NewVector2iWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Vector2i {
	ret := Vector2i{}
	typedSrc := (*Vector2i)(src)

	for i := 0; i < 8; i++ {
		ret[i] = typedSrc[i]
	}

	return (Vector2i)(ret)
}
func copyVector2iWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Vector2i)(dst)
	typedSrc := (*Vector2i)(src)

	for i := 0; i < 8; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Aspect : aspect
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector2i) Aspect() float32 {
	mb := globalVector2iMethodBindings.method_aspect
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* MaxAxisIndex : max_axis_index
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector2i) MaxAxisIndex() int64 {
	mb := globalVector2iMethodBindings.method_max_axis_index
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* MinAxisIndex : min_axis_index
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector2i) MinAxisIndex() int64 {
	mb := globalVector2iMethodBindings.method_min_axis_index
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* DistanceTo : distance_to
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector2i) DistanceTo(to Vector2i) float32 {
	mb := globalVector2iMethodBindings.method_distance_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DistanceSquaredTo : distance_squared_to
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector2i) DistanceSquaredTo(to Vector2i) int64 {
	mb := globalVector2iMethodBindings.method_distance_squared_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Length : length
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector2i) Length() float32 {
	mb := globalVector2iMethodBindings.method_length
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* LengthSquared : length_squared
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector2i) LengthSquared() int64 {
	mb := globalVector2iMethodBindings.method_length_squared
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* Sign : sign
 * is_vararg = false, is_static = false
 * goReturnType(Vector2i) -> Vector2i
 */
func (cx *Vector2i) Sign() Vector2i {
	mb := globalVector2iMethodBindings.method_sign
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector2i](mb, bx, nil)
	return ret
}

/* Abs : abs
 * is_vararg = false, is_static = false
 * goReturnType(Vector2i) -> Vector2i
 */
func (cx *Vector2i) Abs() Vector2i {
	mb := globalVector2iMethodBindings.method_abs
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector2i](mb, bx, nil)
	return ret
}

/* Clamp : clamp
 * is_vararg = false, is_static = false
 * goReturnType(Vector2i) -> Vector2i
 */
func (cx *Vector2i) Clamp(min Vector2i, max Vector2i) Vector2i {
	mb := globalVector2iMethodBindings.method_clamp
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&min))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&max))

	ret := CallBuiltinMethodPtrRet[Vector2i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clampi : clampi
 * is_vararg = false, is_static = false
 * goReturnType(Vector2i) -> Vector2i
 */
func (cx *Vector2i) Clampi(min int64, max int64) Vector2i {
	mb := globalVector2iMethodBindings.method_clampi
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(min)

	args[1] = Int64Encoder.EncodeTypePtr(max)

	ret := CallBuiltinMethodPtrRet[Vector2i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Snapped : snapped
 * is_vararg = false, is_static = false
 * goReturnType(Vector2i) -> Vector2i
 */
func (cx *Vector2i) Snapped(step Vector2i) Vector2i {
	mb := globalVector2iMethodBindings.method_snapped
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&step))

	ret := CallBuiltinMethodPtrRet[Vector2i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Snappedi : snappedi
 * is_vararg = false, is_static = false
 * goReturnType(Vector2i) -> Vector2i
 */
func (cx *Vector2i) Snappedi(step int64) Vector2i {
	mb := globalVector2iMethodBindings.method_snappedi
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(step)

	ret := CallBuiltinMethodPtrRet[Vector2i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Min : min
 * is_vararg = false, is_static = false
 * goReturnType(Vector2i) -> Vector2i
 */
func (cx *Vector2i) Min(with Vector2i) Vector2i {
	mb := globalVector2iMethodBindings.method_min
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[Vector2i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Mini : mini
 * is_vararg = false, is_static = false
 * goReturnType(Vector2i) -> Vector2i
 */
func (cx *Vector2i) Mini(with int64) Vector2i {
	mb := globalVector2iMethodBindings.method_mini
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(with)

	ret := CallBuiltinMethodPtrRet[Vector2i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Max : max
 * is_vararg = false, is_static = false
 * goReturnType(Vector2i) -> Vector2i
 */
func (cx *Vector2i) Max(with Vector2i) Vector2i {
	mb := globalVector2iMethodBindings.method_max
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[Vector2i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Maxi : maxi
 * is_vararg = false, is_static = false
 * goReturnType(Vector2i) -> Vector2i
 */
func (cx *Vector2i) Maxi(with int64) Vector2i {
	mb := globalVector2iMethodBindings.method_maxi
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(with)

	ret := CallBuiltinMethodPtrRet[Vector2i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *Vector2i) GetIndexed(i int64) int64 {
	var ret int64
	CallFunc_GDExtensionPtrIndexedGetter(
		globalVector2iMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *Vector2i) SetIndexed(i int64, value int64) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalVector2iMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members

func (cx *Vector2i) MemberGetx() int64 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[int64](globalVector2iMethodBindings.member_x_getter, bx)
	return ret

}

func (cx *Vector2i) MemberGety() int64 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[int64](globalVector2iMethodBindings.member_y_getter, bx)
	return ret

}

// Equal_Variant operator
func (cx *Vector2i) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalVector2iMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Vector2i) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalVector2iMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Negate operator
func (cx *Vector2i) Negate() Vector2i {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Vector2i](globalVector2iMethodBindings.operator_negate, lt, rt)
}

// Positive operator
func (cx *Vector2i) Positive() Vector2i {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Vector2i](globalVector2iMethodBindings.operator_positive, lt, rt)
}

// Not operator
func (cx *Vector2i) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalVector2iMethodBindings.operator_not, lt, rt)
}

// Multiply_int operator
func (cx *Vector2i) Multiply_int(right int64) Vector2i {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector2i](globalVector2iMethodBindings.operator_multiply_int, lt, rt)
}

// Divide_int operator
func (cx *Vector2i) Divide_int(right int64) Vector2i {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector2i](globalVector2iMethodBindings.operator_divide_int, lt, rt)
}

// Module_int operator
func (cx *Vector2i) Module_int(right int64) Vector2i {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector2i](globalVector2iMethodBindings.operator_module_int, lt, rt)
}

// Multiply_float operator
func (cx *Vector2i) Multiply_float(right float32) Vector2 {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector2](globalVector2iMethodBindings.operator_multiply_float, lt, rt)
}

// Divide_float operator
func (cx *Vector2i) Divide_float(right float32) Vector2 {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector2](globalVector2iMethodBindings.operator_divide_float, lt, rt)
}

// Equal_Vector2i operator
func (cx *Vector2i) Equal_Vector2i(right Vector2i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2iMethodBindings.operator_equal_Vector2i, lt, rt)
}

// Not_equal_Vector2i operator
func (cx *Vector2i) Not_equal_Vector2i(right Vector2i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2iMethodBindings.operator_not_equal_Vector2i, lt, rt)
}

// Less_Vector2i operator
func (cx *Vector2i) Less_Vector2i(right Vector2i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2iMethodBindings.operator_less_Vector2i, lt, rt)
}

// Less_equal_Vector2i operator
func (cx *Vector2i) Less_equal_Vector2i(right Vector2i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2iMethodBindings.operator_less_equal_Vector2i, lt, rt)
}

// Greater_Vector2i operator
func (cx *Vector2i) Greater_Vector2i(right Vector2i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2iMethodBindings.operator_greater_Vector2i, lt, rt)
}

// Greater_equal_Vector2i operator
func (cx *Vector2i) Greater_equal_Vector2i(right Vector2i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2iMethodBindings.operator_greater_equal_Vector2i, lt, rt)
}

// Add_Vector2i operator
func (cx *Vector2i) Add_Vector2i(right Vector2i) Vector2i {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector2i](globalVector2iMethodBindings.operator_add_Vector2i, lt, rt)
}

// Subtract_Vector2i operator
func (cx *Vector2i) Subtract_Vector2i(right Vector2i) Vector2i {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector2i](globalVector2iMethodBindings.operator_subtract_Vector2i, lt, rt)
}

// Multiply_Vector2i operator
func (cx *Vector2i) Multiply_Vector2i(right Vector2i) Vector2i {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector2i](globalVector2iMethodBindings.operator_multiply_Vector2i, lt, rt)
}

// Divide_Vector2i operator
func (cx *Vector2i) Divide_Vector2i(right Vector2i) Vector2i {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector2i](globalVector2iMethodBindings.operator_divide_Vector2i, lt, rt)
}

// Module_Vector2i operator
func (cx *Vector2i) Module_Vector2i(right Vector2i) Vector2i {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector2i](globalVector2iMethodBindings.operator_module_Vector2i, lt, rt)
}

// In_Dictionary operator
func (cx *Vector2i) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2iMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Vector2i) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector2iMethodBindings.operator_in_Array, lt, rt)
}

var _ GDBuiltInClass = &Rect2{}

/*
 * Rect2
 * indexingReturnType:
 * isKeyed: false
 * hasDestructor: false
 */
type Rect2 [16]uint8

func (c *Rect2) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Rect2) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewRect2, index: 0
func NewRect2() Rect2 {
	cx := Rect2{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalRect2MethodBindings.constructor_0, ptr)
	return cx
}

// NewRect2, index: 1
func NewRect2WithRect2(from Rect2) Rect2 {
	cx := Rect2{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Rect2
	// Rect2Encoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalRect2MethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewRect2, index: 2
func NewRect2WithRect2i(from Rect2i) Rect2 {
	cx := Rect2{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Rect2i
	// Rect2iEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalRect2MethodBindings.constructor_2, ptr, args[0])
	return cx
}

// NewRect2, index: 3
func NewRect2WithVector2Vector2(position Vector2, size Vector2) Rect2 {
	cx := Rect2{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [2]GDExtensionConstTypePtr
	// Vector2
	// Vector2Encoder
	args[0] = position.NativeConstPtr()
	// Vector2
	// Vector2Encoder
	args[1] = size.NativeConstPtr()
	CallBuiltinConstructor(globalRect2MethodBindings.constructor_3, ptr, args[0], args[1])
	return cx
}

// NewRect2, index: 4
func NewRect2WithFloat32Float32Float32Float32(x float32, y float32, width float32, height float32) Rect2 {
	cx := Rect2{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [4]GDExtensionConstTypePtr
	// float
	args[0] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(x))
	// float
	args[1] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(y))
	// float
	args[2] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(width))
	// float
	args[3] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(height))
	CallBuiltinConstructor(globalRect2MethodBindings.constructor_4, ptr, args[0], args[1], args[2], args[3])
	return cx
}

// copy funuctions
func NewRect2WithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Rect2 {
	ret := Rect2{}
	typedSrc := (*Rect2)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (Rect2)(ret)
}
func copyRect2WithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Rect2)(dst)
	typedSrc := (*Rect2)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* GetCenter : get_center
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Rect2) GetCenter() Vector2 {
	mb := globalRect2MethodBindings.method_get_center
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, nil)
	return ret
}

/* GetArea : get_area
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Rect2) GetArea() float32 {
	mb := globalRect2MethodBindings.method_get_area
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* HasArea : has_area
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Rect2) HasArea() bool {
	mb := globalRect2MethodBindings.method_has_area
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* HasPoint : has_point
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Rect2) HasPoint(point Vector2) bool {
	mb := globalRect2MethodBindings.method_has_point
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&point))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsEqualApprox : is_equal_approx
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Rect2) IsEqualApprox(rect Rect2) bool {
	mb := globalRect2MethodBindings.method_is_equal_approx
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Rect2Encoder.EncodeTypePtr(rect)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsFinite : is_finite
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Rect2) IsFinite() bool {
	mb := globalRect2MethodBindings.method_is_finite
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Intersects : intersects
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Rect2) Intersects(b Rect2, include_borders bool) bool {
	mb := globalRect2MethodBindings.method_intersects
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Rect2Encoder.EncodeTypePtr(b)

	args[1] = BoolEncoder.EncodeTypePtr(include_borders)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Encloses : encloses
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Rect2) Encloses(b Rect2) bool {
	mb := globalRect2MethodBindings.method_encloses
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Rect2Encoder.EncodeTypePtr(b)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Intersection : intersection
 * is_vararg = false, is_static = false
 * goReturnType(Rect2) -> Rect2
 */
func (cx *Rect2) Intersection(b Rect2) Rect2 {
	mb := globalRect2MethodBindings.method_intersection
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Rect2Encoder.EncodeTypePtr(b)

	ret := CallBuiltinMethodPtrRet[Rect2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Merge : merge
 * is_vararg = false, is_static = false
 * goReturnType(Rect2) -> Rect2
 */
func (cx *Rect2) Merge(b Rect2) Rect2 {
	mb := globalRect2MethodBindings.method_merge
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Rect2Encoder.EncodeTypePtr(b)

	ret := CallBuiltinMethodPtrRet[Rect2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Expand : expand
 * is_vararg = false, is_static = false
 * goReturnType(Rect2) -> Rect2
 */
func (cx *Rect2) Expand(to Vector2) Rect2 {
	mb := globalRect2MethodBindings.method_expand
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[Rect2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Grow : grow
 * is_vararg = false, is_static = false
 * goReturnType(Rect2) -> Rect2
 */
func (cx *Rect2) Grow(amount float32) Rect2 {
	mb := globalRect2MethodBindings.method_grow
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(amount)

	ret := CallBuiltinMethodPtrRet[Rect2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GrowSide : grow_side
 * is_vararg = false, is_static = false
 * goReturnType(Rect2) -> Rect2
 */
func (cx *Rect2) GrowSide(side int64, amount float32) Rect2 {
	mb := globalRect2MethodBindings.method_grow_side
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(side)

	args[1] = Float32Encoder.EncodeTypePtr(amount)

	ret := CallBuiltinMethodPtrRet[Rect2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GrowIndividual : grow_individual
 * is_vararg = false, is_static = false
 * goReturnType(Rect2) -> Rect2
 */
func (cx *Rect2) GrowIndividual(left float32, top float32, right float32, bottom float32) Rect2 {
	mb := globalRect2MethodBindings.method_grow_individual
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 4
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(left)

	args[1] = Float32Encoder.EncodeTypePtr(top)

	args[2] = Float32Encoder.EncodeTypePtr(right)

	args[3] = Float32Encoder.EncodeTypePtr(bottom)

	ret := CallBuiltinMethodPtrRet[Rect2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Abs : abs
 * is_vararg = false, is_static = false
 * goReturnType(Rect2) -> Rect2
 */
func (cx *Rect2) Abs() Rect2 {
	mb := globalRect2MethodBindings.method_abs
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Rect2](mb, bx, nil)
	return ret
}

// members

func (cx *Rect2) MemberGetposition() Vector2 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector2](globalRect2MethodBindings.member_position_getter, bx)
	return ret

}

func (cx *Rect2) MemberGetsize() Vector2 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector2](globalRect2MethodBindings.member_size_getter, bx)
	return ret

}

func (cx *Rect2) MemberGetend() Vector2 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector2](globalRect2MethodBindings.member_end_getter, bx)
	return ret

}

// Equal_Variant operator
func (cx *Rect2) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalRect2MethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Rect2) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalRect2MethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *Rect2) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalRect2MethodBindings.operator_not, lt, rt)
}

// Equal_Rect2 operator
func (cx *Rect2) Equal_Rect2(right Rect2) bool {
	lt := cx.NativeConstPtr()
	eRight := Rect2Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[bool](globalRect2MethodBindings.operator_equal_Rect2, lt, rt)
}

// Not_equal_Rect2 operator
func (cx *Rect2) Not_equal_Rect2(right Rect2) bool {
	lt := cx.NativeConstPtr()
	eRight := Rect2Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[bool](globalRect2MethodBindings.operator_not_equal_Rect2, lt, rt)
}

// Multiply_Transform2D operator
func (cx *Rect2) Multiply_Transform2D(right Transform2D) Rect2 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Rect2](globalRect2MethodBindings.operator_multiply_Transform2D, lt, rt)
}

// In_Dictionary operator
func (cx *Rect2) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalRect2MethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Rect2) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalRect2MethodBindings.operator_in_Array, lt, rt)
}

var _ GDBuiltInClass = &Rect2i{}

/*
 * Rect2i
 * indexingReturnType:
 * isKeyed: false
 * hasDestructor: false
 */
type Rect2i [16]uint8

func (c *Rect2i) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Rect2i) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewRect2i, index: 0
func NewRect2i() Rect2i {
	cx := Rect2i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalRect2iMethodBindings.constructor_0, ptr)
	return cx
}

// NewRect2i, index: 1
func NewRect2iWithRect2i(from Rect2i) Rect2i {
	cx := Rect2i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Rect2i
	// Rect2iEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalRect2iMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewRect2i, index: 2
func NewRect2iWithRect2(from Rect2) Rect2i {
	cx := Rect2i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Rect2
	// Rect2Encoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalRect2iMethodBindings.constructor_2, ptr, args[0])
	return cx
}

// NewRect2i, index: 3
func NewRect2iWithVector2iVector2i(position Vector2i, size Vector2i) Rect2i {
	cx := Rect2i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [2]GDExtensionConstTypePtr
	// Vector2i
	// Vector2iEncoder
	args[0] = position.NativeConstPtr()
	// Vector2i
	// Vector2iEncoder
	args[1] = size.NativeConstPtr()
	CallBuiltinConstructor(globalRect2iMethodBindings.constructor_3, ptr, args[0], args[1])
	return cx
}

// NewRect2i, index: 4
func NewRect2iWithInt64Int64Int64Int64(x int64, y int64, width int64, height int64) Rect2i {
	cx := Rect2i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [4]GDExtensionConstTypePtr
	// int
	args[0] = (GDExtensionConstTypePtr)(Int64Encoder.EncodeTypePtr(x))
	// int
	args[1] = (GDExtensionConstTypePtr)(Int64Encoder.EncodeTypePtr(y))
	// int
	args[2] = (GDExtensionConstTypePtr)(Int64Encoder.EncodeTypePtr(width))
	// int
	args[3] = (GDExtensionConstTypePtr)(Int64Encoder.EncodeTypePtr(height))
	CallBuiltinConstructor(globalRect2iMethodBindings.constructor_4, ptr, args[0], args[1], args[2], args[3])
	return cx
}

// copy funuctions
func NewRect2iWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Rect2i {
	ret := Rect2i{}
	typedSrc := (*Rect2i)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (Rect2i)(ret)
}
func copyRect2iWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Rect2i)(dst)
	typedSrc := (*Rect2i)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* GetCenter : get_center
 * is_vararg = false, is_static = false
 * goReturnType(Vector2i) -> Vector2i
 */
func (cx *Rect2i) GetCenter() Vector2i {
	mb := globalRect2iMethodBindings.method_get_center
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector2i](mb, bx, nil)
	return ret
}

/* GetArea : get_area
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Rect2i) GetArea() int64 {
	mb := globalRect2iMethodBindings.method_get_area
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* HasArea : has_area
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Rect2i) HasArea() bool {
	mb := globalRect2iMethodBindings.method_has_area
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* HasPoint : has_point
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Rect2i) HasPoint(point Vector2i) bool {
	mb := globalRect2iMethodBindings.method_has_point
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&point))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Intersects : intersects
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Rect2i) Intersects(b Rect2i) bool {
	mb := globalRect2iMethodBindings.method_intersects
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Rect2iEncoder.EncodeTypePtr(b)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Encloses : encloses
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Rect2i) Encloses(b Rect2i) bool {
	mb := globalRect2iMethodBindings.method_encloses
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Rect2iEncoder.EncodeTypePtr(b)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Intersection : intersection
 * is_vararg = false, is_static = false
 * goReturnType(Rect2i) -> Rect2i
 */
func (cx *Rect2i) Intersection(b Rect2i) Rect2i {
	mb := globalRect2iMethodBindings.method_intersection
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Rect2iEncoder.EncodeTypePtr(b)

	ret := CallBuiltinMethodPtrRet[Rect2i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Merge : merge
 * is_vararg = false, is_static = false
 * goReturnType(Rect2i) -> Rect2i
 */
func (cx *Rect2i) Merge(b Rect2i) Rect2i {
	mb := globalRect2iMethodBindings.method_merge
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Rect2iEncoder.EncodeTypePtr(b)

	ret := CallBuiltinMethodPtrRet[Rect2i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Expand : expand
 * is_vararg = false, is_static = false
 * goReturnType(Rect2i) -> Rect2i
 */
func (cx *Rect2i) Expand(to Vector2i) Rect2i {
	mb := globalRect2iMethodBindings.method_expand
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[Rect2i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Grow : grow
 * is_vararg = false, is_static = false
 * goReturnType(Rect2i) -> Rect2i
 */
func (cx *Rect2i) Grow(amount int64) Rect2i {
	mb := globalRect2iMethodBindings.method_grow
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(amount)

	ret := CallBuiltinMethodPtrRet[Rect2i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GrowSide : grow_side
 * is_vararg = false, is_static = false
 * goReturnType(Rect2i) -> Rect2i
 */
func (cx *Rect2i) GrowSide(side int64, amount int64) Rect2i {
	mb := globalRect2iMethodBindings.method_grow_side
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(side)

	args[1] = Int64Encoder.EncodeTypePtr(amount)

	ret := CallBuiltinMethodPtrRet[Rect2i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GrowIndividual : grow_individual
 * is_vararg = false, is_static = false
 * goReturnType(Rect2i) -> Rect2i
 */
func (cx *Rect2i) GrowIndividual(left int64, top int64, right int64, bottom int64) Rect2i {
	mb := globalRect2iMethodBindings.method_grow_individual
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 4
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(left)

	args[1] = Int64Encoder.EncodeTypePtr(top)

	args[2] = Int64Encoder.EncodeTypePtr(right)

	args[3] = Int64Encoder.EncodeTypePtr(bottom)

	ret := CallBuiltinMethodPtrRet[Rect2i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Abs : abs
 * is_vararg = false, is_static = false
 * goReturnType(Rect2i) -> Rect2i
 */
func (cx *Rect2i) Abs() Rect2i {
	mb := globalRect2iMethodBindings.method_abs
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Rect2i](mb, bx, nil)
	return ret
}

// members

func (cx *Rect2i) MemberGetposition() Vector2i {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector2i](globalRect2iMethodBindings.member_position_getter, bx)
	return ret

}

func (cx *Rect2i) MemberGetsize() Vector2i {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector2i](globalRect2iMethodBindings.member_size_getter, bx)
	return ret

}

func (cx *Rect2i) MemberGetend() Vector2i {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector2i](globalRect2iMethodBindings.member_end_getter, bx)
	return ret

}

// Equal_Variant operator
func (cx *Rect2i) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalRect2iMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Rect2i) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalRect2iMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *Rect2i) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalRect2iMethodBindings.operator_not, lt, rt)
}

// Equal_Rect2i operator
func (cx *Rect2i) Equal_Rect2i(right Rect2i) bool {
	lt := cx.NativeConstPtr()
	eRight := Rect2iEncoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[bool](globalRect2iMethodBindings.operator_equal_Rect2i, lt, rt)
}

// Not_equal_Rect2i operator
func (cx *Rect2i) Not_equal_Rect2i(right Rect2i) bool {
	lt := cx.NativeConstPtr()
	eRight := Rect2iEncoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[bool](globalRect2iMethodBindings.operator_not_equal_Rect2i, lt, rt)
}

// In_Dictionary operator
func (cx *Rect2i) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalRect2iMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Rect2i) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalRect2iMethodBindings.operator_in_Array, lt, rt)
}

var _ GDBuiltInClass = &Vector3{}

/*
 * Vector3
 * indexingReturnType: float
 * isKeyed: false
 * hasDestructor: false
 */
type Vector3 [12]uint8

func (c *Vector3) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Vector3) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewVector3, index: 0
func NewVector3() Vector3 {
	cx := Vector3{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalVector3MethodBindings.constructor_0, ptr)
	return cx
}

// NewVector3, index: 1
func NewVector3WithVector3(from Vector3) Vector3 {
	cx := Vector3{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Vector3
	// Vector3Encoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalVector3MethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewVector3, index: 2
func NewVector3WithVector3i(from Vector3i) Vector3 {
	cx := Vector3{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Vector3i
	// Vector3iEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalVector3MethodBindings.constructor_2, ptr, args[0])
	return cx
}

// NewVector3, index: 3
func NewVector3WithFloat32Float32Float32(x float32, y float32, z float32) Vector3 {
	cx := Vector3{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [3]GDExtensionConstTypePtr
	// float
	args[0] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(x))
	// float
	args[1] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(y))
	// float
	args[2] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(z))
	CallBuiltinConstructor(globalVector3MethodBindings.constructor_3, ptr, args[0], args[1], args[2])
	return cx
}

// copy funuctions
func NewVector3WithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Vector3 {
	ret := Vector3{}
	typedSrc := (*Vector3)(src)

	for i := 0; i < 12; i++ {
		ret[i] = typedSrc[i]
	}

	return (Vector3)(ret)
}
func copyVector3WithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Vector3)(dst)
	typedSrc := (*Vector3)(src)

	for i := 0; i < 12; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* MinAxisIndex : min_axis_index
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector3) MinAxisIndex() int64 {
	mb := globalVector3MethodBindings.method_min_axis_index
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* MaxAxisIndex : max_axis_index
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector3) MaxAxisIndex() int64 {
	mb := globalVector3MethodBindings.method_max_axis_index
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* AngleTo : angle_to
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector3) AngleTo(to Vector3) float32 {
	mb := globalVector3MethodBindings.method_angle_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* SignedAngleTo : signed_angle_to
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector3) SignedAngleTo(to Vector3, axis Vector3) float32 {
	mb := globalVector3MethodBindings.method_signed_angle_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&axis))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DirectionTo : direction_to
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) DirectionTo(to Vector3) Vector3 {
	mb := globalVector3MethodBindings.method_direction_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DistanceTo : distance_to
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector3) DistanceTo(to Vector3) float32 {
	mb := globalVector3MethodBindings.method_distance_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DistanceSquaredTo : distance_squared_to
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector3) DistanceSquaredTo(to Vector3) float32 {
	mb := globalVector3MethodBindings.method_distance_squared_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Length : length
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector3) Length() float32 {
	mb := globalVector3MethodBindings.method_length
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* LengthSquared : length_squared
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector3) LengthSquared() float32 {
	mb := globalVector3MethodBindings.method_length_squared
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* LimitLength : limit_length
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) LimitLength(length float32) Vector3 {
	mb := globalVector3MethodBindings.method_limit_length
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(length)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Normalized : normalized
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Normalized() Vector3 {
	mb := globalVector3MethodBindings.method_normalized
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, nil)
	return ret
}

/* IsNormalized : is_normalized
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Vector3) IsNormalized() bool {
	mb := globalVector3MethodBindings.method_is_normalized
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsEqualApprox : is_equal_approx
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Vector3) IsEqualApprox(to Vector3) bool {
	mb := globalVector3MethodBindings.method_is_equal_approx
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsZeroApprox : is_zero_approx
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Vector3) IsZeroApprox() bool {
	mb := globalVector3MethodBindings.method_is_zero_approx
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsFinite : is_finite
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Vector3) IsFinite() bool {
	mb := globalVector3MethodBindings.method_is_finite
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Inverse : inverse
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Inverse() Vector3 {
	mb := globalVector3MethodBindings.method_inverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, nil)
	return ret
}

/* Clamp : clamp
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Clamp(min Vector3, max Vector3) Vector3 {
	mb := globalVector3MethodBindings.method_clamp
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&min))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&max))

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clampf : clampf
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Clampf(min float32, max float32) Vector3 {
	mb := globalVector3MethodBindings.method_clampf
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(min)

	args[1] = Float32Encoder.EncodeTypePtr(max)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Snapped : snapped
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Snapped(step Vector3) Vector3 {
	mb := globalVector3MethodBindings.method_snapped
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&step))

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Snappedf : snappedf
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Snappedf(step float32) Vector3 {
	mb := globalVector3MethodBindings.method_snappedf
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(step)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rotated : rotated
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Rotated(axis Vector3, angle float32) Vector3 {
	mb := globalVector3MethodBindings.method_rotated
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&axis))

	args[1] = Float32Encoder.EncodeTypePtr(angle)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Lerp : lerp
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Lerp(to Vector3, weight float32) Vector3 {
	mb := globalVector3MethodBindings.method_lerp
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	args[1] = Float32Encoder.EncodeTypePtr(weight)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Slerp : slerp
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Slerp(to Vector3, weight float32) Vector3 {
	mb := globalVector3MethodBindings.method_slerp
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	args[1] = Float32Encoder.EncodeTypePtr(weight)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* CubicInterpolate : cubic_interpolate
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) CubicInterpolate(b Vector3, pre_a Vector3, post_b Vector3, weight float32) Vector3 {
	mb := globalVector3MethodBindings.method_cubic_interpolate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 4
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&b))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&pre_a))

	args[2] = (GDExtensionTypePtr)(unsafe.Pointer(&post_b))

	args[3] = Float32Encoder.EncodeTypePtr(weight)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* CubicInterpolateInTime : cubic_interpolate_in_time
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) CubicInterpolateInTime(b Vector3, pre_a Vector3, post_b Vector3, weight float32, b_t float32, pre_a_t float32, post_b_t float32) Vector3 {
	mb := globalVector3MethodBindings.method_cubic_interpolate_in_time
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 7
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&b))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&pre_a))

	args[2] = (GDExtensionTypePtr)(unsafe.Pointer(&post_b))

	args[3] = Float32Encoder.EncodeTypePtr(weight)

	args[4] = Float32Encoder.EncodeTypePtr(b_t)

	args[5] = Float32Encoder.EncodeTypePtr(pre_a_t)

	args[6] = Float32Encoder.EncodeTypePtr(post_b_t)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* BezierInterpolate : bezier_interpolate
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) BezierInterpolate(control_1 Vector3, control_2 Vector3, end Vector3, t float32) Vector3 {
	mb := globalVector3MethodBindings.method_bezier_interpolate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 4
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&control_1))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&control_2))

	args[2] = (GDExtensionTypePtr)(unsafe.Pointer(&end))

	args[3] = Float32Encoder.EncodeTypePtr(t)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* BezierDerivative : bezier_derivative
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) BezierDerivative(control_1 Vector3, control_2 Vector3, end Vector3, t float32) Vector3 {
	mb := globalVector3MethodBindings.method_bezier_derivative
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 4
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&control_1))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&control_2))

	args[2] = (GDExtensionTypePtr)(unsafe.Pointer(&end))

	args[3] = Float32Encoder.EncodeTypePtr(t)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* MoveToward : move_toward
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) MoveToward(to Vector3, delta float32) Vector3 {
	mb := globalVector3MethodBindings.method_move_toward
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	args[1] = Float32Encoder.EncodeTypePtr(delta)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Dot : dot
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector3) Dot(with Vector3) float32 {
	mb := globalVector3MethodBindings.method_dot
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Cross : cross
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Cross(with Vector3) Vector3 {
	mb := globalVector3MethodBindings.method_cross
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Outer : outer
 * is_vararg = false, is_static = false
 * goReturnType(Basis) -> Basis
 */
func (cx *Vector3) Outer(with Vector3) Basis {
	mb := globalVector3MethodBindings.method_outer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[Basis](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Abs : abs
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Abs() Vector3 {
	mb := globalVector3MethodBindings.method_abs
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, nil)
	return ret
}

/* Floor : floor
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Floor() Vector3 {
	mb := globalVector3MethodBindings.method_floor
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, nil)
	return ret
}

/* Ceil : ceil
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Ceil() Vector3 {
	mb := globalVector3MethodBindings.method_ceil
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, nil)
	return ret
}

/* Round : round
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Round() Vector3 {
	mb := globalVector3MethodBindings.method_round
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, nil)
	return ret
}

/* Posmod : posmod
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Posmod(mod float32) Vector3 {
	mb := globalVector3MethodBindings.method_posmod
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(mod)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Posmodv : posmodv
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Posmodv(modv Vector3) Vector3 {
	mb := globalVector3MethodBindings.method_posmodv
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&modv))

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Project : project
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Project(b Vector3) Vector3 {
	mb := globalVector3MethodBindings.method_project
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&b))

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Slide : slide
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Slide(n Vector3) Vector3 {
	mb := globalVector3MethodBindings.method_slide
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&n))

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Bounce : bounce
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Bounce(n Vector3) Vector3 {
	mb := globalVector3MethodBindings.method_bounce
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&n))

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Reflect : reflect
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Reflect(n Vector3) Vector3 {
	mb := globalVector3MethodBindings.method_reflect
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&n))

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Sign : sign
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Sign() Vector3 {
	mb := globalVector3MethodBindings.method_sign
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, nil)
	return ret
}

/* OctahedronEncode : octahedron_encode
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Vector3) OctahedronEncode() Vector2 {
	mb := globalVector3MethodBindings.method_octahedron_encode
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, nil)
	return ret
}

/* Min : min
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Min(with Vector3) Vector3 {
	mb := globalVector3MethodBindings.method_min
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Minf : minf
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Minf(with float32) Vector3 {
	mb := globalVector3MethodBindings.method_minf
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(with)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Max : max
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Max(with Vector3) Vector3 {
	mb := globalVector3MethodBindings.method_max
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Maxf : maxf
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) Maxf(with float32) Vector3 {
	mb := globalVector3MethodBindings.method_maxf
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(with)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* OctahedronDecode : octahedron_decode
 * is_vararg = false, is_static = true
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Vector3) OctahedronDecode(uv Vector2) Vector3 {
	mb := globalVector3MethodBindings.method_octahedron_decode
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&uv))

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *Vector3) GetIndexed(i int64) float32 {
	var ret float32
	CallFunc_GDExtensionPtrIndexedGetter(
		globalVector3MethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *Vector3) SetIndexed(i int64, value float32) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalVector3MethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members

func (cx *Vector3) MemberGetx() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalVector3MethodBindings.member_x_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Vector3) MemberGety() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalVector3MethodBindings.member_y_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Vector3) MemberGetz() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalVector3MethodBindings.member_z_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

// Equal_Variant operator
func (cx *Vector3) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalVector3MethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Vector3) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalVector3MethodBindings.operator_not_equal_Variant, lt, rt)
}

// Negate operator
func (cx *Vector3) Negate() Vector3 {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Vector3](globalVector3MethodBindings.operator_negate, lt, rt)
}

// Positive operator
func (cx *Vector3) Positive() Vector3 {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Vector3](globalVector3MethodBindings.operator_positive, lt, rt)
}

// Not operator
func (cx *Vector3) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalVector3MethodBindings.operator_not, lt, rt)
}

// Multiply_int operator
func (cx *Vector3) Multiply_int(right int64) Vector3 {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector3](globalVector3MethodBindings.operator_multiply_int, lt, rt)
}

// Divide_int operator
func (cx *Vector3) Divide_int(right int64) Vector3 {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector3](globalVector3MethodBindings.operator_divide_int, lt, rt)
}

// Multiply_float operator
func (cx *Vector3) Multiply_float(right float32) Vector3 {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector3](globalVector3MethodBindings.operator_multiply_float, lt, rt)
}

// Divide_float operator
func (cx *Vector3) Divide_float(right float32) Vector3 {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector3](globalVector3MethodBindings.operator_divide_float, lt, rt)
}

// Equal_Vector3 operator
func (cx *Vector3) Equal_Vector3(right Vector3) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3MethodBindings.operator_equal_Vector3, lt, rt)
}

// Not_equal_Vector3 operator
func (cx *Vector3) Not_equal_Vector3(right Vector3) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3MethodBindings.operator_not_equal_Vector3, lt, rt)
}

// Less_Vector3 operator
func (cx *Vector3) Less_Vector3(right Vector3) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3MethodBindings.operator_less_Vector3, lt, rt)
}

// Less_equal_Vector3 operator
func (cx *Vector3) Less_equal_Vector3(right Vector3) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3MethodBindings.operator_less_equal_Vector3, lt, rt)
}

// Greater_Vector3 operator
func (cx *Vector3) Greater_Vector3(right Vector3) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3MethodBindings.operator_greater_Vector3, lt, rt)
}

// Greater_equal_Vector3 operator
func (cx *Vector3) Greater_equal_Vector3(right Vector3) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3MethodBindings.operator_greater_equal_Vector3, lt, rt)
}

// Add_Vector3 operator
func (cx *Vector3) Add_Vector3(right Vector3) Vector3 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector3](globalVector3MethodBindings.operator_add_Vector3, lt, rt)
}

// Subtract_Vector3 operator
func (cx *Vector3) Subtract_Vector3(right Vector3) Vector3 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector3](globalVector3MethodBindings.operator_subtract_Vector3, lt, rt)
}

// Multiply_Vector3 operator
func (cx *Vector3) Multiply_Vector3(right Vector3) Vector3 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector3](globalVector3MethodBindings.operator_multiply_Vector3, lt, rt)
}

// Divide_Vector3 operator
func (cx *Vector3) Divide_Vector3(right Vector3) Vector3 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector3](globalVector3MethodBindings.operator_divide_Vector3, lt, rt)
}

// Multiply_Quaternion operator
func (cx *Vector3) Multiply_Quaternion(right Quaternion) Vector3 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector3](globalVector3MethodBindings.operator_multiply_Quaternion, lt, rt)
}

// Multiply_Basis operator
func (cx *Vector3) Multiply_Basis(right Basis) Vector3 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector3](globalVector3MethodBindings.operator_multiply_Basis, lt, rt)
}

// Multiply_Transform3D operator
func (cx *Vector3) Multiply_Transform3D(right Transform3D) Vector3 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector3](globalVector3MethodBindings.operator_multiply_Transform3D, lt, rt)
}

// In_Dictionary operator
func (cx *Vector3) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3MethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Vector3) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3MethodBindings.operator_in_Array, lt, rt)
}

// In_PackedVector3Array operator
func (cx *Vector3) In_PackedVector3Array(right PackedVector3Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3MethodBindings.operator_in_PackedVector3Array, lt, rt)
}

var _ GDBuiltInClass = &Vector3i{}

/*
 * Vector3i
 * indexingReturnType: int
 * isKeyed: false
 * hasDestructor: false
 */
type Vector3i [12]uint8

func (c *Vector3i) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Vector3i) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewVector3i, index: 0
func NewVector3i() Vector3i {
	cx := Vector3i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalVector3iMethodBindings.constructor_0, ptr)
	return cx
}

// NewVector3i, index: 1
func NewVector3iWithVector3i(from Vector3i) Vector3i {
	cx := Vector3i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Vector3i
	// Vector3iEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalVector3iMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewVector3i, index: 2
func NewVector3iWithVector3(from Vector3) Vector3i {
	cx := Vector3i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Vector3
	// Vector3Encoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalVector3iMethodBindings.constructor_2, ptr, args[0])
	return cx
}

// NewVector3i, index: 3
func NewVector3iWithInt64Int64Int64(x int64, y int64, z int64) Vector3i {
	cx := Vector3i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [3]GDExtensionConstTypePtr
	// int
	args[0] = (GDExtensionConstTypePtr)(Int64Encoder.EncodeTypePtr(x))
	// int
	args[1] = (GDExtensionConstTypePtr)(Int64Encoder.EncodeTypePtr(y))
	// int
	args[2] = (GDExtensionConstTypePtr)(Int64Encoder.EncodeTypePtr(z))
	CallBuiltinConstructor(globalVector3iMethodBindings.constructor_3, ptr, args[0], args[1], args[2])
	return cx
}

// copy funuctions
func NewVector3iWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Vector3i {
	ret := Vector3i{}
	typedSrc := (*Vector3i)(src)

	for i := 0; i < 12; i++ {
		ret[i] = typedSrc[i]
	}

	return (Vector3i)(ret)
}
func copyVector3iWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Vector3i)(dst)
	typedSrc := (*Vector3i)(src)

	for i := 0; i < 12; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* MinAxisIndex : min_axis_index
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector3i) MinAxisIndex() int64 {
	mb := globalVector3iMethodBindings.method_min_axis_index
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* MaxAxisIndex : max_axis_index
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector3i) MaxAxisIndex() int64 {
	mb := globalVector3iMethodBindings.method_max_axis_index
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* DistanceTo : distance_to
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector3i) DistanceTo(to Vector3i) float32 {
	mb := globalVector3iMethodBindings.method_distance_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DistanceSquaredTo : distance_squared_to
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector3i) DistanceSquaredTo(to Vector3i) int64 {
	mb := globalVector3iMethodBindings.method_distance_squared_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Length : length
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector3i) Length() float32 {
	mb := globalVector3iMethodBindings.method_length
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* LengthSquared : length_squared
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector3i) LengthSquared() int64 {
	mb := globalVector3iMethodBindings.method_length_squared
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* Sign : sign
 * is_vararg = false, is_static = false
 * goReturnType(Vector3i) -> Vector3i
 */
func (cx *Vector3i) Sign() Vector3i {
	mb := globalVector3iMethodBindings.method_sign
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector3i](mb, bx, nil)
	return ret
}

/* Abs : abs
 * is_vararg = false, is_static = false
 * goReturnType(Vector3i) -> Vector3i
 */
func (cx *Vector3i) Abs() Vector3i {
	mb := globalVector3iMethodBindings.method_abs
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector3i](mb, bx, nil)
	return ret
}

/* Clamp : clamp
 * is_vararg = false, is_static = false
 * goReturnType(Vector3i) -> Vector3i
 */
func (cx *Vector3i) Clamp(min Vector3i, max Vector3i) Vector3i {
	mb := globalVector3iMethodBindings.method_clamp
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&min))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&max))

	ret := CallBuiltinMethodPtrRet[Vector3i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clampi : clampi
 * is_vararg = false, is_static = false
 * goReturnType(Vector3i) -> Vector3i
 */
func (cx *Vector3i) Clampi(min int64, max int64) Vector3i {
	mb := globalVector3iMethodBindings.method_clampi
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(min)

	args[1] = Int64Encoder.EncodeTypePtr(max)

	ret := CallBuiltinMethodPtrRet[Vector3i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Snapped : snapped
 * is_vararg = false, is_static = false
 * goReturnType(Vector3i) -> Vector3i
 */
func (cx *Vector3i) Snapped(step Vector3i) Vector3i {
	mb := globalVector3iMethodBindings.method_snapped
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&step))

	ret := CallBuiltinMethodPtrRet[Vector3i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Snappedi : snappedi
 * is_vararg = false, is_static = false
 * goReturnType(Vector3i) -> Vector3i
 */
func (cx *Vector3i) Snappedi(step int64) Vector3i {
	mb := globalVector3iMethodBindings.method_snappedi
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(step)

	ret := CallBuiltinMethodPtrRet[Vector3i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Min : min
 * is_vararg = false, is_static = false
 * goReturnType(Vector3i) -> Vector3i
 */
func (cx *Vector3i) Min(with Vector3i) Vector3i {
	mb := globalVector3iMethodBindings.method_min
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[Vector3i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Mini : mini
 * is_vararg = false, is_static = false
 * goReturnType(Vector3i) -> Vector3i
 */
func (cx *Vector3i) Mini(with int64) Vector3i {
	mb := globalVector3iMethodBindings.method_mini
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(with)

	ret := CallBuiltinMethodPtrRet[Vector3i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Max : max
 * is_vararg = false, is_static = false
 * goReturnType(Vector3i) -> Vector3i
 */
func (cx *Vector3i) Max(with Vector3i) Vector3i {
	mb := globalVector3iMethodBindings.method_max
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[Vector3i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Maxi : maxi
 * is_vararg = false, is_static = false
 * goReturnType(Vector3i) -> Vector3i
 */
func (cx *Vector3i) Maxi(with int64) Vector3i {
	mb := globalVector3iMethodBindings.method_maxi
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(with)

	ret := CallBuiltinMethodPtrRet[Vector3i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *Vector3i) GetIndexed(i int64) int64 {
	var ret int64
	CallFunc_GDExtensionPtrIndexedGetter(
		globalVector3iMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *Vector3i) SetIndexed(i int64, value int64) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalVector3iMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members

func (cx *Vector3i) MemberGetx() int64 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[int64](globalVector3iMethodBindings.member_x_getter, bx)
	return ret

}

func (cx *Vector3i) MemberGety() int64 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[int64](globalVector3iMethodBindings.member_y_getter, bx)
	return ret

}

func (cx *Vector3i) MemberGetz() int64 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[int64](globalVector3iMethodBindings.member_z_getter, bx)
	return ret

}

// Equal_Variant operator
func (cx *Vector3i) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalVector3iMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Vector3i) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalVector3iMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Negate operator
func (cx *Vector3i) Negate() Vector3i {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Vector3i](globalVector3iMethodBindings.operator_negate, lt, rt)
}

// Positive operator
func (cx *Vector3i) Positive() Vector3i {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Vector3i](globalVector3iMethodBindings.operator_positive, lt, rt)
}

// Not operator
func (cx *Vector3i) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalVector3iMethodBindings.operator_not, lt, rt)
}

// Multiply_int operator
func (cx *Vector3i) Multiply_int(right int64) Vector3i {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector3i](globalVector3iMethodBindings.operator_multiply_int, lt, rt)
}

// Divide_int operator
func (cx *Vector3i) Divide_int(right int64) Vector3i {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector3i](globalVector3iMethodBindings.operator_divide_int, lt, rt)
}

// Module_int operator
func (cx *Vector3i) Module_int(right int64) Vector3i {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector3i](globalVector3iMethodBindings.operator_module_int, lt, rt)
}

// Multiply_float operator
func (cx *Vector3i) Multiply_float(right float32) Vector3 {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector3](globalVector3iMethodBindings.operator_multiply_float, lt, rt)
}

// Divide_float operator
func (cx *Vector3i) Divide_float(right float32) Vector3 {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector3](globalVector3iMethodBindings.operator_divide_float, lt, rt)
}

// Equal_Vector3i operator
func (cx *Vector3i) Equal_Vector3i(right Vector3i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3iMethodBindings.operator_equal_Vector3i, lt, rt)
}

// Not_equal_Vector3i operator
func (cx *Vector3i) Not_equal_Vector3i(right Vector3i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3iMethodBindings.operator_not_equal_Vector3i, lt, rt)
}

// Less_Vector3i operator
func (cx *Vector3i) Less_Vector3i(right Vector3i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3iMethodBindings.operator_less_Vector3i, lt, rt)
}

// Less_equal_Vector3i operator
func (cx *Vector3i) Less_equal_Vector3i(right Vector3i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3iMethodBindings.operator_less_equal_Vector3i, lt, rt)
}

// Greater_Vector3i operator
func (cx *Vector3i) Greater_Vector3i(right Vector3i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3iMethodBindings.operator_greater_Vector3i, lt, rt)
}

// Greater_equal_Vector3i operator
func (cx *Vector3i) Greater_equal_Vector3i(right Vector3i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3iMethodBindings.operator_greater_equal_Vector3i, lt, rt)
}

// Add_Vector3i operator
func (cx *Vector3i) Add_Vector3i(right Vector3i) Vector3i {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector3i](globalVector3iMethodBindings.operator_add_Vector3i, lt, rt)
}

// Subtract_Vector3i operator
func (cx *Vector3i) Subtract_Vector3i(right Vector3i) Vector3i {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector3i](globalVector3iMethodBindings.operator_subtract_Vector3i, lt, rt)
}

// Multiply_Vector3i operator
func (cx *Vector3i) Multiply_Vector3i(right Vector3i) Vector3i {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector3i](globalVector3iMethodBindings.operator_multiply_Vector3i, lt, rt)
}

// Divide_Vector3i operator
func (cx *Vector3i) Divide_Vector3i(right Vector3i) Vector3i {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector3i](globalVector3iMethodBindings.operator_divide_Vector3i, lt, rt)
}

// Module_Vector3i operator
func (cx *Vector3i) Module_Vector3i(right Vector3i) Vector3i {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector3i](globalVector3iMethodBindings.operator_module_Vector3i, lt, rt)
}

// In_Dictionary operator
func (cx *Vector3i) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3iMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Vector3i) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector3iMethodBindings.operator_in_Array, lt, rt)
}

var _ GDBuiltInClass = &Transform2D{}

/*
 * Transform2D
 * indexingReturnType: Vector2
 * isKeyed: false
 * hasDestructor: false
 */
type Transform2D [24]uint8

func (c *Transform2D) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Transform2D) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewTransform2D, index: 0
func NewTransform2D() Transform2D {
	cx := Transform2D{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalTransform2DMethodBindings.constructor_0, ptr)
	return cx
}

// NewTransform2D, index: 1
func NewTransform2DWithTransform2D(from Transform2D) Transform2D {
	cx := Transform2D{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Transform2D
	// Transform2DEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalTransform2DMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewTransform2D, index: 2
func NewTransform2DWithFloat32Vector2(rotation float32, position Vector2) Transform2D {
	cx := Transform2D{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [2]GDExtensionConstTypePtr
	// float
	args[0] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(rotation))
	// Vector2
	// Vector2Encoder
	args[1] = position.NativeConstPtr()
	CallBuiltinConstructor(globalTransform2DMethodBindings.constructor_2, ptr, args[0], args[1])
	return cx
}

// NewTransform2D, index: 3
func NewTransform2DWithFloat32Vector2Float32Vector2(rotation float32, scale Vector2, skew float32, position Vector2) Transform2D {
	cx := Transform2D{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [4]GDExtensionConstTypePtr
	// float
	args[0] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(rotation))
	// Vector2
	// Vector2Encoder
	args[1] = scale.NativeConstPtr()
	// float
	args[2] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(skew))
	// Vector2
	// Vector2Encoder
	args[3] = position.NativeConstPtr()
	CallBuiltinConstructor(globalTransform2DMethodBindings.constructor_3, ptr, args[0], args[1], args[2], args[3])
	return cx
}

// NewTransform2D, index: 4
func NewTransform2DWithVector2Vector2Vector2(x_axis Vector2, y_axis Vector2, origin Vector2) Transform2D {
	cx := Transform2D{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [3]GDExtensionConstTypePtr
	// Vector2
	// Vector2Encoder
	args[0] = x_axis.NativeConstPtr()
	// Vector2
	// Vector2Encoder
	args[1] = y_axis.NativeConstPtr()
	// Vector2
	// Vector2Encoder
	args[2] = origin.NativeConstPtr()
	CallBuiltinConstructor(globalTransform2DMethodBindings.constructor_4, ptr, args[0], args[1], args[2])
	return cx
}

// copy funuctions
func NewTransform2DWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Transform2D {
	ret := Transform2D{}
	typedSrc := (*Transform2D)(src)

	for i := 0; i < 24; i++ {
		ret[i] = typedSrc[i]
	}

	return (Transform2D)(ret)
}
func copyTransform2DWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Transform2D)(dst)
	typedSrc := (*Transform2D)(src)

	for i := 0; i < 24; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Inverse : inverse
 * is_vararg = false, is_static = false
 * goReturnType(Transform2D) -> Transform2D
 */
func (cx *Transform2D) Inverse() Transform2D {
	mb := globalTransform2DMethodBindings.method_inverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Transform2D](mb, bx, nil)
	return ret
}

/* AffineInverse : affine_inverse
 * is_vararg = false, is_static = false
 * goReturnType(Transform2D) -> Transform2D
 */
func (cx *Transform2D) AffineInverse() Transform2D {
	mb := globalTransform2DMethodBindings.method_affine_inverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Transform2D](mb, bx, nil)
	return ret
}

/* GetRotation : get_rotation
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Transform2D) GetRotation() float32 {
	mb := globalTransform2DMethodBindings.method_get_rotation
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* GetOrigin : get_origin
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Transform2D) GetOrigin() Vector2 {
	mb := globalTransform2DMethodBindings.method_get_origin
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, nil)
	return ret
}

/* GetScale : get_scale
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Transform2D) GetScale() Vector2 {
	mb := globalTransform2DMethodBindings.method_get_scale
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, nil)
	return ret
}

/* GetSkew : get_skew
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Transform2D) GetSkew() float32 {
	mb := globalTransform2DMethodBindings.method_get_skew
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* Orthonormalized : orthonormalized
 * is_vararg = false, is_static = false
 * goReturnType(Transform2D) -> Transform2D
 */
func (cx *Transform2D) Orthonormalized() Transform2D {
	mb := globalTransform2DMethodBindings.method_orthonormalized
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Transform2D](mb, bx, nil)
	return ret
}

/* Rotated : rotated
 * is_vararg = false, is_static = false
 * goReturnType(Transform2D) -> Transform2D
 */
func (cx *Transform2D) Rotated(angle float32) Transform2D {
	mb := globalTransform2DMethodBindings.method_rotated
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(angle)

	ret := CallBuiltinMethodPtrRet[Transform2D](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* RotatedLocal : rotated_local
 * is_vararg = false, is_static = false
 * goReturnType(Transform2D) -> Transform2D
 */
func (cx *Transform2D) RotatedLocal(angle float32) Transform2D {
	mb := globalTransform2DMethodBindings.method_rotated_local
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(angle)

	ret := CallBuiltinMethodPtrRet[Transform2D](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Scaled : scaled
 * is_vararg = false, is_static = false
 * goReturnType(Transform2D) -> Transform2D
 */
func (cx *Transform2D) Scaled(scale Vector2) Transform2D {
	mb := globalTransform2DMethodBindings.method_scaled
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&scale))

	ret := CallBuiltinMethodPtrRet[Transform2D](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* ScaledLocal : scaled_local
 * is_vararg = false, is_static = false
 * goReturnType(Transform2D) -> Transform2D
 */
func (cx *Transform2D) ScaledLocal(scale Vector2) Transform2D {
	mb := globalTransform2DMethodBindings.method_scaled_local
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&scale))

	ret := CallBuiltinMethodPtrRet[Transform2D](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Translated : translated
 * is_vararg = false, is_static = false
 * goReturnType(Transform2D) -> Transform2D
 */
func (cx *Transform2D) Translated(offset Vector2) Transform2D {
	mb := globalTransform2DMethodBindings.method_translated
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&offset))

	ret := CallBuiltinMethodPtrRet[Transform2D](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* TranslatedLocal : translated_local
 * is_vararg = false, is_static = false
 * goReturnType(Transform2D) -> Transform2D
 */
func (cx *Transform2D) TranslatedLocal(offset Vector2) Transform2D {
	mb := globalTransform2DMethodBindings.method_translated_local
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&offset))

	ret := CallBuiltinMethodPtrRet[Transform2D](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Determinant : determinant
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Transform2D) Determinant() float32 {
	mb := globalTransform2DMethodBindings.method_determinant
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* BasisXform : basis_xform
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Transform2D) BasisXform(v Vector2) Vector2 {
	mb := globalTransform2DMethodBindings.method_basis_xform
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&v))

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* BasisXformInv : basis_xform_inv
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Transform2D) BasisXformInv(v Vector2) Vector2 {
	mb := globalTransform2DMethodBindings.method_basis_xform_inv
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&v))

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* InterpolateWith : interpolate_with
 * is_vararg = false, is_static = false
 * goReturnType(Transform2D) -> Transform2D
 */
func (cx *Transform2D) InterpolateWith(xform Transform2D, weight float32) Transform2D {
	mb := globalTransform2DMethodBindings.method_interpolate_with
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&xform))

	args[1] = Float32Encoder.EncodeTypePtr(weight)

	ret := CallBuiltinMethodPtrRet[Transform2D](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsConformal : is_conformal
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Transform2D) IsConformal() bool {
	mb := globalTransform2DMethodBindings.method_is_conformal
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsEqualApprox : is_equal_approx
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Transform2D) IsEqualApprox(xform Transform2D) bool {
	mb := globalTransform2DMethodBindings.method_is_equal_approx
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&xform))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsFinite : is_finite
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Transform2D) IsFinite() bool {
	mb := globalTransform2DMethodBindings.method_is_finite
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* LookingAt : looking_at
 * is_vararg = false, is_static = false
 * goReturnType(Transform2D) -> Transform2D
 */
func (cx *Transform2D) LookingAt(target Vector2) Transform2D {
	mb := globalTransform2DMethodBindings.method_looking_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&target))

	ret := CallBuiltinMethodPtrRet[Transform2D](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *Transform2D) GetIndexed(i int64) Vector2 {
	var ret Vector2
	CallFunc_GDExtensionPtrIndexedGetter(
		globalTransform2DMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *Transform2D) SetIndexed(i int64, value Vector2) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalTransform2DMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members

func (cx *Transform2D) MemberGetx() Vector2 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector2](globalTransform2DMethodBindings.member_x_getter, bx)
	return ret

}

func (cx *Transform2D) MemberGety() Vector2 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector2](globalTransform2DMethodBindings.member_y_getter, bx)
	return ret

}

func (cx *Transform2D) MemberGetorigin() Vector2 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector2](globalTransform2DMethodBindings.member_origin_getter, bx)
	return ret

}

// Equal_Variant operator
func (cx *Transform2D) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalTransform2DMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Transform2D) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalTransform2DMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *Transform2D) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalTransform2DMethodBindings.operator_not, lt, rt)
}

// Multiply_int operator
func (cx *Transform2D) Multiply_int(right int64) Transform2D {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Transform2D](globalTransform2DMethodBindings.operator_multiply_int, lt, rt)
}

// Divide_int operator
func (cx *Transform2D) Divide_int(right int64) Transform2D {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Transform2D](globalTransform2DMethodBindings.operator_divide_int, lt, rt)
}

// Multiply_float operator
func (cx *Transform2D) Multiply_float(right float32) Transform2D {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Transform2D](globalTransform2DMethodBindings.operator_multiply_float, lt, rt)
}

// Divide_float operator
func (cx *Transform2D) Divide_float(right float32) Transform2D {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Transform2D](globalTransform2DMethodBindings.operator_divide_float, lt, rt)
}

// Multiply_Vector2 operator
func (cx *Transform2D) Multiply_Vector2(right Vector2) Vector2 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector2](globalTransform2DMethodBindings.operator_multiply_Vector2, lt, rt)
}

// Multiply_Rect2 operator
func (cx *Transform2D) Multiply_Rect2(right Rect2) Rect2 {
	lt := cx.NativeConstPtr()
	eRight := Rect2Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Rect2](globalTransform2DMethodBindings.operator_multiply_Rect2, lt, rt)
}

// Equal_Transform2D operator
func (cx *Transform2D) Equal_Transform2D(right Transform2D) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalTransform2DMethodBindings.operator_equal_Transform2D, lt, rt)
}

// Not_equal_Transform2D operator
func (cx *Transform2D) Not_equal_Transform2D(right Transform2D) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalTransform2DMethodBindings.operator_not_equal_Transform2D, lt, rt)
}

// Multiply_Transform2D operator
func (cx *Transform2D) Multiply_Transform2D(right Transform2D) Transform2D {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Transform2D](globalTransform2DMethodBindings.operator_multiply_Transform2D, lt, rt)
}

// In_Dictionary operator
func (cx *Transform2D) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalTransform2DMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Transform2D) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalTransform2DMethodBindings.operator_in_Array, lt, rt)
}

// Multiply_PackedVector2Array operator
func (cx *Transform2D) Multiply_PackedVector2Array(right PackedVector2Array) PackedVector2Array {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[PackedVector2Array](globalTransform2DMethodBindings.operator_multiply_PackedVector2Array, lt, rt)
}

var _ GDBuiltInClass = &Vector4{}

/*
 * Vector4
 * indexingReturnType: float
 * isKeyed: false
 * hasDestructor: false
 */
type Vector4 [16]uint8

func (c *Vector4) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Vector4) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewVector4, index: 0
func NewVector4() Vector4 {
	cx := Vector4{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalVector4MethodBindings.constructor_0, ptr)
	return cx
}

// NewVector4, index: 1
func NewVector4WithVector4(from Vector4) Vector4 {
	cx := Vector4{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Vector4
	// Vector4Encoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalVector4MethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewVector4, index: 2
func NewVector4WithVector4i(from Vector4i) Vector4 {
	cx := Vector4{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Vector4i
	// Vector4iEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalVector4MethodBindings.constructor_2, ptr, args[0])
	return cx
}

// NewVector4, index: 3
func NewVector4WithFloat32Float32Float32Float32(x float32, y float32, z float32, w float32) Vector4 {
	cx := Vector4{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [4]GDExtensionConstTypePtr
	// float
	args[0] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(x))
	// float
	args[1] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(y))
	// float
	args[2] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(z))
	// float
	args[3] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(w))
	CallBuiltinConstructor(globalVector4MethodBindings.constructor_3, ptr, args[0], args[1], args[2], args[3])
	return cx
}

// copy funuctions
func NewVector4WithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Vector4 {
	ret := Vector4{}
	typedSrc := (*Vector4)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (Vector4)(ret)
}
func copyVector4WithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Vector4)(dst)
	typedSrc := (*Vector4)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* MinAxisIndex : min_axis_index
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector4) MinAxisIndex() int64 {
	mb := globalVector4MethodBindings.method_min_axis_index
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* MaxAxisIndex : max_axis_index
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector4) MaxAxisIndex() int64 {
	mb := globalVector4MethodBindings.method_max_axis_index
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* Length : length
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector4) Length() float32 {
	mb := globalVector4MethodBindings.method_length
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* LengthSquared : length_squared
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector4) LengthSquared() float32 {
	mb := globalVector4MethodBindings.method_length_squared
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* Abs : abs
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Abs() Vector4 {
	mb := globalVector4MethodBindings.method_abs
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, nil)
	return ret
}

/* Sign : sign
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Sign() Vector4 {
	mb := globalVector4MethodBindings.method_sign
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, nil)
	return ret
}

/* Floor : floor
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Floor() Vector4 {
	mb := globalVector4MethodBindings.method_floor
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, nil)
	return ret
}

/* Ceil : ceil
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Ceil() Vector4 {
	mb := globalVector4MethodBindings.method_ceil
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, nil)
	return ret
}

/* Round : round
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Round() Vector4 {
	mb := globalVector4MethodBindings.method_round
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, nil)
	return ret
}

/* Lerp : lerp
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Lerp(to Vector4, weight float32) Vector4 {
	mb := globalVector4MethodBindings.method_lerp
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	args[1] = Float32Encoder.EncodeTypePtr(weight)

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* CubicInterpolate : cubic_interpolate
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) CubicInterpolate(b Vector4, pre_a Vector4, post_b Vector4, weight float32) Vector4 {
	mb := globalVector4MethodBindings.method_cubic_interpolate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 4
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&b))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&pre_a))

	args[2] = (GDExtensionTypePtr)(unsafe.Pointer(&post_b))

	args[3] = Float32Encoder.EncodeTypePtr(weight)

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* CubicInterpolateInTime : cubic_interpolate_in_time
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) CubicInterpolateInTime(b Vector4, pre_a Vector4, post_b Vector4, weight float32, b_t float32, pre_a_t float32, post_b_t float32) Vector4 {
	mb := globalVector4MethodBindings.method_cubic_interpolate_in_time
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 7
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&b))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&pre_a))

	args[2] = (GDExtensionTypePtr)(unsafe.Pointer(&post_b))

	args[3] = Float32Encoder.EncodeTypePtr(weight)

	args[4] = Float32Encoder.EncodeTypePtr(b_t)

	args[5] = Float32Encoder.EncodeTypePtr(pre_a_t)

	args[6] = Float32Encoder.EncodeTypePtr(post_b_t)

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Posmod : posmod
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Posmod(mod float32) Vector4 {
	mb := globalVector4MethodBindings.method_posmod
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(mod)

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Posmodv : posmodv
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Posmodv(modv Vector4) Vector4 {
	mb := globalVector4MethodBindings.method_posmodv
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&modv))

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Snapped : snapped
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Snapped(step Vector4) Vector4 {
	mb := globalVector4MethodBindings.method_snapped
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&step))

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Snappedf : snappedf
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Snappedf(step float32) Vector4 {
	mb := globalVector4MethodBindings.method_snappedf
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(step)

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clamp : clamp
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Clamp(min Vector4, max Vector4) Vector4 {
	mb := globalVector4MethodBindings.method_clamp
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&min))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&max))

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clampf : clampf
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Clampf(min float32, max float32) Vector4 {
	mb := globalVector4MethodBindings.method_clampf
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(min)

	args[1] = Float32Encoder.EncodeTypePtr(max)

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Normalized : normalized
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Normalized() Vector4 {
	mb := globalVector4MethodBindings.method_normalized
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, nil)
	return ret
}

/* IsNormalized : is_normalized
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Vector4) IsNormalized() bool {
	mb := globalVector4MethodBindings.method_is_normalized
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* DirectionTo : direction_to
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) DirectionTo(to Vector4) Vector4 {
	mb := globalVector4MethodBindings.method_direction_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DistanceTo : distance_to
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector4) DistanceTo(to Vector4) float32 {
	mb := globalVector4MethodBindings.method_distance_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DistanceSquaredTo : distance_squared_to
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector4) DistanceSquaredTo(to Vector4) float32 {
	mb := globalVector4MethodBindings.method_distance_squared_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Dot : dot
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector4) Dot(with Vector4) float32 {
	mb := globalVector4MethodBindings.method_dot
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Inverse : inverse
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Inverse() Vector4 {
	mb := globalVector4MethodBindings.method_inverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, nil)
	return ret
}

/* IsEqualApprox : is_equal_approx
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Vector4) IsEqualApprox(to Vector4) bool {
	mb := globalVector4MethodBindings.method_is_equal_approx
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsZeroApprox : is_zero_approx
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Vector4) IsZeroApprox() bool {
	mb := globalVector4MethodBindings.method_is_zero_approx
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsFinite : is_finite
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Vector4) IsFinite() bool {
	mb := globalVector4MethodBindings.method_is_finite
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Min : min
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Min(with Vector4) Vector4 {
	mb := globalVector4MethodBindings.method_min
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Minf : minf
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Minf(with float32) Vector4 {
	mb := globalVector4MethodBindings.method_minf
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(with)

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Max : max
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Max(with Vector4) Vector4 {
	mb := globalVector4MethodBindings.method_max
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Maxf : maxf
 * is_vararg = false, is_static = false
 * goReturnType(Vector4) -> Vector4
 */
func (cx *Vector4) Maxf(with float32) Vector4 {
	mb := globalVector4MethodBindings.method_maxf
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(with)

	ret := CallBuiltinMethodPtrRet[Vector4](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *Vector4) GetIndexed(i int64) float32 {
	var ret float32
	CallFunc_GDExtensionPtrIndexedGetter(
		globalVector4MethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *Vector4) SetIndexed(i int64, value float32) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalVector4MethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members

func (cx *Vector4) MemberGetx() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalVector4MethodBindings.member_x_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Vector4) MemberGety() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalVector4MethodBindings.member_y_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Vector4) MemberGetz() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalVector4MethodBindings.member_z_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Vector4) MemberGetw() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalVector4MethodBindings.member_w_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

// Equal_Variant operator
func (cx *Vector4) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalVector4MethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Vector4) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalVector4MethodBindings.operator_not_equal_Variant, lt, rt)
}

// Negate operator
func (cx *Vector4) Negate() Vector4 {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Vector4](globalVector4MethodBindings.operator_negate, lt, rt)
}

// Positive operator
func (cx *Vector4) Positive() Vector4 {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Vector4](globalVector4MethodBindings.operator_positive, lt, rt)
}

// Not operator
func (cx *Vector4) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalVector4MethodBindings.operator_not, lt, rt)
}

// Multiply_int operator
func (cx *Vector4) Multiply_int(right int64) Vector4 {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector4](globalVector4MethodBindings.operator_multiply_int, lt, rt)
}

// Divide_int operator
func (cx *Vector4) Divide_int(right int64) Vector4 {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector4](globalVector4MethodBindings.operator_divide_int, lt, rt)
}

// Multiply_float operator
func (cx *Vector4) Multiply_float(right float32) Vector4 {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector4](globalVector4MethodBindings.operator_multiply_float, lt, rt)
}

// Divide_float operator
func (cx *Vector4) Divide_float(right float32) Vector4 {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector4](globalVector4MethodBindings.operator_divide_float, lt, rt)
}

// Equal_Vector4 operator
func (cx *Vector4) Equal_Vector4(right Vector4) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector4MethodBindings.operator_equal_Vector4, lt, rt)
}

// Not_equal_Vector4 operator
func (cx *Vector4) Not_equal_Vector4(right Vector4) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector4MethodBindings.operator_not_equal_Vector4, lt, rt)
}

// Less_Vector4 operator
func (cx *Vector4) Less_Vector4(right Vector4) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector4MethodBindings.operator_less_Vector4, lt, rt)
}

// Less_equal_Vector4 operator
func (cx *Vector4) Less_equal_Vector4(right Vector4) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector4MethodBindings.operator_less_equal_Vector4, lt, rt)
}

// Greater_Vector4 operator
func (cx *Vector4) Greater_Vector4(right Vector4) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector4MethodBindings.operator_greater_Vector4, lt, rt)
}

// Greater_equal_Vector4 operator
func (cx *Vector4) Greater_equal_Vector4(right Vector4) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector4MethodBindings.operator_greater_equal_Vector4, lt, rt)
}

// Add_Vector4 operator
func (cx *Vector4) Add_Vector4(right Vector4) Vector4 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector4](globalVector4MethodBindings.operator_add_Vector4, lt, rt)
}

// Subtract_Vector4 operator
func (cx *Vector4) Subtract_Vector4(right Vector4) Vector4 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector4](globalVector4MethodBindings.operator_subtract_Vector4, lt, rt)
}

// Multiply_Vector4 operator
func (cx *Vector4) Multiply_Vector4(right Vector4) Vector4 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector4](globalVector4MethodBindings.operator_multiply_Vector4, lt, rt)
}

// Divide_Vector4 operator
func (cx *Vector4) Divide_Vector4(right Vector4) Vector4 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector4](globalVector4MethodBindings.operator_divide_Vector4, lt, rt)
}

// Multiply_Projection operator
func (cx *Vector4) Multiply_Projection(right Projection) Vector4 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector4](globalVector4MethodBindings.operator_multiply_Projection, lt, rt)
}

// In_Dictionary operator
func (cx *Vector4) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector4MethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Vector4) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector4MethodBindings.operator_in_Array, lt, rt)
}

// In_PackedVector4Array operator
func (cx *Vector4) In_PackedVector4Array(right PackedVector4Array) bool {
	lt := cx.NativeConstPtr()
	eRight := PackedVector4ArrayEncoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[bool](globalVector4MethodBindings.operator_in_PackedVector4Array, lt, rt)
}

var _ GDBuiltInClass = &Vector4i{}

/*
 * Vector4i
 * indexingReturnType: int
 * isKeyed: false
 * hasDestructor: false
 */
type Vector4i [16]uint8

func (c *Vector4i) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Vector4i) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewVector4i, index: 0
func NewVector4i() Vector4i {
	cx := Vector4i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalVector4iMethodBindings.constructor_0, ptr)
	return cx
}

// NewVector4i, index: 1
func NewVector4iWithVector4i(from Vector4i) Vector4i {
	cx := Vector4i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Vector4i
	// Vector4iEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalVector4iMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewVector4i, index: 2
func NewVector4iWithVector4(from Vector4) Vector4i {
	cx := Vector4i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Vector4
	// Vector4Encoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalVector4iMethodBindings.constructor_2, ptr, args[0])
	return cx
}

// NewVector4i, index: 3
func NewVector4iWithInt64Int64Int64Int64(x int64, y int64, z int64, w int64) Vector4i {
	cx := Vector4i{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [4]GDExtensionConstTypePtr
	// int
	args[0] = (GDExtensionConstTypePtr)(Int64Encoder.EncodeTypePtr(x))
	// int
	args[1] = (GDExtensionConstTypePtr)(Int64Encoder.EncodeTypePtr(y))
	// int
	args[2] = (GDExtensionConstTypePtr)(Int64Encoder.EncodeTypePtr(z))
	// int
	args[3] = (GDExtensionConstTypePtr)(Int64Encoder.EncodeTypePtr(w))
	CallBuiltinConstructor(globalVector4iMethodBindings.constructor_3, ptr, args[0], args[1], args[2], args[3])
	return cx
}

// copy funuctions
func NewVector4iWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Vector4i {
	ret := Vector4i{}
	typedSrc := (*Vector4i)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (Vector4i)(ret)
}
func copyVector4iWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Vector4i)(dst)
	typedSrc := (*Vector4i)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* MinAxisIndex : min_axis_index
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector4i) MinAxisIndex() int64 {
	mb := globalVector4iMethodBindings.method_min_axis_index
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* MaxAxisIndex : max_axis_index
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector4i) MaxAxisIndex() int64 {
	mb := globalVector4iMethodBindings.method_max_axis_index
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* Length : length
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector4i) Length() float32 {
	mb := globalVector4iMethodBindings.method_length
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* LengthSquared : length_squared
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector4i) LengthSquared() int64 {
	mb := globalVector4iMethodBindings.method_length_squared
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* Sign : sign
 * is_vararg = false, is_static = false
 * goReturnType(Vector4i) -> Vector4i
 */
func (cx *Vector4i) Sign() Vector4i {
	mb := globalVector4iMethodBindings.method_sign
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector4i](mb, bx, nil)
	return ret
}

/* Abs : abs
 * is_vararg = false, is_static = false
 * goReturnType(Vector4i) -> Vector4i
 */
func (cx *Vector4i) Abs() Vector4i {
	mb := globalVector4iMethodBindings.method_abs
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector4i](mb, bx, nil)
	return ret
}

/* Clamp : clamp
 * is_vararg = false, is_static = false
 * goReturnType(Vector4i) -> Vector4i
 */
func (cx *Vector4i) Clamp(min Vector4i, max Vector4i) Vector4i {
	mb := globalVector4iMethodBindings.method_clamp
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&min))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&max))

	ret := CallBuiltinMethodPtrRet[Vector4i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clampi : clampi
 * is_vararg = false, is_static = false
 * goReturnType(Vector4i) -> Vector4i
 */
func (cx *Vector4i) Clampi(min int64, max int64) Vector4i {
	mb := globalVector4iMethodBindings.method_clampi
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(min)

	args[1] = Int64Encoder.EncodeTypePtr(max)

	ret := CallBuiltinMethodPtrRet[Vector4i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Snapped : snapped
 * is_vararg = false, is_static = false
 * goReturnType(Vector4i) -> Vector4i
 */
func (cx *Vector4i) Snapped(step Vector4i) Vector4i {
	mb := globalVector4iMethodBindings.method_snapped
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&step))

	ret := CallBuiltinMethodPtrRet[Vector4i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Snappedi : snappedi
 * is_vararg = false, is_static = false
 * goReturnType(Vector4i) -> Vector4i
 */
func (cx *Vector4i) Snappedi(step int64) Vector4i {
	mb := globalVector4iMethodBindings.method_snappedi
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(step)

	ret := CallBuiltinMethodPtrRet[Vector4i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Min : min
 * is_vararg = false, is_static = false
 * goReturnType(Vector4i) -> Vector4i
 */
func (cx *Vector4i) Min(with Vector4i) Vector4i {
	mb := globalVector4iMethodBindings.method_min
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[Vector4i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Mini : mini
 * is_vararg = false, is_static = false
 * goReturnType(Vector4i) -> Vector4i
 */
func (cx *Vector4i) Mini(with int64) Vector4i {
	mb := globalVector4iMethodBindings.method_mini
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(with)

	ret := CallBuiltinMethodPtrRet[Vector4i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Max : max
 * is_vararg = false, is_static = false
 * goReturnType(Vector4i) -> Vector4i
 */
func (cx *Vector4i) Max(with Vector4i) Vector4i {
	mb := globalVector4iMethodBindings.method_max
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[Vector4i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Maxi : maxi
 * is_vararg = false, is_static = false
 * goReturnType(Vector4i) -> Vector4i
 */
func (cx *Vector4i) Maxi(with int64) Vector4i {
	mb := globalVector4iMethodBindings.method_maxi
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(with)

	ret := CallBuiltinMethodPtrRet[Vector4i](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DistanceTo : distance_to
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Vector4i) DistanceTo(to Vector4i) float32 {
	mb := globalVector4iMethodBindings.method_distance_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DistanceSquaredTo : distance_squared_to
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Vector4i) DistanceSquaredTo(to Vector4i) int64 {
	mb := globalVector4iMethodBindings.method_distance_squared_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *Vector4i) GetIndexed(i int64) int64 {
	var ret int64
	CallFunc_GDExtensionPtrIndexedGetter(
		globalVector4iMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *Vector4i) SetIndexed(i int64, value int64) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalVector4iMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members

func (cx *Vector4i) MemberGetx() int64 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[int64](globalVector4iMethodBindings.member_x_getter, bx)
	return ret

}

func (cx *Vector4i) MemberGety() int64 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[int64](globalVector4iMethodBindings.member_y_getter, bx)
	return ret

}

func (cx *Vector4i) MemberGetz() int64 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[int64](globalVector4iMethodBindings.member_z_getter, bx)
	return ret

}

func (cx *Vector4i) MemberGetw() int64 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[int64](globalVector4iMethodBindings.member_w_getter, bx)
	return ret

}

// Equal_Variant operator
func (cx *Vector4i) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalVector4iMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Vector4i) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalVector4iMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Negate operator
func (cx *Vector4i) Negate() Vector4i {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Vector4i](globalVector4iMethodBindings.operator_negate, lt, rt)
}

// Positive operator
func (cx *Vector4i) Positive() Vector4i {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Vector4i](globalVector4iMethodBindings.operator_positive, lt, rt)
}

// Not operator
func (cx *Vector4i) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalVector4iMethodBindings.operator_not, lt, rt)
}

// Multiply_int operator
func (cx *Vector4i) Multiply_int(right int64) Vector4i {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector4i](globalVector4iMethodBindings.operator_multiply_int, lt, rt)
}

// Divide_int operator
func (cx *Vector4i) Divide_int(right int64) Vector4i {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector4i](globalVector4iMethodBindings.operator_divide_int, lt, rt)
}

// Module_int operator
func (cx *Vector4i) Module_int(right int64) Vector4i {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector4i](globalVector4iMethodBindings.operator_module_int, lt, rt)
}

// Multiply_float operator
func (cx *Vector4i) Multiply_float(right float32) Vector4 {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector4](globalVector4iMethodBindings.operator_multiply_float, lt, rt)
}

// Divide_float operator
func (cx *Vector4i) Divide_float(right float32) Vector4 {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Vector4](globalVector4iMethodBindings.operator_divide_float, lt, rt)
}

// Equal_Vector4i operator
func (cx *Vector4i) Equal_Vector4i(right Vector4i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector4iMethodBindings.operator_equal_Vector4i, lt, rt)
}

// Not_equal_Vector4i operator
func (cx *Vector4i) Not_equal_Vector4i(right Vector4i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector4iMethodBindings.operator_not_equal_Vector4i, lt, rt)
}

// Less_Vector4i operator
func (cx *Vector4i) Less_Vector4i(right Vector4i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector4iMethodBindings.operator_less_Vector4i, lt, rt)
}

// Less_equal_Vector4i operator
func (cx *Vector4i) Less_equal_Vector4i(right Vector4i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector4iMethodBindings.operator_less_equal_Vector4i, lt, rt)
}

// Greater_Vector4i operator
func (cx *Vector4i) Greater_Vector4i(right Vector4i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector4iMethodBindings.operator_greater_Vector4i, lt, rt)
}

// Greater_equal_Vector4i operator
func (cx *Vector4i) Greater_equal_Vector4i(right Vector4i) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector4iMethodBindings.operator_greater_equal_Vector4i, lt, rt)
}

// Add_Vector4i operator
func (cx *Vector4i) Add_Vector4i(right Vector4i) Vector4i {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector4i](globalVector4iMethodBindings.operator_add_Vector4i, lt, rt)
}

// Subtract_Vector4i operator
func (cx *Vector4i) Subtract_Vector4i(right Vector4i) Vector4i {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector4i](globalVector4iMethodBindings.operator_subtract_Vector4i, lt, rt)
}

// Multiply_Vector4i operator
func (cx *Vector4i) Multiply_Vector4i(right Vector4i) Vector4i {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector4i](globalVector4iMethodBindings.operator_multiply_Vector4i, lt, rt)
}

// Divide_Vector4i operator
func (cx *Vector4i) Divide_Vector4i(right Vector4i) Vector4i {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector4i](globalVector4iMethodBindings.operator_divide_Vector4i, lt, rt)
}

// Module_Vector4i operator
func (cx *Vector4i) Module_Vector4i(right Vector4i) Vector4i {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector4i](globalVector4iMethodBindings.operator_module_Vector4i, lt, rt)
}

// In_Dictionary operator
func (cx *Vector4i) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector4iMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Vector4i) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalVector4iMethodBindings.operator_in_Array, lt, rt)
}

var _ GDBuiltInClass = &Plane{}

/*
 * Plane
 * indexingReturnType:
 * isKeyed: false
 * hasDestructor: false
 */
type Plane [16]uint8

func (c *Plane) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Plane) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewPlane, index: 0
func NewPlane() Plane {
	cx := Plane{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalPlaneMethodBindings.constructor_0, ptr)
	return cx
}

// NewPlane, index: 1
func NewPlaneWithPlane(from Plane) Plane {
	cx := Plane{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Plane
	// PlaneEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPlaneMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewPlane, index: 2
func NewPlaneWithVector3(normal Vector3) Plane {
	cx := Plane{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Vector3
	// Vector3Encoder
	args[0] = normal.NativeConstPtr()
	CallBuiltinConstructor(globalPlaneMethodBindings.constructor_2, ptr, args[0])
	return cx
}

// NewPlane, index: 3
func NewPlaneWithVector3Float32(normal Vector3, d float32) Plane {
	cx := Plane{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [2]GDExtensionConstTypePtr
	// Vector3
	// Vector3Encoder
	args[0] = normal.NativeConstPtr()
	// float
	args[1] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(d))
	CallBuiltinConstructor(globalPlaneMethodBindings.constructor_3, ptr, args[0], args[1])
	return cx
}

// NewPlane, index: 4
func NewPlaneWithVector3Vector3(normal Vector3, point Vector3) Plane {
	cx := Plane{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [2]GDExtensionConstTypePtr
	// Vector3
	// Vector3Encoder
	args[0] = normal.NativeConstPtr()
	// Vector3
	// Vector3Encoder
	args[1] = point.NativeConstPtr()
	CallBuiltinConstructor(globalPlaneMethodBindings.constructor_4, ptr, args[0], args[1])
	return cx
}

// NewPlane, index: 5
func NewPlaneWithVector3Vector3Vector3(point1 Vector3, point2 Vector3, point3 Vector3) Plane {
	cx := Plane{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [3]GDExtensionConstTypePtr
	// Vector3
	// Vector3Encoder
	args[0] = point1.NativeConstPtr()
	// Vector3
	// Vector3Encoder
	args[1] = point2.NativeConstPtr()
	// Vector3
	// Vector3Encoder
	args[2] = point3.NativeConstPtr()
	CallBuiltinConstructor(globalPlaneMethodBindings.constructor_5, ptr, args[0], args[1], args[2])
	return cx
}

// NewPlane, index: 6
func NewPlaneWithFloat32Float32Float32Float32(a float32, b float32, c float32, d float32) Plane {
	cx := Plane{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [4]GDExtensionConstTypePtr
	// float
	args[0] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(a))
	// float
	args[1] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(b))
	// float
	args[2] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(c))
	// float
	args[3] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(d))
	CallBuiltinConstructor(globalPlaneMethodBindings.constructor_6, ptr, args[0], args[1], args[2], args[3])
	return cx
}

// copy funuctions
func NewPlaneWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Plane {
	ret := Plane{}
	typedSrc := (*Plane)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (Plane)(ret)
}
func copyPlaneWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Plane)(dst)
	typedSrc := (*Plane)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Normalized : normalized
 * is_vararg = false, is_static = false
 * goReturnType(Plane) -> Plane
 */
func (cx *Plane) Normalized() Plane {
	mb := globalPlaneMethodBindings.method_normalized
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Plane](mb, bx, nil)
	return ret
}

/* GetCenter : get_center
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Plane) GetCenter() Vector3 {
	mb := globalPlaneMethodBindings.method_get_center
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, nil)
	return ret
}

/* IsEqualApprox : is_equal_approx
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Plane) IsEqualApprox(to_plane Plane) bool {
	mb := globalPlaneMethodBindings.method_is_equal_approx
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to_plane))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsFinite : is_finite
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Plane) IsFinite() bool {
	mb := globalPlaneMethodBindings.method_is_finite
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsPointOver : is_point_over
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Plane) IsPointOver(point Vector3) bool {
	mb := globalPlaneMethodBindings.method_is_point_over
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&point))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DistanceTo : distance_to
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Plane) DistanceTo(point Vector3) float32 {
	mb := globalPlaneMethodBindings.method_distance_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&point))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* HasPoint : has_point
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Plane) HasPoint(point Vector3, tolerance float32) bool {
	mb := globalPlaneMethodBindings.method_has_point
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&point))

	args[1] = Float32Encoder.EncodeTypePtr(tolerance)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Project : project
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Plane) Project(point Vector3) Vector3 {
	mb := globalPlaneMethodBindings.method_project
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&point))

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Intersect3 : intersect_3
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Plane) Intersect3(b Plane, c Plane) Variant {
	mb := globalPlaneMethodBindings.method_intersect_3
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&b))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&c))

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IntersectsRay : intersects_ray
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Plane) IntersectsRay(from Vector3, dir Vector3) Variant {
	mb := globalPlaneMethodBindings.method_intersects_ray
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&from))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&dir))

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IntersectsSegment : intersects_segment
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Plane) IntersectsSegment(from Vector3, to Vector3) Variant {
	mb := globalPlaneMethodBindings.method_intersects_segment
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&from))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

// members

func (cx *Plane) MemberGetx() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalPlaneMethodBindings.member_x_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Plane) MemberGety() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalPlaneMethodBindings.member_y_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Plane) MemberGetz() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalPlaneMethodBindings.member_z_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Plane) MemberGetd() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalPlaneMethodBindings.member_d_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Plane) MemberGetnormal() Vector3 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector3](globalPlaneMethodBindings.member_normal_getter, bx)
	return ret

}

// Equal_Variant operator
func (cx *Plane) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPlaneMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Plane) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPlaneMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Negate operator
func (cx *Plane) Negate() Plane {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Plane](globalPlaneMethodBindings.operator_negate, lt, rt)
}

// Positive operator
func (cx *Plane) Positive() Plane {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Plane](globalPlaneMethodBindings.operator_positive, lt, rt)
}

// Not operator
func (cx *Plane) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalPlaneMethodBindings.operator_not, lt, rt)
}

// Equal_Plane operator
func (cx *Plane) Equal_Plane(right Plane) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPlaneMethodBindings.operator_equal_Plane, lt, rt)
}

// Not_equal_Plane operator
func (cx *Plane) Not_equal_Plane(right Plane) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPlaneMethodBindings.operator_not_equal_Plane, lt, rt)
}

// Multiply_Transform3D operator
func (cx *Plane) Multiply_Transform3D(right Transform3D) Plane {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Plane](globalPlaneMethodBindings.operator_multiply_Transform3D, lt, rt)
}

// In_Dictionary operator
func (cx *Plane) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPlaneMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Plane) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPlaneMethodBindings.operator_in_Array, lt, rt)
}

var _ GDBuiltInClass = &Quaternion{}

/*
 * Quaternion
 * indexingReturnType: float
 * isKeyed: false
 * hasDestructor: false
 */
type Quaternion [16]uint8

func (c *Quaternion) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Quaternion) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewQuaternion, index: 0
func NewQuaternion() Quaternion {
	cx := Quaternion{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalQuaternionMethodBindings.constructor_0, ptr)
	return cx
}

// NewQuaternion, index: 1
func NewQuaternionWithQuaternion(from Quaternion) Quaternion {
	cx := Quaternion{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Quaternion
	// QuaternionEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalQuaternionMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewQuaternion, index: 2
func NewQuaternionWithBasis(from Basis) Quaternion {
	cx := Quaternion{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Basis
	// BasisEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalQuaternionMethodBindings.constructor_2, ptr, args[0])
	return cx
}

// NewQuaternion, index: 3
func NewQuaternionWithVector3Float32(axis Vector3, angle float32) Quaternion {
	cx := Quaternion{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [2]GDExtensionConstTypePtr
	// Vector3
	// Vector3Encoder
	args[0] = axis.NativeConstPtr()
	// float
	args[1] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(angle))
	CallBuiltinConstructor(globalQuaternionMethodBindings.constructor_3, ptr, args[0], args[1])
	return cx
}

// NewQuaternion, index: 4
func NewQuaternionWithVector3Vector3(arc_from Vector3, arc_to Vector3) Quaternion {
	cx := Quaternion{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [2]GDExtensionConstTypePtr
	// Vector3
	// Vector3Encoder
	args[0] = arc_from.NativeConstPtr()
	// Vector3
	// Vector3Encoder
	args[1] = arc_to.NativeConstPtr()
	CallBuiltinConstructor(globalQuaternionMethodBindings.constructor_4, ptr, args[0], args[1])
	return cx
}

// NewQuaternion, index: 5
func NewQuaternionWithFloat32Float32Float32Float32(x float32, y float32, z float32, w float32) Quaternion {
	cx := Quaternion{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [4]GDExtensionConstTypePtr
	// float
	args[0] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(x))
	// float
	args[1] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(y))
	// float
	args[2] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(z))
	// float
	args[3] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(w))
	CallBuiltinConstructor(globalQuaternionMethodBindings.constructor_5, ptr, args[0], args[1], args[2], args[3])
	return cx
}

// copy funuctions
func NewQuaternionWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Quaternion {
	ret := Quaternion{}
	typedSrc := (*Quaternion)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (Quaternion)(ret)
}
func copyQuaternionWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Quaternion)(dst)
	typedSrc := (*Quaternion)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Length : length
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Quaternion) Length() float32 {
	mb := globalQuaternionMethodBindings.method_length
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* LengthSquared : length_squared
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Quaternion) LengthSquared() float32 {
	mb := globalQuaternionMethodBindings.method_length_squared
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* Normalized : normalized
 * is_vararg = false, is_static = false
 * goReturnType(Quaternion) -> Quaternion
 */
func (cx *Quaternion) Normalized() Quaternion {
	mb := globalQuaternionMethodBindings.method_normalized
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Quaternion](mb, bx, nil)
	return ret
}

/* IsNormalized : is_normalized
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Quaternion) IsNormalized() bool {
	mb := globalQuaternionMethodBindings.method_is_normalized
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsEqualApprox : is_equal_approx
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Quaternion) IsEqualApprox(to Quaternion) bool {
	mb := globalQuaternionMethodBindings.method_is_equal_approx
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsFinite : is_finite
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Quaternion) IsFinite() bool {
	mb := globalQuaternionMethodBindings.method_is_finite
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Inverse : inverse
 * is_vararg = false, is_static = false
 * goReturnType(Quaternion) -> Quaternion
 */
func (cx *Quaternion) Inverse() Quaternion {
	mb := globalQuaternionMethodBindings.method_inverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Quaternion](mb, bx, nil)
	return ret
}

/* Log : log
 * is_vararg = false, is_static = false
 * goReturnType(Quaternion) -> Quaternion
 */
func (cx *Quaternion) Log() Quaternion {
	mb := globalQuaternionMethodBindings.method_log
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Quaternion](mb, bx, nil)
	return ret
}

/* Exp : exp
 * is_vararg = false, is_static = false
 * goReturnType(Quaternion) -> Quaternion
 */
func (cx *Quaternion) Exp() Quaternion {
	mb := globalQuaternionMethodBindings.method_exp
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Quaternion](mb, bx, nil)
	return ret
}

/* AngleTo : angle_to
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Quaternion) AngleTo(to Quaternion) float32 {
	mb := globalQuaternionMethodBindings.method_angle_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Dot : dot
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Quaternion) Dot(with Quaternion) float32 {
	mb := globalQuaternionMethodBindings.method_dot
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Slerp : slerp
 * is_vararg = false, is_static = false
 * goReturnType(Quaternion) -> Quaternion
 */
func (cx *Quaternion) Slerp(to Quaternion, weight float32) Quaternion {
	mb := globalQuaternionMethodBindings.method_slerp
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	args[1] = Float32Encoder.EncodeTypePtr(weight)

	ret := CallBuiltinMethodPtrRet[Quaternion](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Slerpni : slerpni
 * is_vararg = false, is_static = false
 * goReturnType(Quaternion) -> Quaternion
 */
func (cx *Quaternion) Slerpni(to Quaternion, weight float32) Quaternion {
	mb := globalQuaternionMethodBindings.method_slerpni
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	args[1] = Float32Encoder.EncodeTypePtr(weight)

	ret := CallBuiltinMethodPtrRet[Quaternion](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* SphericalCubicInterpolate : spherical_cubic_interpolate
 * is_vararg = false, is_static = false
 * goReturnType(Quaternion) -> Quaternion
 */
func (cx *Quaternion) SphericalCubicInterpolate(b Quaternion, pre_a Quaternion, post_b Quaternion, weight float32) Quaternion {
	mb := globalQuaternionMethodBindings.method_spherical_cubic_interpolate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 4
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&b))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&pre_a))

	args[2] = (GDExtensionTypePtr)(unsafe.Pointer(&post_b))

	args[3] = Float32Encoder.EncodeTypePtr(weight)

	ret := CallBuiltinMethodPtrRet[Quaternion](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* SphericalCubicInterpolateInTime : spherical_cubic_interpolate_in_time
 * is_vararg = false, is_static = false
 * goReturnType(Quaternion) -> Quaternion
 */
func (cx *Quaternion) SphericalCubicInterpolateInTime(b Quaternion, pre_a Quaternion, post_b Quaternion, weight float32, b_t float32, pre_a_t float32, post_b_t float32) Quaternion {
	mb := globalQuaternionMethodBindings.method_spherical_cubic_interpolate_in_time
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 7
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&b))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&pre_a))

	args[2] = (GDExtensionTypePtr)(unsafe.Pointer(&post_b))

	args[3] = Float32Encoder.EncodeTypePtr(weight)

	args[4] = Float32Encoder.EncodeTypePtr(b_t)

	args[5] = Float32Encoder.EncodeTypePtr(pre_a_t)

	args[6] = Float32Encoder.EncodeTypePtr(post_b_t)

	ret := CallBuiltinMethodPtrRet[Quaternion](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetEuler : get_euler
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Quaternion) GetEuler(order int64) Vector3 {
	mb := globalQuaternionMethodBindings.method_get_euler
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(order)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* FromEuler : from_euler
 * is_vararg = false, is_static = true
 * goReturnType(Quaternion) -> Quaternion
 */
func (cx *Quaternion) FromEuler(euler Vector3) Quaternion {
	mb := globalQuaternionMethodBindings.method_from_euler
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&euler))

	ret := CallBuiltinMethodPtrRet[Quaternion](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetAxis : get_axis
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Quaternion) GetAxis() Vector3 {
	mb := globalQuaternionMethodBindings.method_get_axis
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, nil)
	return ret
}

/* GetAngle : get_angle
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Quaternion) GetAngle() float32 {
	mb := globalQuaternionMethodBindings.method_get_angle
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

func (cx *Quaternion) GetIndexed(i int64) float32 {
	var ret float32
	CallFunc_GDExtensionPtrIndexedGetter(
		globalQuaternionMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *Quaternion) SetIndexed(i int64, value float32) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalQuaternionMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members

func (cx *Quaternion) MemberGetx() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalQuaternionMethodBindings.member_x_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Quaternion) MemberGety() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalQuaternionMethodBindings.member_y_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Quaternion) MemberGetz() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalQuaternionMethodBindings.member_z_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Quaternion) MemberGetw() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalQuaternionMethodBindings.member_w_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

// Equal_Variant operator
func (cx *Quaternion) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalQuaternionMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Quaternion) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalQuaternionMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Negate operator
func (cx *Quaternion) Negate() Quaternion {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Quaternion](globalQuaternionMethodBindings.operator_negate, lt, rt)
}

// Positive operator
func (cx *Quaternion) Positive() Quaternion {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Quaternion](globalQuaternionMethodBindings.operator_positive, lt, rt)
}

// Not operator
func (cx *Quaternion) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalQuaternionMethodBindings.operator_not, lt, rt)
}

// Multiply_int operator
func (cx *Quaternion) Multiply_int(right int64) Quaternion {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Quaternion](globalQuaternionMethodBindings.operator_multiply_int, lt, rt)
}

// Divide_int operator
func (cx *Quaternion) Divide_int(right int64) Quaternion {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Quaternion](globalQuaternionMethodBindings.operator_divide_int, lt, rt)
}

// Multiply_float operator
func (cx *Quaternion) Multiply_float(right float32) Quaternion {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Quaternion](globalQuaternionMethodBindings.operator_multiply_float, lt, rt)
}

// Divide_float operator
func (cx *Quaternion) Divide_float(right float32) Quaternion {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Quaternion](globalQuaternionMethodBindings.operator_divide_float, lt, rt)
}

// Multiply_Vector3 operator
func (cx *Quaternion) Multiply_Vector3(right Vector3) Vector3 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector3](globalQuaternionMethodBindings.operator_multiply_Vector3, lt, rt)
}

// Equal_Quaternion operator
func (cx *Quaternion) Equal_Quaternion(right Quaternion) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalQuaternionMethodBindings.operator_equal_Quaternion, lt, rt)
}

// Not_equal_Quaternion operator
func (cx *Quaternion) Not_equal_Quaternion(right Quaternion) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalQuaternionMethodBindings.operator_not_equal_Quaternion, lt, rt)
}

// Add_Quaternion operator
func (cx *Quaternion) Add_Quaternion(right Quaternion) Quaternion {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Quaternion](globalQuaternionMethodBindings.operator_add_Quaternion, lt, rt)
}

// Subtract_Quaternion operator
func (cx *Quaternion) Subtract_Quaternion(right Quaternion) Quaternion {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Quaternion](globalQuaternionMethodBindings.operator_subtract_Quaternion, lt, rt)
}

// Multiply_Quaternion operator
func (cx *Quaternion) Multiply_Quaternion(right Quaternion) Quaternion {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Quaternion](globalQuaternionMethodBindings.operator_multiply_Quaternion, lt, rt)
}

// In_Dictionary operator
func (cx *Quaternion) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalQuaternionMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Quaternion) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalQuaternionMethodBindings.operator_in_Array, lt, rt)
}

var _ GDBuiltInClass = &AABB{}

/*
 * AABB
 * indexingReturnType:
 * isKeyed: false
 * hasDestructor: false
 */
type AABB [24]uint8

func (c *AABB) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *AABB) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewAABB, index: 0
func NewAABB() AABB {
	cx := AABB{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalAABBMethodBindings.constructor_0, ptr)
	return cx
}

// NewAABB, index: 1
func NewAABBWithAABB(from AABB) AABB {
	cx := AABB{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// AABB
	// AABBEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalAABBMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewAABB, index: 2
func NewAABBWithVector3Vector3(position Vector3, size Vector3) AABB {
	cx := AABB{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [2]GDExtensionConstTypePtr
	// Vector3
	// Vector3Encoder
	args[0] = position.NativeConstPtr()
	// Vector3
	// Vector3Encoder
	args[1] = size.NativeConstPtr()
	CallBuiltinConstructor(globalAABBMethodBindings.constructor_2, ptr, args[0], args[1])
	return cx
}

// copy funuctions
func NewAABBWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) AABB {
	ret := AABB{}
	typedSrc := (*AABB)(src)

	for i := 0; i < 24; i++ {
		ret[i] = typedSrc[i]
	}

	return (AABB)(ret)
}
func copyAABBWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*AABB)(dst)
	typedSrc := (*AABB)(src)

	for i := 0; i < 24; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Abs : abs
 * is_vararg = false, is_static = false
 * goReturnType(AABB) -> AABB
 */
func (cx *AABB) Abs() AABB {
	mb := globalAABBMethodBindings.method_abs
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[AABB](mb, bx, nil)
	return ret
}

/* GetCenter : get_center
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *AABB) GetCenter() Vector3 {
	mb := globalAABBMethodBindings.method_get_center
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, nil)
	return ret
}

/* GetVolume : get_volume
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *AABB) GetVolume() float32 {
	mb := globalAABBMethodBindings.method_get_volume
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* HasVolume : has_volume
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *AABB) HasVolume() bool {
	mb := globalAABBMethodBindings.method_has_volume
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* HasSurface : has_surface
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *AABB) HasSurface() bool {
	mb := globalAABBMethodBindings.method_has_surface
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* HasPoint : has_point
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *AABB) HasPoint(point Vector3) bool {
	mb := globalAABBMethodBindings.method_has_point
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&point))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsEqualApprox : is_equal_approx
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *AABB) IsEqualApprox(aabb AABB) bool {
	mb := globalAABBMethodBindings.method_is_equal_approx
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&aabb))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsFinite : is_finite
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *AABB) IsFinite() bool {
	mb := globalAABBMethodBindings.method_is_finite
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Intersects : intersects
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *AABB) Intersects(with AABB) bool {
	mb := globalAABBMethodBindings.method_intersects
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Encloses : encloses
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *AABB) Encloses(with AABB) bool {
	mb := globalAABBMethodBindings.method_encloses
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IntersectsPlane : intersects_plane
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *AABB) IntersectsPlane(plane Plane) bool {
	mb := globalAABBMethodBindings.method_intersects_plane
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&plane))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Intersection : intersection
 * is_vararg = false, is_static = false
 * goReturnType(AABB) -> AABB
 */
func (cx *AABB) Intersection(with AABB) AABB {
	mb := globalAABBMethodBindings.method_intersection
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[AABB](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Merge : merge
 * is_vararg = false, is_static = false
 * goReturnType(AABB) -> AABB
 */
func (cx *AABB) Merge(with AABB) AABB {
	mb := globalAABBMethodBindings.method_merge
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[AABB](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Expand : expand
 * is_vararg = false, is_static = false
 * goReturnType(AABB) -> AABB
 */
func (cx *AABB) Expand(to_point Vector3) AABB {
	mb := globalAABBMethodBindings.method_expand
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to_point))

	ret := CallBuiltinMethodPtrRet[AABB](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Grow : grow
 * is_vararg = false, is_static = false
 * goReturnType(AABB) -> AABB
 */
func (cx *AABB) Grow(by float32) AABB {
	mb := globalAABBMethodBindings.method_grow
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(by)

	ret := CallBuiltinMethodPtrRet[AABB](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetSupport : get_support
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *AABB) GetSupport(dir Vector3) Vector3 {
	mb := globalAABBMethodBindings.method_get_support
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&dir))

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetLongestAxis : get_longest_axis
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *AABB) GetLongestAxis() Vector3 {
	mb := globalAABBMethodBindings.method_get_longest_axis
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, nil)
	return ret
}

/* GetLongestAxisIndex : get_longest_axis_index
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *AABB) GetLongestAxisIndex() int64 {
	mb := globalAABBMethodBindings.method_get_longest_axis_index
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* GetLongestAxisSize : get_longest_axis_size
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *AABB) GetLongestAxisSize() float32 {
	mb := globalAABBMethodBindings.method_get_longest_axis_size
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* GetShortestAxis : get_shortest_axis
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *AABB) GetShortestAxis() Vector3 {
	mb := globalAABBMethodBindings.method_get_shortest_axis
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, nil)
	return ret
}

/* GetShortestAxisIndex : get_shortest_axis_index
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *AABB) GetShortestAxisIndex() int64 {
	mb := globalAABBMethodBindings.method_get_shortest_axis_index
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* GetShortestAxisSize : get_shortest_axis_size
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *AABB) GetShortestAxisSize() float32 {
	mb := globalAABBMethodBindings.method_get_shortest_axis_size
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* GetEndpoint : get_endpoint
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *AABB) GetEndpoint(idx int64) Vector3 {
	mb := globalAABBMethodBindings.method_get_endpoint
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(idx)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IntersectsSegment : intersects_segment
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *AABB) IntersectsSegment(from Vector3, to Vector3) Variant {
	mb := globalAABBMethodBindings.method_intersects_segment
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&from))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IntersectsRay : intersects_ray
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *AABB) IntersectsRay(from Vector3, dir Vector3) Variant {
	mb := globalAABBMethodBindings.method_intersects_ray
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&from))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&dir))

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

// members

func (cx *AABB) MemberGetposition() Vector3 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector3](globalAABBMethodBindings.member_position_getter, bx)
	return ret

}

func (cx *AABB) MemberGetsize() Vector3 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector3](globalAABBMethodBindings.member_size_getter, bx)
	return ret

}

func (cx *AABB) MemberGetend() Vector3 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector3](globalAABBMethodBindings.member_end_getter, bx)
	return ret

}

// Equal_Variant operator
func (cx *AABB) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalAABBMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *AABB) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalAABBMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *AABB) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalAABBMethodBindings.operator_not, lt, rt)
}

// Equal_AABB operator
func (cx *AABB) Equal_AABB(right AABB) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalAABBMethodBindings.operator_equal_AABB, lt, rt)
}

// Not_equal_AABB operator
func (cx *AABB) Not_equal_AABB(right AABB) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalAABBMethodBindings.operator_not_equal_AABB, lt, rt)
}

// Multiply_Transform3D operator
func (cx *AABB) Multiply_Transform3D(right Transform3D) AABB {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[AABB](globalAABBMethodBindings.operator_multiply_Transform3D, lt, rt)
}

// In_Dictionary operator
func (cx *AABB) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalAABBMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *AABB) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalAABBMethodBindings.operator_in_Array, lt, rt)
}

var _ GDBuiltInClass = &Basis{}

/*
 * Basis
 * indexingReturnType: Vector3
 * isKeyed: false
 * hasDestructor: false
 */
type Basis [36]uint8

func (c *Basis) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Basis) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewBasis, index: 0
func NewBasis() Basis {
	cx := Basis{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalBasisMethodBindings.constructor_0, ptr)
	return cx
}

// NewBasis, index: 1
func NewBasisWithBasis(from Basis) Basis {
	cx := Basis{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Basis
	// BasisEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalBasisMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewBasis, index: 2
func NewBasisWithQuaternion(from Quaternion) Basis {
	cx := Basis{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Quaternion
	// QuaternionEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalBasisMethodBindings.constructor_2, ptr, args[0])
	return cx
}

// NewBasis, index: 3
func NewBasisWithVector3Float32(axis Vector3, angle float32) Basis {
	cx := Basis{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [2]GDExtensionConstTypePtr
	// Vector3
	// Vector3Encoder
	args[0] = axis.NativeConstPtr()
	// float
	args[1] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(angle))
	CallBuiltinConstructor(globalBasisMethodBindings.constructor_3, ptr, args[0], args[1])
	return cx
}

// NewBasis, index: 4
func NewBasisWithVector3Vector3Vector3(x_axis Vector3, y_axis Vector3, z_axis Vector3) Basis {
	cx := Basis{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [3]GDExtensionConstTypePtr
	// Vector3
	// Vector3Encoder
	args[0] = x_axis.NativeConstPtr()
	// Vector3
	// Vector3Encoder
	args[1] = y_axis.NativeConstPtr()
	// Vector3
	// Vector3Encoder
	args[2] = z_axis.NativeConstPtr()
	CallBuiltinConstructor(globalBasisMethodBindings.constructor_4, ptr, args[0], args[1], args[2])
	return cx
}

// copy funuctions
func NewBasisWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Basis {
	ret := Basis{}
	typedSrc := (*Basis)(src)

	for i := 0; i < 36; i++ {
		ret[i] = typedSrc[i]
	}

	return (Basis)(ret)
}
func copyBasisWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Basis)(dst)
	typedSrc := (*Basis)(src)

	for i := 0; i < 36; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Inverse : inverse
 * is_vararg = false, is_static = false
 * goReturnType(Basis) -> Basis
 */
func (cx *Basis) Inverse() Basis {
	mb := globalBasisMethodBindings.method_inverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Basis](mb, bx, nil)
	return ret
}

/* Transposed : transposed
 * is_vararg = false, is_static = false
 * goReturnType(Basis) -> Basis
 */
func (cx *Basis) Transposed() Basis {
	mb := globalBasisMethodBindings.method_transposed
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Basis](mb, bx, nil)
	return ret
}

/* Orthonormalized : orthonormalized
 * is_vararg = false, is_static = false
 * goReturnType(Basis) -> Basis
 */
func (cx *Basis) Orthonormalized() Basis {
	mb := globalBasisMethodBindings.method_orthonormalized
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Basis](mb, bx, nil)
	return ret
}

/* Determinant : determinant
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Basis) Determinant() float32 {
	mb := globalBasisMethodBindings.method_determinant
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* Rotated : rotated
 * is_vararg = false, is_static = false
 * goReturnType(Basis) -> Basis
 */
func (cx *Basis) Rotated(axis Vector3, angle float32) Basis {
	mb := globalBasisMethodBindings.method_rotated
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&axis))

	args[1] = Float32Encoder.EncodeTypePtr(angle)

	ret := CallBuiltinMethodPtrRet[Basis](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Scaled : scaled
 * is_vararg = false, is_static = false
 * goReturnType(Basis) -> Basis
 */
func (cx *Basis) Scaled(scale Vector3) Basis {
	mb := globalBasisMethodBindings.method_scaled
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&scale))

	ret := CallBuiltinMethodPtrRet[Basis](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetScale : get_scale
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Basis) GetScale() Vector3 {
	mb := globalBasisMethodBindings.method_get_scale
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, nil)
	return ret
}

/* GetEuler : get_euler
 * is_vararg = false, is_static = false
 * goReturnType(Vector3) -> Vector3
 */
func (cx *Basis) GetEuler(order int64) Vector3 {
	mb := globalBasisMethodBindings.method_get_euler
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(order)

	ret := CallBuiltinMethodPtrRet[Vector3](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Tdotx : tdotx
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Basis) Tdotx(with Vector3) float32 {
	mb := globalBasisMethodBindings.method_tdotx
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Tdoty : tdoty
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Basis) Tdoty(with Vector3) float32 {
	mb := globalBasisMethodBindings.method_tdoty
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Tdotz : tdotz
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Basis) Tdotz(with Vector3) float32 {
	mb := globalBasisMethodBindings.method_tdotz
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&with))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Slerp : slerp
 * is_vararg = false, is_static = false
 * goReturnType(Basis) -> Basis
 */
func (cx *Basis) Slerp(to Basis, weight float32) Basis {
	mb := globalBasisMethodBindings.method_slerp
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	args[1] = Float32Encoder.EncodeTypePtr(weight)

	ret := CallBuiltinMethodPtrRet[Basis](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsConformal : is_conformal
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Basis) IsConformal() bool {
	mb := globalBasisMethodBindings.method_is_conformal
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsEqualApprox : is_equal_approx
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Basis) IsEqualApprox(b Basis) bool {
	mb := globalBasisMethodBindings.method_is_equal_approx
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&b))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsFinite : is_finite
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Basis) IsFinite() bool {
	mb := globalBasisMethodBindings.method_is_finite
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* GetRotationQuaternion : get_rotation_quaternion
 * is_vararg = false, is_static = false
 * goReturnType(Quaternion) -> Quaternion
 */
func (cx *Basis) GetRotationQuaternion() Quaternion {
	mb := globalBasisMethodBindings.method_get_rotation_quaternion
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Quaternion](mb, bx, nil)
	return ret
}

/* LookingAt : looking_at
 * is_vararg = false, is_static = true
 * goReturnType(Basis) -> Basis
 */
func (cx *Basis) LookingAt(target Vector3, up Vector3, use_model_front bool) Basis {
	mb := globalBasisMethodBindings.method_looking_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 3
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&target))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&up))

	args[2] = BoolEncoder.EncodeTypePtr(use_model_front)

	ret := CallBuiltinMethodPtrRet[Basis](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* FromScale : from_scale
 * is_vararg = false, is_static = true
 * goReturnType(Basis) -> Basis
 */
func (cx *Basis) FromScale(scale Vector3) Basis {
	mb := globalBasisMethodBindings.method_from_scale
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&scale))

	ret := CallBuiltinMethodPtrRet[Basis](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* FromEuler : from_euler
 * is_vararg = false, is_static = true
 * goReturnType(Basis) -> Basis
 */
func (cx *Basis) FromEuler(euler Vector3, order int64) Basis {
	mb := globalBasisMethodBindings.method_from_euler
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&euler))

	args[1] = Int64Encoder.EncodeTypePtr(order)

	ret := CallBuiltinMethodPtrRet[Basis](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *Basis) GetIndexed(i int64) Vector3 {
	var ret Vector3
	CallFunc_GDExtensionPtrIndexedGetter(
		globalBasisMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *Basis) SetIndexed(i int64, value Vector3) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalBasisMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members

func (cx *Basis) MemberGetx() Vector3 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector3](globalBasisMethodBindings.member_x_getter, bx)
	return ret

}

func (cx *Basis) MemberGety() Vector3 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector3](globalBasisMethodBindings.member_y_getter, bx)
	return ret

}

func (cx *Basis) MemberGetz() Vector3 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector3](globalBasisMethodBindings.member_z_getter, bx)
	return ret

}

// Equal_Variant operator
func (cx *Basis) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalBasisMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Basis) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalBasisMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *Basis) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalBasisMethodBindings.operator_not, lt, rt)
}

// Multiply_int operator
func (cx *Basis) Multiply_int(right int64) Basis {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Basis](globalBasisMethodBindings.operator_multiply_int, lt, rt)
}

// Divide_int operator
func (cx *Basis) Divide_int(right int64) Basis {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Basis](globalBasisMethodBindings.operator_divide_int, lt, rt)
}

// Multiply_float operator
func (cx *Basis) Multiply_float(right float32) Basis {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Basis](globalBasisMethodBindings.operator_multiply_float, lt, rt)
}

// Divide_float operator
func (cx *Basis) Divide_float(right float32) Basis {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Basis](globalBasisMethodBindings.operator_divide_float, lt, rt)
}

// Multiply_Vector3 operator
func (cx *Basis) Multiply_Vector3(right Vector3) Vector3 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector3](globalBasisMethodBindings.operator_multiply_Vector3, lt, rt)
}

// Equal_Basis operator
func (cx *Basis) Equal_Basis(right Basis) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalBasisMethodBindings.operator_equal_Basis, lt, rt)
}

// Not_equal_Basis operator
func (cx *Basis) Not_equal_Basis(right Basis) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalBasisMethodBindings.operator_not_equal_Basis, lt, rt)
}

// Multiply_Basis operator
func (cx *Basis) Multiply_Basis(right Basis) Basis {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Basis](globalBasisMethodBindings.operator_multiply_Basis, lt, rt)
}

// In_Dictionary operator
func (cx *Basis) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalBasisMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Basis) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalBasisMethodBindings.operator_in_Array, lt, rt)
}

var _ GDBuiltInClass = &Transform3D{}

/*
 * Transform3D
 * indexingReturnType:
 * isKeyed: false
 * hasDestructor: false
 */
type Transform3D [48]uint8

func (c *Transform3D) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Transform3D) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewTransform3D, index: 0
func NewTransform3D() Transform3D {
	cx := Transform3D{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalTransform3DMethodBindings.constructor_0, ptr)
	return cx
}

// NewTransform3D, index: 1
func NewTransform3DWithTransform3D(from Transform3D) Transform3D {
	cx := Transform3D{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Transform3D
	// Transform3DEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalTransform3DMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewTransform3D, index: 2
func NewTransform3DWithBasisVector3(basis Basis, origin Vector3) Transform3D {
	cx := Transform3D{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [2]GDExtensionConstTypePtr
	// Basis
	// BasisEncoder
	args[0] = basis.NativeConstPtr()
	// Vector3
	// Vector3Encoder
	args[1] = origin.NativeConstPtr()
	CallBuiltinConstructor(globalTransform3DMethodBindings.constructor_2, ptr, args[0], args[1])
	return cx
}

// NewTransform3D, index: 3
func NewTransform3DWithVector3Vector3Vector3Vector3(x_axis Vector3, y_axis Vector3, z_axis Vector3, origin Vector3) Transform3D {
	cx := Transform3D{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [4]GDExtensionConstTypePtr
	// Vector3
	// Vector3Encoder
	args[0] = x_axis.NativeConstPtr()
	// Vector3
	// Vector3Encoder
	args[1] = y_axis.NativeConstPtr()
	// Vector3
	// Vector3Encoder
	args[2] = z_axis.NativeConstPtr()
	// Vector3
	// Vector3Encoder
	args[3] = origin.NativeConstPtr()
	CallBuiltinConstructor(globalTransform3DMethodBindings.constructor_3, ptr, args[0], args[1], args[2], args[3])
	return cx
}

// NewTransform3D, index: 4
func NewTransform3DWithProjection(from Projection) Transform3D {
	cx := Transform3D{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Projection
	// ProjectionEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalTransform3DMethodBindings.constructor_4, ptr, args[0])
	return cx
}

// copy funuctions
func NewTransform3DWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Transform3D {
	ret := Transform3D{}
	typedSrc := (*Transform3D)(src)

	for i := 0; i < 48; i++ {
		ret[i] = typedSrc[i]
	}

	return (Transform3D)(ret)
}
func copyTransform3DWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Transform3D)(dst)
	typedSrc := (*Transform3D)(src)

	for i := 0; i < 48; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Inverse : inverse
 * is_vararg = false, is_static = false
 * goReturnType(Transform3D) -> Transform3D
 */
func (cx *Transform3D) Inverse() Transform3D {
	mb := globalTransform3DMethodBindings.method_inverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Transform3D](mb, bx, nil)
	return ret
}

/* AffineInverse : affine_inverse
 * is_vararg = false, is_static = false
 * goReturnType(Transform3D) -> Transform3D
 */
func (cx *Transform3D) AffineInverse() Transform3D {
	mb := globalTransform3DMethodBindings.method_affine_inverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Transform3D](mb, bx, nil)
	return ret
}

/* Orthonormalized : orthonormalized
 * is_vararg = false, is_static = false
 * goReturnType(Transform3D) -> Transform3D
 */
func (cx *Transform3D) Orthonormalized() Transform3D {
	mb := globalTransform3DMethodBindings.method_orthonormalized
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Transform3D](mb, bx, nil)
	return ret
}

/* Rotated : rotated
 * is_vararg = false, is_static = false
 * goReturnType(Transform3D) -> Transform3D
 */
func (cx *Transform3D) Rotated(axis Vector3, angle float32) Transform3D {
	mb := globalTransform3DMethodBindings.method_rotated
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&axis))

	args[1] = Float32Encoder.EncodeTypePtr(angle)

	ret := CallBuiltinMethodPtrRet[Transform3D](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* RotatedLocal : rotated_local
 * is_vararg = false, is_static = false
 * goReturnType(Transform3D) -> Transform3D
 */
func (cx *Transform3D) RotatedLocal(axis Vector3, angle float32) Transform3D {
	mb := globalTransform3DMethodBindings.method_rotated_local
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&axis))

	args[1] = Float32Encoder.EncodeTypePtr(angle)

	ret := CallBuiltinMethodPtrRet[Transform3D](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Scaled : scaled
 * is_vararg = false, is_static = false
 * goReturnType(Transform3D) -> Transform3D
 */
func (cx *Transform3D) Scaled(scale Vector3) Transform3D {
	mb := globalTransform3DMethodBindings.method_scaled
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&scale))

	ret := CallBuiltinMethodPtrRet[Transform3D](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* ScaledLocal : scaled_local
 * is_vararg = false, is_static = false
 * goReturnType(Transform3D) -> Transform3D
 */
func (cx *Transform3D) ScaledLocal(scale Vector3) Transform3D {
	mb := globalTransform3DMethodBindings.method_scaled_local
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&scale))

	ret := CallBuiltinMethodPtrRet[Transform3D](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Translated : translated
 * is_vararg = false, is_static = false
 * goReturnType(Transform3D) -> Transform3D
 */
func (cx *Transform3D) Translated(offset Vector3) Transform3D {
	mb := globalTransform3DMethodBindings.method_translated
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&offset))

	ret := CallBuiltinMethodPtrRet[Transform3D](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* TranslatedLocal : translated_local
 * is_vararg = false, is_static = false
 * goReturnType(Transform3D) -> Transform3D
 */
func (cx *Transform3D) TranslatedLocal(offset Vector3) Transform3D {
	mb := globalTransform3DMethodBindings.method_translated_local
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&offset))

	ret := CallBuiltinMethodPtrRet[Transform3D](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* LookingAt : looking_at
 * is_vararg = false, is_static = false
 * goReturnType(Transform3D) -> Transform3D
 */
func (cx *Transform3D) LookingAt(target Vector3, up Vector3, use_model_front bool) Transform3D {
	mb := globalTransform3DMethodBindings.method_looking_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 3
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&target))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&up))

	args[2] = BoolEncoder.EncodeTypePtr(use_model_front)

	ret := CallBuiltinMethodPtrRet[Transform3D](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* InterpolateWith : interpolate_with
 * is_vararg = false, is_static = false
 * goReturnType(Transform3D) -> Transform3D
 */
func (cx *Transform3D) InterpolateWith(xform Transform3D, weight float32) Transform3D {
	mb := globalTransform3DMethodBindings.method_interpolate_with
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&xform))

	args[1] = Float32Encoder.EncodeTypePtr(weight)

	ret := CallBuiltinMethodPtrRet[Transform3D](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsEqualApprox : is_equal_approx
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Transform3D) IsEqualApprox(xform Transform3D) bool {
	mb := globalTransform3DMethodBindings.method_is_equal_approx
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&xform))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsFinite : is_finite
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Transform3D) IsFinite() bool {
	mb := globalTransform3DMethodBindings.method_is_finite
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

// members

func (cx *Transform3D) MemberGetbasis() Basis {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Basis](globalTransform3DMethodBindings.member_basis_getter, bx)
	return ret

}

func (cx *Transform3D) MemberGetorigin() Vector3 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector3](globalTransform3DMethodBindings.member_origin_getter, bx)
	return ret

}

// Equal_Variant operator
func (cx *Transform3D) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalTransform3DMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Transform3D) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalTransform3DMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *Transform3D) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalTransform3DMethodBindings.operator_not, lt, rt)
}

// Multiply_int operator
func (cx *Transform3D) Multiply_int(right int64) Transform3D {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Transform3D](globalTransform3DMethodBindings.operator_multiply_int, lt, rt)
}

// Divide_int operator
func (cx *Transform3D) Divide_int(right int64) Transform3D {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Transform3D](globalTransform3DMethodBindings.operator_divide_int, lt, rt)
}

// Multiply_float operator
func (cx *Transform3D) Multiply_float(right float32) Transform3D {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Transform3D](globalTransform3DMethodBindings.operator_multiply_float, lt, rt)
}

// Divide_float operator
func (cx *Transform3D) Divide_float(right float32) Transform3D {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Transform3D](globalTransform3DMethodBindings.operator_divide_float, lt, rt)
}

// Multiply_Vector3 operator
func (cx *Transform3D) Multiply_Vector3(right Vector3) Vector3 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector3](globalTransform3DMethodBindings.operator_multiply_Vector3, lt, rt)
}

// Multiply_Plane operator
func (cx *Transform3D) Multiply_Plane(right Plane) Plane {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Plane](globalTransform3DMethodBindings.operator_multiply_Plane, lt, rt)
}

// Multiply_AABB operator
func (cx *Transform3D) Multiply_AABB(right AABB) AABB {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[AABB](globalTransform3DMethodBindings.operator_multiply_AABB, lt, rt)
}

// Equal_Transform3D operator
func (cx *Transform3D) Equal_Transform3D(right Transform3D) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalTransform3DMethodBindings.operator_equal_Transform3D, lt, rt)
}

// Not_equal_Transform3D operator
func (cx *Transform3D) Not_equal_Transform3D(right Transform3D) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalTransform3DMethodBindings.operator_not_equal_Transform3D, lt, rt)
}

// Multiply_Transform3D operator
func (cx *Transform3D) Multiply_Transform3D(right Transform3D) Transform3D {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Transform3D](globalTransform3DMethodBindings.operator_multiply_Transform3D, lt, rt)
}

// In_Dictionary operator
func (cx *Transform3D) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalTransform3DMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Transform3D) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalTransform3DMethodBindings.operator_in_Array, lt, rt)
}

// Multiply_PackedVector3Array operator
func (cx *Transform3D) Multiply_PackedVector3Array(right PackedVector3Array) PackedVector3Array {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[PackedVector3Array](globalTransform3DMethodBindings.operator_multiply_PackedVector3Array, lt, rt)
}

var _ GDBuiltInClass = &Projection{}

/*
 * Projection
 * indexingReturnType: Vector4
 * isKeyed: false
 * hasDestructor: false
 */
type Projection [64]uint8

func (c *Projection) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Projection) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewProjection, index: 0
func NewProjection() Projection {
	cx := Projection{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalProjectionMethodBindings.constructor_0, ptr)
	return cx
}

// NewProjection, index: 1
func NewProjectionWithProjection(from Projection) Projection {
	cx := Projection{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Projection
	// ProjectionEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalProjectionMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewProjection, index: 2
func NewProjectionWithTransform3D(from Transform3D) Projection {
	cx := Projection{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Transform3D
	// Transform3DEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalProjectionMethodBindings.constructor_2, ptr, args[0])
	return cx
}

// NewProjection, index: 3
func NewProjectionWithVector4Vector4Vector4Vector4(x_axis Vector4, y_axis Vector4, z_axis Vector4, w_axis Vector4) Projection {
	cx := Projection{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [4]GDExtensionConstTypePtr
	// Vector4
	// Vector4Encoder
	args[0] = x_axis.NativeConstPtr()
	// Vector4
	// Vector4Encoder
	args[1] = y_axis.NativeConstPtr()
	// Vector4
	// Vector4Encoder
	args[2] = z_axis.NativeConstPtr()
	// Vector4
	// Vector4Encoder
	args[3] = w_axis.NativeConstPtr()
	CallBuiltinConstructor(globalProjectionMethodBindings.constructor_3, ptr, args[0], args[1], args[2], args[3])
	return cx
}

// copy funuctions
func NewProjectionWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Projection {
	ret := Projection{}
	typedSrc := (*Projection)(src)

	for i := 0; i < 64; i++ {
		ret[i] = typedSrc[i]
	}

	return (Projection)(ret)
}
func copyProjectionWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Projection)(dst)
	typedSrc := (*Projection)(src)

	for i := 0; i < 64; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* CreateDepthCorrection : create_depth_correction
 * is_vararg = false, is_static = true
 * goReturnType(Projection) -> Projection
 */
func (cx *Projection) CreateDepthCorrection(flip_y bool) Projection {
	mb := globalProjectionMethodBindings.method_create_depth_correction
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = BoolEncoder.EncodeTypePtr(flip_y)

	ret := CallBuiltinMethodPtrRet[Projection](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* CreateLightAtlasRect : create_light_atlas_rect
 * is_vararg = false, is_static = true
 * goReturnType(Projection) -> Projection
 */
func (cx *Projection) CreateLightAtlasRect(rect Rect2) Projection {
	mb := globalProjectionMethodBindings.method_create_light_atlas_rect
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Rect2Encoder.EncodeTypePtr(rect)

	ret := CallBuiltinMethodPtrRet[Projection](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* CreatePerspective : create_perspective
 * is_vararg = false, is_static = true
 * goReturnType(Projection) -> Projection
 */
func (cx *Projection) CreatePerspective(fovy float32, aspect float32, z_near float32, z_far float32, flip_fov bool) Projection {
	mb := globalProjectionMethodBindings.method_create_perspective
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 5
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(fovy)

	args[1] = Float32Encoder.EncodeTypePtr(aspect)

	args[2] = Float32Encoder.EncodeTypePtr(z_near)

	args[3] = Float32Encoder.EncodeTypePtr(z_far)

	args[4] = BoolEncoder.EncodeTypePtr(flip_fov)

	ret := CallBuiltinMethodPtrRet[Projection](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* CreatePerspectiveHmd : create_perspective_hmd
 * is_vararg = false, is_static = true
 * goReturnType(Projection) -> Projection
 */
func (cx *Projection) CreatePerspectiveHmd(fovy float32, aspect float32, z_near float32, z_far float32, flip_fov bool, eye int64, intraocular_dist float32, convergence_dist float32) Projection {
	mb := globalProjectionMethodBindings.method_create_perspective_hmd
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 8
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(fovy)

	args[1] = Float32Encoder.EncodeTypePtr(aspect)

	args[2] = Float32Encoder.EncodeTypePtr(z_near)

	args[3] = Float32Encoder.EncodeTypePtr(z_far)

	args[4] = BoolEncoder.EncodeTypePtr(flip_fov)

	args[5] = Int64Encoder.EncodeTypePtr(eye)

	args[6] = Float32Encoder.EncodeTypePtr(intraocular_dist)

	args[7] = Float32Encoder.EncodeTypePtr(convergence_dist)

	ret := CallBuiltinMethodPtrRet[Projection](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* CreateForHmd : create_for_hmd
 * is_vararg = false, is_static = true
 * goReturnType(Projection) -> Projection
 */
func (cx *Projection) CreateForHmd(eye int64, aspect float32, intraocular_dist float32, display_width float32, display_to_lens float32, oversample float32, z_near float32, z_far float32) Projection {
	mb := globalProjectionMethodBindings.method_create_for_hmd
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 8
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(eye)

	args[1] = Float32Encoder.EncodeTypePtr(aspect)

	args[2] = Float32Encoder.EncodeTypePtr(intraocular_dist)

	args[3] = Float32Encoder.EncodeTypePtr(display_width)

	args[4] = Float32Encoder.EncodeTypePtr(display_to_lens)

	args[5] = Float32Encoder.EncodeTypePtr(oversample)

	args[6] = Float32Encoder.EncodeTypePtr(z_near)

	args[7] = Float32Encoder.EncodeTypePtr(z_far)

	ret := CallBuiltinMethodPtrRet[Projection](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* CreateOrthogonal : create_orthogonal
 * is_vararg = false, is_static = true
 * goReturnType(Projection) -> Projection
 */
func (cx *Projection) CreateOrthogonal(left float32, right float32, bottom float32, top float32, z_near float32, z_far float32) Projection {
	mb := globalProjectionMethodBindings.method_create_orthogonal
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 6
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(left)

	args[1] = Float32Encoder.EncodeTypePtr(right)

	args[2] = Float32Encoder.EncodeTypePtr(bottom)

	args[3] = Float32Encoder.EncodeTypePtr(top)

	args[4] = Float32Encoder.EncodeTypePtr(z_near)

	args[5] = Float32Encoder.EncodeTypePtr(z_far)

	ret := CallBuiltinMethodPtrRet[Projection](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* CreateOrthogonalAspect : create_orthogonal_aspect
 * is_vararg = false, is_static = true
 * goReturnType(Projection) -> Projection
 */
func (cx *Projection) CreateOrthogonalAspect(size float32, aspect float32, z_near float32, z_far float32, flip_fov bool) Projection {
	mb := globalProjectionMethodBindings.method_create_orthogonal_aspect
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 5
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(size)

	args[1] = Float32Encoder.EncodeTypePtr(aspect)

	args[2] = Float32Encoder.EncodeTypePtr(z_near)

	args[3] = Float32Encoder.EncodeTypePtr(z_far)

	args[4] = BoolEncoder.EncodeTypePtr(flip_fov)

	ret := CallBuiltinMethodPtrRet[Projection](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* CreateFrustum : create_frustum
 * is_vararg = false, is_static = true
 * goReturnType(Projection) -> Projection
 */
func (cx *Projection) CreateFrustum(left float32, right float32, bottom float32, top float32, z_near float32, z_far float32) Projection {
	mb := globalProjectionMethodBindings.method_create_frustum
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 6
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(left)

	args[1] = Float32Encoder.EncodeTypePtr(right)

	args[2] = Float32Encoder.EncodeTypePtr(bottom)

	args[3] = Float32Encoder.EncodeTypePtr(top)

	args[4] = Float32Encoder.EncodeTypePtr(z_near)

	args[5] = Float32Encoder.EncodeTypePtr(z_far)

	ret := CallBuiltinMethodPtrRet[Projection](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* CreateFrustumAspect : create_frustum_aspect
 * is_vararg = false, is_static = true
 * goReturnType(Projection) -> Projection
 */
func (cx *Projection) CreateFrustumAspect(size float32, aspect float32, offset Vector2, z_near float32, z_far float32, flip_fov bool) Projection {
	mb := globalProjectionMethodBindings.method_create_frustum_aspect
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 6
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(size)

	args[1] = Float32Encoder.EncodeTypePtr(aspect)

	args[2] = (GDExtensionTypePtr)(unsafe.Pointer(&offset))

	args[3] = Float32Encoder.EncodeTypePtr(z_near)

	args[4] = Float32Encoder.EncodeTypePtr(z_far)

	args[5] = BoolEncoder.EncodeTypePtr(flip_fov)

	ret := CallBuiltinMethodPtrRet[Projection](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* CreateFitAabb : create_fit_aabb
 * is_vararg = false, is_static = true
 * goReturnType(Projection) -> Projection
 */
func (cx *Projection) CreateFitAabb(aabb AABB) Projection {
	mb := globalProjectionMethodBindings.method_create_fit_aabb
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&aabb))

	ret := CallBuiltinMethodPtrRet[Projection](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Determinant : determinant
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Projection) Determinant() float32 {
	mb := globalProjectionMethodBindings.method_determinant
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* PerspectiveZnearAdjusted : perspective_znear_adjusted
 * is_vararg = false, is_static = false
 * goReturnType(Projection) -> Projection
 */
func (cx *Projection) PerspectiveZnearAdjusted(new_znear float32) Projection {
	mb := globalProjectionMethodBindings.method_perspective_znear_adjusted
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(new_znear)

	ret := CallBuiltinMethodPtrRet[Projection](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetProjectionPlane : get_projection_plane
 * is_vararg = false, is_static = false
 * goReturnType(Plane) -> Plane
 */
func (cx *Projection) GetProjectionPlane(plane int64) Plane {
	mb := globalProjectionMethodBindings.method_get_projection_plane
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(plane)

	ret := CallBuiltinMethodPtrRet[Plane](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* FlippedY : flipped_y
 * is_vararg = false, is_static = false
 * goReturnType(Projection) -> Projection
 */
func (cx *Projection) FlippedY() Projection {
	mb := globalProjectionMethodBindings.method_flipped_y
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Projection](mb, bx, nil)
	return ret
}

/* JitterOffseted : jitter_offseted
 * is_vararg = false, is_static = false
 * goReturnType(Projection) -> Projection
 */
func (cx *Projection) JitterOffseted(offset Vector2) Projection {
	mb := globalProjectionMethodBindings.method_jitter_offseted
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&offset))

	ret := CallBuiltinMethodPtrRet[Projection](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetFovy : get_fovy
 * is_vararg = false, is_static = true
 * goReturnType(float) -> float32
 */
func (cx *Projection) GetFovy(fovx float32, aspect float32) float32 {
	mb := globalProjectionMethodBindings.method_get_fovy
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(fovx)

	args[1] = Float32Encoder.EncodeTypePtr(aspect)

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetZFar : get_z_far
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Projection) GetZFar() float32 {
	mb := globalProjectionMethodBindings.method_get_z_far
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* GetZNear : get_z_near
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Projection) GetZNear() float32 {
	mb := globalProjectionMethodBindings.method_get_z_near
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* GetAspect : get_aspect
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Projection) GetAspect() float32 {
	mb := globalProjectionMethodBindings.method_get_aspect
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* GetFov : get_fov
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Projection) GetFov() float32 {
	mb := globalProjectionMethodBindings.method_get_fov
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* IsOrthogonal : is_orthogonal
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Projection) IsOrthogonal() bool {
	mb := globalProjectionMethodBindings.method_is_orthogonal
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* GetViewportHalfExtents : get_viewport_half_extents
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Projection) GetViewportHalfExtents() Vector2 {
	mb := globalProjectionMethodBindings.method_get_viewport_half_extents
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, nil)
	return ret
}

/* GetFarPlaneHalfExtents : get_far_plane_half_extents
 * is_vararg = false, is_static = false
 * goReturnType(Vector2) -> Vector2
 */
func (cx *Projection) GetFarPlaneHalfExtents() Vector2 {
	mb := globalProjectionMethodBindings.method_get_far_plane_half_extents
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Vector2](mb, bx, nil)
	return ret
}

/* Inverse : inverse
 * is_vararg = false, is_static = false
 * goReturnType(Projection) -> Projection
 */
func (cx *Projection) Inverse() Projection {
	mb := globalProjectionMethodBindings.method_inverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Projection](mb, bx, nil)
	return ret
}

/* GetPixelsPerMeter : get_pixels_per_meter
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Projection) GetPixelsPerMeter(for_pixel_width int64) int64 {
	mb := globalProjectionMethodBindings.method_get_pixels_per_meter
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(for_pixel_width)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetLodMultiplier : get_lod_multiplier
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Projection) GetLodMultiplier() float32 {
	mb := globalProjectionMethodBindings.method_get_lod_multiplier
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

func (cx *Projection) GetIndexed(i int64) Vector4 {
	var ret Vector4
	CallFunc_GDExtensionPtrIndexedGetter(
		globalProjectionMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *Projection) SetIndexed(i int64, value Vector4) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalProjectionMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members

func (cx *Projection) MemberGetx() Vector4 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector4](globalProjectionMethodBindings.member_x_getter, bx)
	return ret

}

func (cx *Projection) MemberGety() Vector4 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector4](globalProjectionMethodBindings.member_y_getter, bx)
	return ret

}

func (cx *Projection) MemberGetz() Vector4 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector4](globalProjectionMethodBindings.member_z_getter, bx)
	return ret

}

func (cx *Projection) MemberGetw() Vector4 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[Vector4](globalProjectionMethodBindings.member_w_getter, bx)
	return ret

}

// Equal_Variant operator
func (cx *Projection) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalProjectionMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Projection) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalProjectionMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *Projection) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalProjectionMethodBindings.operator_not, lt, rt)
}

// Multiply_Vector4 operator
func (cx *Projection) Multiply_Vector4(right Vector4) Vector4 {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Vector4](globalProjectionMethodBindings.operator_multiply_Vector4, lt, rt)
}

// Equal_Projection operator
func (cx *Projection) Equal_Projection(right Projection) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalProjectionMethodBindings.operator_equal_Projection, lt, rt)
}

// Not_equal_Projection operator
func (cx *Projection) Not_equal_Projection(right Projection) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalProjectionMethodBindings.operator_not_equal_Projection, lt, rt)
}

// Multiply_Projection operator
func (cx *Projection) Multiply_Projection(right Projection) Projection {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Projection](globalProjectionMethodBindings.operator_multiply_Projection, lt, rt)
}

// In_Dictionary operator
func (cx *Projection) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalProjectionMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Projection) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalProjectionMethodBindings.operator_in_Array, lt, rt)
}

var _ GDBuiltInClass = &Color{}

/*
 * Color
 * indexingReturnType: float
 * isKeyed: false
 * hasDestructor: false
 */
type Color [16]uint8

func (c *Color) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Color) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewColor, index: 0
func NewColor() Color {
	cx := Color{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalColorMethodBindings.constructor_0, ptr)
	return cx
}

// NewColor, index: 1
func NewColorWithColor(from Color) Color {
	cx := Color{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Color
	// ColorEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalColorMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewColor, index: 2
func NewColorWithColorFloat32(from Color, alpha float32) Color {
	cx := Color{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [2]GDExtensionConstTypePtr
	// Color
	// ColorEncoder
	args[0] = from.NativeConstPtr()
	// float
	args[1] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(alpha))
	CallBuiltinConstructor(globalColorMethodBindings.constructor_2, ptr, args[0], args[1])
	return cx
}

// NewColor, index: 3
func NewColorWithFloat32Float32Float32(r float32, g float32, b float32) Color {
	cx := Color{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [3]GDExtensionConstTypePtr
	// float
	args[0] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(r))
	// float
	args[1] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(g))
	// float
	args[2] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(b))
	CallBuiltinConstructor(globalColorMethodBindings.constructor_3, ptr, args[0], args[1], args[2])
	return cx
}

// NewColor, index: 4
func NewColorWithFloat32Float32Float32Float32(r float32, g float32, b float32, a float32) Color {
	cx := Color{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [4]GDExtensionConstTypePtr
	// float
	args[0] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(r))
	// float
	args[1] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(g))
	// float
	args[2] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(b))
	// float
	args[3] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(a))
	CallBuiltinConstructor(globalColorMethodBindings.constructor_4, ptr, args[0], args[1], args[2], args[3])
	return cx
}

// NewColor, index: 5
func NewColorWithString(code String) Color {
	cx := Color{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// String
	// StringEncoder
	args[0] = code.NativeConstPtr()
	CallBuiltinConstructor(globalColorMethodBindings.constructor_5, ptr, args[0])
	return cx
}

// NewColor, index: 6
func NewColorWithStringFloat32(code String, alpha float32) Color {
	cx := Color{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [2]GDExtensionConstTypePtr
	// String
	// StringEncoder
	args[0] = code.NativeConstPtr()
	// float
	args[1] = (GDExtensionConstTypePtr)(Float32Encoder.EncodeTypePtr(alpha))
	CallBuiltinConstructor(globalColorMethodBindings.constructor_6, ptr, args[0], args[1])
	return cx
}

// copy funuctions
func NewColorWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Color {
	ret := Color{}
	typedSrc := (*Color)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (Color)(ret)
}
func copyColorWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Color)(dst)
	typedSrc := (*Color)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* ToArgb32 : to_argb32
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Color) ToArgb32() int64 {
	mb := globalColorMethodBindings.method_to_argb32
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* ToAbgr32 : to_abgr32
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Color) ToAbgr32() int64 {
	mb := globalColorMethodBindings.method_to_abgr32
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* ToRgba32 : to_rgba32
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Color) ToRgba32() int64 {
	mb := globalColorMethodBindings.method_to_rgba32
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* ToArgb64 : to_argb64
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Color) ToArgb64() int64 {
	mb := globalColorMethodBindings.method_to_argb64
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* ToAbgr64 : to_abgr64
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Color) ToAbgr64() int64 {
	mb := globalColorMethodBindings.method_to_abgr64
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* ToRgba64 : to_rgba64
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Color) ToRgba64() int64 {
	mb := globalColorMethodBindings.method_to_rgba64
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* ToHtml : to_html
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *Color) ToHtml(with_alpha bool) String {
	mb := globalColorMethodBindings.method_to_html
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = BoolEncoder.EncodeTypePtr(with_alpha)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clamp : clamp
 * is_vararg = false, is_static = false
 * goReturnType(Color) -> Color
 */
func (cx *Color) Clamp(min Color, max Color) Color {
	mb := globalColorMethodBindings.method_clamp
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&min))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&max))

	ret := CallBuiltinMethodPtrRet[Color](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Inverted : inverted
 * is_vararg = false, is_static = false
 * goReturnType(Color) -> Color
 */
func (cx *Color) Inverted() Color {
	mb := globalColorMethodBindings.method_inverted
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Color](mb, bx, nil)
	return ret
}

/* Lerp : lerp
 * is_vararg = false, is_static = false
 * goReturnType(Color) -> Color
 */
func (cx *Color) Lerp(to Color, weight float32) Color {
	mb := globalColorMethodBindings.method_lerp
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	args[1] = Float32Encoder.EncodeTypePtr(weight)

	ret := CallBuiltinMethodPtrRet[Color](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Lightened : lightened
 * is_vararg = false, is_static = false
 * goReturnType(Color) -> Color
 */
func (cx *Color) Lightened(amount float32) Color {
	mb := globalColorMethodBindings.method_lightened
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(amount)

	ret := CallBuiltinMethodPtrRet[Color](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Darkened : darkened
 * is_vararg = false, is_static = false
 * goReturnType(Color) -> Color
 */
func (cx *Color) Darkened(amount float32) Color {
	mb := globalColorMethodBindings.method_darkened
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(amount)

	ret := CallBuiltinMethodPtrRet[Color](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Blend : blend
 * is_vararg = false, is_static = false
 * goReturnType(Color) -> Color
 */
func (cx *Color) Blend(over Color) Color {
	mb := globalColorMethodBindings.method_blend
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&over))

	ret := CallBuiltinMethodPtrRet[Color](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetLuminance : get_luminance
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *Color) GetLuminance() float32 {
	mb := globalColorMethodBindings.method_get_luminance
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* SrgbToLinear : srgb_to_linear
 * is_vararg = false, is_static = false
 * goReturnType(Color) -> Color
 */
func (cx *Color) SrgbToLinear() Color {
	mb := globalColorMethodBindings.method_srgb_to_linear
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Color](mb, bx, nil)
	return ret
}

/* LinearToSrgb : linear_to_srgb
 * is_vararg = false, is_static = false
 * goReturnType(Color) -> Color
 */
func (cx *Color) LinearToSrgb() Color {
	mb := globalColorMethodBindings.method_linear_to_srgb
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Color](mb, bx, nil)
	return ret
}

/* IsEqualApprox : is_equal_approx
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Color) IsEqualApprox(to Color) bool {
	mb := globalColorMethodBindings.method_is_equal_approx
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Hex : hex
 * is_vararg = false, is_static = true
 * goReturnType(Color) -> Color
 */
func (cx *Color) Hex(hex int64) Color {
	mb := globalColorMethodBindings.method_hex
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(hex)

	ret := CallBuiltinMethodPtrRet[Color](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Hex64 : hex64
 * is_vararg = false, is_static = true
 * goReturnType(Color) -> Color
 */
func (cx *Color) Hex64(hex int64) Color {
	mb := globalColorMethodBindings.method_hex64
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(hex)

	ret := CallBuiltinMethodPtrRet[Color](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Html : html
 * is_vararg = false, is_static = true
 * goReturnType(Color) -> Color
 */
func (cx *Color) Html(rgba String) Color {
	mb := globalColorMethodBindings.method_html
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&rgba))

	ret := CallBuiltinMethodPtrRet[Color](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* HtmlIsValid : html_is_valid
 * is_vararg = false, is_static = true
 * goReturnType(bool) -> bool
 */
func (cx *Color) HtmlIsValid(color String) bool {
	mb := globalColorMethodBindings.method_html_is_valid
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&color))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* FromString : from_string
 * is_vararg = false, is_static = true
 * goReturnType(Color) -> Color
 */
func (cx *Color) FromString(str String, defaultName Color) Color {
	mb := globalColorMethodBindings.method_from_string
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&str))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&defaultName))

	ret := CallBuiltinMethodPtrRet[Color](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* FromHsv : from_hsv
 * is_vararg = false, is_static = true
 * goReturnType(Color) -> Color
 */
func (cx *Color) FromHsv(h float32, s float32, v float32, alpha float32) Color {
	mb := globalColorMethodBindings.method_from_hsv
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 4
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(h)

	args[1] = Float32Encoder.EncodeTypePtr(s)

	args[2] = Float32Encoder.EncodeTypePtr(v)

	args[3] = Float32Encoder.EncodeTypePtr(alpha)

	ret := CallBuiltinMethodPtrRet[Color](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* FromOkHsl : from_ok_hsl
 * is_vararg = false, is_static = true
 * goReturnType(Color) -> Color
 */
func (cx *Color) FromOkHsl(h float32, s float32, l float32, alpha float32) Color {
	mb := globalColorMethodBindings.method_from_ok_hsl
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 4
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(h)

	args[1] = Float32Encoder.EncodeTypePtr(s)

	args[2] = Float32Encoder.EncodeTypePtr(l)

	args[3] = Float32Encoder.EncodeTypePtr(alpha)

	ret := CallBuiltinMethodPtrRet[Color](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* FromRgbe9995 : from_rgbe9995
 * is_vararg = false, is_static = true
 * goReturnType(Color) -> Color
 */
func (cx *Color) FromRgbe9995(rgbe int64) Color {
	mb := globalColorMethodBindings.method_from_rgbe9995
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(rgbe)

	ret := CallBuiltinMethodPtrRet[Color](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *Color) GetIndexed(i int64) float32 {
	var ret float32
	CallFunc_GDExtensionPtrIndexedGetter(
		globalColorMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *Color) SetIndexed(i int64, value float32) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalColorMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members

func (cx *Color) MemberGetr() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalColorMethodBindings.member_r_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Color) MemberGetg() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalColorMethodBindings.member_g_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Color) MemberGetb() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalColorMethodBindings.member_b_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Color) MemberGeta() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalColorMethodBindings.member_a_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Color) MemberGetr8() int64 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[int64](globalColorMethodBindings.member_r8_getter, bx)
	return ret

}

func (cx *Color) MemberGetg8() int64 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[int64](globalColorMethodBindings.member_g8_getter, bx)
	return ret

}

func (cx *Color) MemberGetb8() int64 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[int64](globalColorMethodBindings.member_b8_getter, bx)
	return ret

}

func (cx *Color) MemberGeta8() int64 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[int64](globalColorMethodBindings.member_a8_getter, bx)
	return ret

}

func (cx *Color) MemberGeth() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalColorMethodBindings.member_h_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Color) MemberGets() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalColorMethodBindings.member_s_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

func (cx *Color) MemberGetv() float32 {
	bx := cx.NativeConstPtr()
	ret := CallBuiltinPtrGetter[float64](globalColorMethodBindings.member_v_getter, bx)
	return Float32Encoder.DecodeTypePtr((GDExtensionConstTypePtr)(unsafe.Pointer(&ret)))

}

// Equal_Variant operator
func (cx *Color) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalColorMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Color) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalColorMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Negate operator
func (cx *Color) Negate() Color {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Color](globalColorMethodBindings.operator_negate, lt, rt)
}

// Positive operator
func (cx *Color) Positive() Color {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[Color](globalColorMethodBindings.operator_positive, lt, rt)
}

// Not operator
func (cx *Color) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalColorMethodBindings.operator_not, lt, rt)
}

// Multiply_int operator
func (cx *Color) Multiply_int(right int64) Color {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Color](globalColorMethodBindings.operator_multiply_int, lt, rt)
}

// Divide_int operator
func (cx *Color) Divide_int(right int64) Color {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Color](globalColorMethodBindings.operator_divide_int, lt, rt)
}

// Multiply_float operator
func (cx *Color) Multiply_float(right float32) Color {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Color](globalColorMethodBindings.operator_multiply_float, lt, rt)
}

// Divide_float operator
func (cx *Color) Divide_float(right float32) Color {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[Color](globalColorMethodBindings.operator_divide_float, lt, rt)
}

// Equal_Color operator
func (cx *Color) Equal_Color(right Color) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalColorMethodBindings.operator_equal_Color, lt, rt)
}

// Not_equal_Color operator
func (cx *Color) Not_equal_Color(right Color) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalColorMethodBindings.operator_not_equal_Color, lt, rt)
}

// Add_Color operator
func (cx *Color) Add_Color(right Color) Color {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Color](globalColorMethodBindings.operator_add_Color, lt, rt)
}

// Subtract_Color operator
func (cx *Color) Subtract_Color(right Color) Color {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Color](globalColorMethodBindings.operator_subtract_Color, lt, rt)
}

// Multiply_Color operator
func (cx *Color) Multiply_Color(right Color) Color {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Color](globalColorMethodBindings.operator_multiply_Color, lt, rt)
}

// Divide_Color operator
func (cx *Color) Divide_Color(right Color) Color {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Color](globalColorMethodBindings.operator_divide_Color, lt, rt)
}

// In_Dictionary operator
func (cx *Color) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalColorMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Color) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalColorMethodBindings.operator_in_Array, lt, rt)
}

// In_PackedColorArray operator
func (cx *Color) In_PackedColorArray(right PackedColorArray) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalColorMethodBindings.operator_in_PackedColorArray, lt, rt)
}

var _ GDBuiltInDestroyableClass = &StringName{}

/*
 * StringName
 * indexingReturnType:
 * isKeyed: false
 * hasDestructor: true
 */
type StringName [8]uint8

func (c *StringName) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *StringName) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewStringName, index: 0
func NewStringName() StringName {
	cx := StringName{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalStringNameMethodBindings.constructor_0, ptr)
	return cx
}

// NewStringName, index: 1
func NewStringNameWithStringName(from StringName) StringName {
	cx := StringName{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// StringName
	// StringNameEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalStringNameMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewStringName, index: 2
func NewStringNameWithString(from String) StringName {
	cx := StringName{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// String
	// StringEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalStringNameMethodBindings.constructor_2, ptr, args[0])
	return cx
}

func (cx *StringName) Destroy() {
	md := (GDExtensionPtrDestructor)(globalStringNameMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewStringNameWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) StringName {
	ret := StringName{}
	typedSrc := (*StringName)(src)

	for i := 0; i < 8; i++ {
		ret[i] = typedSrc[i]
	}

	return (StringName)(ret)
}
func copyStringNameWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*StringName)(dst)
	typedSrc := (*StringName)(src)

	for i := 0; i < 8; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* CasecmpTo : casecmp_to
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) CasecmpTo(to String) int64 {
	mb := globalStringNameMethodBindings.method_casecmp_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* NocasecmpTo : nocasecmp_to
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) NocasecmpTo(to String) int64 {
	mb := globalStringNameMethodBindings.method_nocasecmp_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* NaturalcasecmpTo : naturalcasecmp_to
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) NaturalcasecmpTo(to String) int64 {
	mb := globalStringNameMethodBindings.method_naturalcasecmp_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* NaturalnocasecmpTo : naturalnocasecmp_to
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) NaturalnocasecmpTo(to String) int64 {
	mb := globalStringNameMethodBindings.method_naturalnocasecmp_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* FilecasecmpTo : filecasecmp_to
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) FilecasecmpTo(to String) int64 {
	mb := globalStringNameMethodBindings.method_filecasecmp_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* FilenocasecmpTo : filenocasecmp_to
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) FilenocasecmpTo(to String) int64 {
	mb := globalStringNameMethodBindings.method_filenocasecmp_to
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&to))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Length : length
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) Length() int64 {
	mb := globalStringNameMethodBindings.method_length
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* Substr : substr
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Substr(from int64, len int64) String {
	mb := globalStringNameMethodBindings.method_substr
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(from)

	args[1] = Int64Encoder.EncodeTypePtr(len)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetSlice : get_slice
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) GetSlice(delimiter String, slice int64) String {
	mb := globalStringNameMethodBindings.method_get_slice
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&delimiter))

	args[1] = Int64Encoder.EncodeTypePtr(slice)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetSlicec : get_slicec
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) GetSlicec(delimiter int64, slice int64) String {
	mb := globalStringNameMethodBindings.method_get_slicec
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(delimiter)

	args[1] = Int64Encoder.EncodeTypePtr(slice)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetSliceCount : get_slice_count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) GetSliceCount(delimiter String) int64 {
	mb := globalStringNameMethodBindings.method_get_slice_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&delimiter))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Find : find
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) Find(what String, from int64) int64 {
	mb := globalStringNameMethodBindings.method_find
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Findn : findn
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) Findn(what String, from int64) int64 {
	mb := globalStringNameMethodBindings.method_findn
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Count : count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) Count(what String, from int64, to int64) int64 {
	mb := globalStringNameMethodBindings.method_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 3
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	args[2] = Int64Encoder.EncodeTypePtr(to)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Countn : countn
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) Countn(what String, from int64, to int64) int64 {
	mb := globalStringNameMethodBindings.method_countn
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 3
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	args[2] = Int64Encoder.EncodeTypePtr(to)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rfind : rfind
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) Rfind(what String, from int64) int64 {
	mb := globalStringNameMethodBindings.method_rfind
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rfindn : rfindn
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) Rfindn(what String, from int64) int64 {
	mb := globalStringNameMethodBindings.method_rfindn
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Match : match
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) Match(expr String) bool {
	mb := globalStringNameMethodBindings.method_match
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&expr))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Matchn : matchn
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) Matchn(expr String) bool {
	mb := globalStringNameMethodBindings.method_matchn
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&expr))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* BeginsWith : begins_with
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) BeginsWith(text String) bool {
	mb := globalStringNameMethodBindings.method_begins_with
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&text))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* EndsWith : ends_with
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) EndsWith(text String) bool {
	mb := globalStringNameMethodBindings.method_ends_with
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&text))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsSubsequenceOf : is_subsequence_of
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) IsSubsequenceOf(text String) bool {
	mb := globalStringNameMethodBindings.method_is_subsequence_of
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&text))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsSubsequenceOfn : is_subsequence_ofn
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) IsSubsequenceOfn(text String) bool {
	mb := globalStringNameMethodBindings.method_is_subsequence_ofn
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&text))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Bigrams : bigrams
 * is_vararg = false, is_static = false
 * goReturnType(PackedStringArray) -> PackedStringArray
 */
func (cx *StringName) Bigrams() PackedStringArray {
	mb := globalStringNameMethodBindings.method_bigrams
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedStringArray](mb, bx, nil)
	return ret
}

/* Similarity : similarity
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *StringName) Similarity(text String) float32 {
	mb := globalStringNameMethodBindings.method_similarity
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&text))

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Format : format
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Format(values Variant, placeholder String) String {
	mb := globalStringNameMethodBindings.method_format
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&values))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&placeholder))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Replace : replace
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Replace(what String, forwhat String) String {
	mb := globalStringNameMethodBindings.method_replace
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&forwhat))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Replacen : replacen
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Replacen(what String, forwhat String) String {
	mb := globalStringNameMethodBindings.method_replacen
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&forwhat))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Repeat : repeat
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Repeat(count int64) String {
	mb := globalStringNameMethodBindings.method_repeat
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(count)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Reverse : reverse
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Reverse() String {
	mb := globalStringNameMethodBindings.method_reverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Insert : insert
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Insert(position int64, what String) String {
	mb := globalStringNameMethodBindings.method_insert
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(position)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Erase : erase
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Erase(position int64, chars int64) String {
	mb := globalStringNameMethodBindings.method_erase
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(position)

	args[1] = Int64Encoder.EncodeTypePtr(chars)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Capitalize : capitalize
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Capitalize() String {
	mb := globalStringNameMethodBindings.method_capitalize
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* ToCamelCase : to_camel_case
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) ToCamelCase() String {
	mb := globalStringNameMethodBindings.method_to_camel_case
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* ToPascalCase : to_pascal_case
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) ToPascalCase() String {
	mb := globalStringNameMethodBindings.method_to_pascal_case
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* ToSnakeCase : to_snake_case
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) ToSnakeCase() String {
	mb := globalStringNameMethodBindings.method_to_snake_case
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Split : split
 * is_vararg = false, is_static = false
 * goReturnType(PackedStringArray) -> PackedStringArray
 */
func (cx *StringName) Split(delimiter String, allow_empty bool, maxsplit int64) PackedStringArray {
	mb := globalStringNameMethodBindings.method_split
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 3
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&delimiter))

	args[1] = BoolEncoder.EncodeTypePtr(allow_empty)

	args[2] = Int64Encoder.EncodeTypePtr(maxsplit)

	ret := CallBuiltinMethodPtrRet[PackedStringArray](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rsplit : rsplit
 * is_vararg = false, is_static = false
 * goReturnType(PackedStringArray) -> PackedStringArray
 */
func (cx *StringName) Rsplit(delimiter String, allow_empty bool, maxsplit int64) PackedStringArray {
	mb := globalStringNameMethodBindings.method_rsplit
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 3
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&delimiter))

	args[1] = BoolEncoder.EncodeTypePtr(allow_empty)

	args[2] = Int64Encoder.EncodeTypePtr(maxsplit)

	ret := CallBuiltinMethodPtrRet[PackedStringArray](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* SplitFloats : split_floats
 * is_vararg = false, is_static = false
 * goReturnType(PackedFloat64Array) -> PackedFloat64Array
 */
func (cx *StringName) SplitFloats(delimiter String, allow_empty bool) PackedFloat64Array {
	mb := globalStringNameMethodBindings.method_split_floats
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&delimiter))

	args[1] = BoolEncoder.EncodeTypePtr(allow_empty)

	ret := CallBuiltinMethodPtrRet[PackedFloat64Array](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Join : join
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Join(parts PackedStringArray) String {
	mb := globalStringNameMethodBindings.method_join
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&parts))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* ToUpper : to_upper
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) ToUpper() String {
	mb := globalStringNameMethodBindings.method_to_upper
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* ToLower : to_lower
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) ToLower() String {
	mb := globalStringNameMethodBindings.method_to_lower
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Left : left
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Left(length int64) String {
	mb := globalStringNameMethodBindings.method_left
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(length)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Right : right
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Right(length int64) String {
	mb := globalStringNameMethodBindings.method_right
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(length)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* StripEdges : strip_edges
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) StripEdges(left bool, right bool) String {
	mb := globalStringNameMethodBindings.method_strip_edges
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = BoolEncoder.EncodeTypePtr(left)

	args[1] = BoolEncoder.EncodeTypePtr(right)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* StripEscapes : strip_escapes
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) StripEscapes() String {
	mb := globalStringNameMethodBindings.method_strip_escapes
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Lstrip : lstrip
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Lstrip(chars String) String {
	mb := globalStringNameMethodBindings.method_lstrip
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&chars))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rstrip : rstrip
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Rstrip(chars String) String {
	mb := globalStringNameMethodBindings.method_rstrip
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&chars))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetExtension : get_extension
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) GetExtension() String {
	mb := globalStringNameMethodBindings.method_get_extension
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* GetBasename : get_basename
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) GetBasename() String {
	mb := globalStringNameMethodBindings.method_get_basename
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* PathJoin : path_join
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) PathJoin(file String) String {
	mb := globalStringNameMethodBindings.method_path_join
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&file))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* UnicodeAt : unicode_at
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) UnicodeAt(at int64) int64 {
	mb := globalStringNameMethodBindings.method_unicode_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(at)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Indent : indent
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Indent(prefix String) String {
	mb := globalStringNameMethodBindings.method_indent
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&prefix))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Dedent : dedent
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Dedent() String {
	mb := globalStringNameMethodBindings.method_dedent
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Md5Text : md5_text
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Md5Text() String {
	mb := globalStringNameMethodBindings.method_md5_text
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Sha1Text : sha1_text
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Sha1Text() String {
	mb := globalStringNameMethodBindings.method_sha1_text
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Sha256Text : sha256_text
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Sha256Text() String {
	mb := globalStringNameMethodBindings.method_sha256_text
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Md5Buffer : md5_buffer
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *StringName) Md5Buffer() PackedByteArray {
	mb := globalStringNameMethodBindings.method_md5_buffer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* Sha1Buffer : sha1_buffer
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *StringName) Sha1Buffer() PackedByteArray {
	mb := globalStringNameMethodBindings.method_sha1_buffer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* Sha256Buffer : sha256_buffer
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *StringName) Sha256Buffer() PackedByteArray {
	mb := globalStringNameMethodBindings.method_sha256_buffer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* IsEmpty : is_empty
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) IsEmpty() bool {
	mb := globalStringNameMethodBindings.method_is_empty
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Contains : contains
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) Contains(what String) bool {
	mb := globalStringNameMethodBindings.method_contains
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Containsn : containsn
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) Containsn(what String) bool {
	mb := globalStringNameMethodBindings.method_containsn
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsAbsolutePath : is_absolute_path
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) IsAbsolutePath() bool {
	mb := globalStringNameMethodBindings.method_is_absolute_path
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsRelativePath : is_relative_path
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) IsRelativePath() bool {
	mb := globalStringNameMethodBindings.method_is_relative_path
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* SimplifyPath : simplify_path
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) SimplifyPath() String {
	mb := globalStringNameMethodBindings.method_simplify_path
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* GetBaseDir : get_base_dir
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) GetBaseDir() String {
	mb := globalStringNameMethodBindings.method_get_base_dir
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* GetFile : get_file
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) GetFile() String {
	mb := globalStringNameMethodBindings.method_get_file
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* XmlEscape : xml_escape
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) XmlEscape(escape_quotes bool) String {
	mb := globalStringNameMethodBindings.method_xml_escape
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = BoolEncoder.EncodeTypePtr(escape_quotes)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* XmlUnescape : xml_unescape
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) XmlUnescape() String {
	mb := globalStringNameMethodBindings.method_xml_unescape
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* UriEncode : uri_encode
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) UriEncode() String {
	mb := globalStringNameMethodBindings.method_uri_encode
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* UriDecode : uri_decode
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) UriDecode() String {
	mb := globalStringNameMethodBindings.method_uri_decode
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* CEscape : c_escape
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) CEscape() String {
	mb := globalStringNameMethodBindings.method_c_escape
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* CUnescape : c_unescape
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) CUnescape() String {
	mb := globalStringNameMethodBindings.method_c_unescape
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* JsonEscape : json_escape
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) JsonEscape() String {
	mb := globalStringNameMethodBindings.method_json_escape
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* ValidateNodeName : validate_node_name
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) ValidateNodeName() String {
	mb := globalStringNameMethodBindings.method_validate_node_name
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* ValidateFilename : validate_filename
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) ValidateFilename() String {
	mb := globalStringNameMethodBindings.method_validate_filename
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* IsValidIdentifier : is_valid_identifier
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) IsValidIdentifier() bool {
	mb := globalStringNameMethodBindings.method_is_valid_identifier
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsValidInt : is_valid_int
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) IsValidInt() bool {
	mb := globalStringNameMethodBindings.method_is_valid_int
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsValidFloat : is_valid_float
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) IsValidFloat() bool {
	mb := globalStringNameMethodBindings.method_is_valid_float
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsValidHexNumber : is_valid_hex_number
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) IsValidHexNumber(with_prefix bool) bool {
	mb := globalStringNameMethodBindings.method_is_valid_hex_number
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = BoolEncoder.EncodeTypePtr(with_prefix)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsValidHtmlColor : is_valid_html_color
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) IsValidHtmlColor() bool {
	mb := globalStringNameMethodBindings.method_is_valid_html_color
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsValidIpAddress : is_valid_ip_address
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) IsValidIpAddress() bool {
	mb := globalStringNameMethodBindings.method_is_valid_ip_address
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsValidFilename : is_valid_filename
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *StringName) IsValidFilename() bool {
	mb := globalStringNameMethodBindings.method_is_valid_filename
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* ToInt : to_int
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) ToInt() int64 {
	mb := globalStringNameMethodBindings.method_to_int
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* ToFloat : to_float
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *StringName) ToFloat() float32 {
	mb := globalStringNameMethodBindings.method_to_float
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, nil)
	return ret
}

/* HexToInt : hex_to_int
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) HexToInt() int64 {
	mb := globalStringNameMethodBindings.method_hex_to_int
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* BinToInt : bin_to_int
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) BinToInt() int64 {
	mb := globalStringNameMethodBindings.method_bin_to_int
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* Lpad : lpad
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Lpad(min_length int64, character String) String {
	mb := globalStringNameMethodBindings.method_lpad
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(min_length)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&character))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rpad : rpad
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) Rpad(min_length int64, character String) String {
	mb := globalStringNameMethodBindings.method_rpad
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(min_length)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&character))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* PadDecimals : pad_decimals
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) PadDecimals(digits int64) String {
	mb := globalStringNameMethodBindings.method_pad_decimals
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(digits)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* PadZeros : pad_zeros
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) PadZeros(digits int64) String {
	mb := globalStringNameMethodBindings.method_pad_zeros
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(digits)

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* TrimPrefix : trim_prefix
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) TrimPrefix(prefix String) String {
	mb := globalStringNameMethodBindings.method_trim_prefix
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&prefix))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* TrimSuffix : trim_suffix
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *StringName) TrimSuffix(suffix String) String {
	mb := globalStringNameMethodBindings.method_trim_suffix
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&suffix))

	ret := CallBuiltinMethodPtrRet[String](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* ToAsciiBuffer : to_ascii_buffer
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *StringName) ToAsciiBuffer() PackedByteArray {
	mb := globalStringNameMethodBindings.method_to_ascii_buffer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* ToUtf8Buffer : to_utf8_buffer
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *StringName) ToUtf8Buffer() PackedByteArray {
	mb := globalStringNameMethodBindings.method_to_utf8_buffer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* ToUtf16Buffer : to_utf16_buffer
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *StringName) ToUtf16Buffer() PackedByteArray {
	mb := globalStringNameMethodBindings.method_to_utf16_buffer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* ToUtf32Buffer : to_utf32_buffer
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *StringName) ToUtf32Buffer() PackedByteArray {
	mb := globalStringNameMethodBindings.method_to_utf32_buffer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* HexDecode : hex_decode
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *StringName) HexDecode() PackedByteArray {
	mb := globalStringNameMethodBindings.method_hex_decode
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* ToWcharBuffer : to_wchar_buffer
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *StringName) ToWcharBuffer() PackedByteArray {
	mb := globalStringNameMethodBindings.method_to_wchar_buffer
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* Hash : hash
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *StringName) Hash() int64 {
	mb := globalStringNameMethodBindings.method_hash
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

// members
// Equal_Variant operator
func (cx *StringName) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *StringName) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Module_Variant operator
func (cx *StringName) Module_Variant(right Variant) String {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Variant, lt, rt)
}

// Not operator
func (cx *StringName) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_not, lt, rt)
}

// Module_bool operator
func (cx *StringName) Module_bool(right bool) String {
	lt := cx.NativeConstPtr()
	eRight := BoolEncoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_bool, lt, rt)
}

// Module_int operator
func (cx *StringName) Module_int(right int64) String {
	lt := cx.NativeConstPtr()
	eRight := Int64Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_int, lt, rt)
}

// Module_float operator
func (cx *StringName) Module_float(right float32) String {
	lt := cx.NativeConstPtr()
	eRight := Float32Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_float, lt, rt)
}

// Equal_String operator
func (cx *StringName) Equal_String(right String) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_equal_String, lt, rt)
}

// Not_equal_String operator
func (cx *StringName) Not_equal_String(right String) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_not_equal_String, lt, rt)
}

// Add_String operator
func (cx *StringName) Add_String(right String) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_add_String, lt, rt)
}

// Module_String operator
func (cx *StringName) Module_String(right String) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_String, lt, rt)
}

// In_String operator
func (cx *StringName) In_String(right String) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_in_String, lt, rt)
}

// Module_Vector2 operator
func (cx *StringName) Module_Vector2(right Vector2) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Vector2, lt, rt)
}

// Module_Vector2i operator
func (cx *StringName) Module_Vector2i(right Vector2i) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Vector2i, lt, rt)
}

// Module_Rect2 operator
func (cx *StringName) Module_Rect2(right Rect2) String {
	lt := cx.NativeConstPtr()
	eRight := Rect2Encoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Rect2, lt, rt)
}

// Module_Rect2i operator
func (cx *StringName) Module_Rect2i(right Rect2i) String {
	lt := cx.NativeConstPtr()
	eRight := Rect2iEncoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Rect2i, lt, rt)
}

// Module_Vector3 operator
func (cx *StringName) Module_Vector3(right Vector3) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Vector3, lt, rt)
}

// Module_Vector3i operator
func (cx *StringName) Module_Vector3i(right Vector3i) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Vector3i, lt, rt)
}

// Module_Transform2D operator
func (cx *StringName) Module_Transform2D(right Transform2D) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Transform2D, lt, rt)
}

// Module_Vector4 operator
func (cx *StringName) Module_Vector4(right Vector4) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Vector4, lt, rt)
}

// Module_Vector4i operator
func (cx *StringName) Module_Vector4i(right Vector4i) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Vector4i, lt, rt)
}

// Module_Plane operator
func (cx *StringName) Module_Plane(right Plane) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Plane, lt, rt)
}

// Module_Quaternion operator
func (cx *StringName) Module_Quaternion(right Quaternion) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Quaternion, lt, rt)
}

// Module_AABB operator
func (cx *StringName) Module_AABB(right AABB) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_AABB, lt, rt)
}

// Module_Basis operator
func (cx *StringName) Module_Basis(right Basis) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Basis, lt, rt)
}

// Module_Transform3D operator
func (cx *StringName) Module_Transform3D(right Transform3D) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Transform3D, lt, rt)
}

// Module_Projection operator
func (cx *StringName) Module_Projection(right Projection) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Projection, lt, rt)
}

// Module_Color operator
func (cx *StringName) Module_Color(right Color) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Color, lt, rt)
}

// Equal_StringName operator
func (cx *StringName) Equal_StringName(right StringName) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_equal_StringName, lt, rt)
}

// Not_equal_StringName operator
func (cx *StringName) Not_equal_StringName(right StringName) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_not_equal_StringName, lt, rt)
}

// Less_StringName operator
func (cx *StringName) Less_StringName(right StringName) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_less_StringName, lt, rt)
}

// Less_equal_StringName operator
func (cx *StringName) Less_equal_StringName(right StringName) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_less_equal_StringName, lt, rt)
}

// Greater_StringName operator
func (cx *StringName) Greater_StringName(right StringName) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_greater_StringName, lt, rt)
}

// Greater_equal_StringName operator
func (cx *StringName) Greater_equal_StringName(right StringName) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_greater_equal_StringName, lt, rt)
}

// Add_StringName operator
func (cx *StringName) Add_StringName(right StringName) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_add_StringName, lt, rt)
}

// Module_StringName operator
func (cx *StringName) Module_StringName(right StringName) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_StringName, lt, rt)
}

// In_StringName operator
func (cx *StringName) In_StringName(right StringName) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_in_StringName, lt, rt)
}

// Module_NodePath operator
func (cx *StringName) Module_NodePath(right NodePath) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_NodePath, lt, rt)
}

// Module_Object operator
func (cx *StringName) Module_Object(right Object) String {
	lt := cx.NativeConstPtr()
	eRight := ObjectEncoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Object, lt, rt)
}

// In_Object operator
func (cx *StringName) In_Object(right Object) bool {
	lt := cx.NativeConstPtr()
	eRight := ObjectEncoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_in_Object, lt, rt)
}

// Module_Callable operator
func (cx *StringName) Module_Callable(right Callable) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Callable, lt, rt)
}

// Module_Signal operator
func (cx *StringName) Module_Signal(right Signal) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Signal, lt, rt)
}

// Module_Dictionary operator
func (cx *StringName) Module_Dictionary(right Dictionary) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Dictionary, lt, rt)
}

// In_Dictionary operator
func (cx *StringName) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_in_Dictionary, lt, rt)
}

// Module_Array operator
func (cx *StringName) Module_Array(right Array) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_Array, lt, rt)
}

// In_Array operator
func (cx *StringName) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_in_Array, lt, rt)
}

// Module_PackedByteArray operator
func (cx *StringName) Module_PackedByteArray(right PackedByteArray) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_PackedByteArray, lt, rt)
}

// Module_PackedInt32Array operator
func (cx *StringName) Module_PackedInt32Array(right PackedInt32Array) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_PackedInt32Array, lt, rt)
}

// Module_PackedInt64Array operator
func (cx *StringName) Module_PackedInt64Array(right PackedInt64Array) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_PackedInt64Array, lt, rt)
}

// Module_PackedFloat32Array operator
func (cx *StringName) Module_PackedFloat32Array(right PackedFloat32Array) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_PackedFloat32Array, lt, rt)
}

// Module_PackedFloat64Array operator
func (cx *StringName) Module_PackedFloat64Array(right PackedFloat64Array) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_PackedFloat64Array, lt, rt)
}

// Module_PackedStringArray operator
func (cx *StringName) Module_PackedStringArray(right PackedStringArray) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_PackedStringArray, lt, rt)
}

// In_PackedStringArray operator
func (cx *StringName) In_PackedStringArray(right PackedStringArray) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalStringNameMethodBindings.operator_in_PackedStringArray, lt, rt)
}

// Module_PackedVector2Array operator
func (cx *StringName) Module_PackedVector2Array(right PackedVector2Array) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_PackedVector2Array, lt, rt)
}

// Module_PackedVector3Array operator
func (cx *StringName) Module_PackedVector3Array(right PackedVector3Array) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_PackedVector3Array, lt, rt)
}

// Module_PackedColorArray operator
func (cx *StringName) Module_PackedColorArray(right PackedColorArray) String {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_PackedColorArray, lt, rt)
}

// Module_PackedVector4Array operator
func (cx *StringName) Module_PackedVector4Array(right PackedVector4Array) String {
	lt := cx.NativeConstPtr()
	eRight := PackedVector4ArrayEncoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[String](globalStringNameMethodBindings.operator_module_PackedVector4Array, lt, rt)
}

var _ GDBuiltInDestroyableClass = &NodePath{}

/*
 * NodePath
 * indexingReturnType:
 * isKeyed: false
 * hasDestructor: true
 */
type NodePath [8]uint8

func (c *NodePath) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *NodePath) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewNodePath, index: 0
func NewNodePath() NodePath {
	cx := NodePath{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalNodePathMethodBindings.constructor_0, ptr)
	return cx
}

// NewNodePath, index: 1
func NewNodePathWithNodePath(from NodePath) NodePath {
	cx := NodePath{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// NodePath
	// NodePathEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalNodePathMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewNodePath, index: 2
func NewNodePathWithString(from String) NodePath {
	cx := NodePath{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// String
	// StringEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalNodePathMethodBindings.constructor_2, ptr, args[0])
	return cx
}

func (cx *NodePath) Destroy() {
	md := (GDExtensionPtrDestructor)(globalNodePathMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewNodePathWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) NodePath {
	ret := NodePath{}
	typedSrc := (*NodePath)(src)

	for i := 0; i < 8; i++ {
		ret[i] = typedSrc[i]
	}

	return (NodePath)(ret)
}
func copyNodePathWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*NodePath)(dst)
	typedSrc := (*NodePath)(src)

	for i := 0; i < 8; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* IsAbsolute : is_absolute
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *NodePath) IsAbsolute() bool {
	mb := globalNodePathMethodBindings.method_is_absolute
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* GetNameCount : get_name_count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *NodePath) GetNameCount() int64 {
	mb := globalNodePathMethodBindings.method_get_name_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* GetName : get_name
 * is_vararg = false, is_static = false
 * goReturnType(StringName) -> StringName
 */
func (cx *NodePath) GetName(idx int64) StringName {
	mb := globalNodePathMethodBindings.method_get_name
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(idx)

	ret := CallBuiltinMethodPtrRet[StringName](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetSubnameCount : get_subname_count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *NodePath) GetSubnameCount() int64 {
	mb := globalNodePathMethodBindings.method_get_subname_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* Hash : hash
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *NodePath) Hash() int64 {
	mb := globalNodePathMethodBindings.method_hash
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* GetSubname : get_subname
 * is_vararg = false, is_static = false
 * goReturnType(StringName) -> StringName
 */
func (cx *NodePath) GetSubname(idx int64) StringName {
	mb := globalNodePathMethodBindings.method_get_subname
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(idx)

	ret := CallBuiltinMethodPtrRet[StringName](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetConcatenatedNames : get_concatenated_names
 * is_vararg = false, is_static = false
 * goReturnType(StringName) -> StringName
 */
func (cx *NodePath) GetConcatenatedNames() StringName {
	mb := globalNodePathMethodBindings.method_get_concatenated_names
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[StringName](mb, bx, nil)
	return ret
}

/* GetConcatenatedSubnames : get_concatenated_subnames
 * is_vararg = false, is_static = false
 * goReturnType(StringName) -> StringName
 */
func (cx *NodePath) GetConcatenatedSubnames() StringName {
	mb := globalNodePathMethodBindings.method_get_concatenated_subnames
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[StringName](mb, bx, nil)
	return ret
}

/* Slice : slice
 * is_vararg = false, is_static = false
 * goReturnType(NodePath) -> NodePath
 */
func (cx *NodePath) Slice(begin int64, end int64) NodePath {
	mb := globalNodePathMethodBindings.method_slice
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(begin)

	args[1] = Int64Encoder.EncodeTypePtr(end)

	ret := CallBuiltinMethodPtrRet[NodePath](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetAsPropertyPath : get_as_property_path
 * is_vararg = false, is_static = false
 * goReturnType(NodePath) -> NodePath
 */
func (cx *NodePath) GetAsPropertyPath() NodePath {
	mb := globalNodePathMethodBindings.method_get_as_property_path
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[NodePath](mb, bx, nil)
	return ret
}

/* IsEmpty : is_empty
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *NodePath) IsEmpty() bool {
	mb := globalNodePathMethodBindings.method_is_empty
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

// members
// Equal_Variant operator
func (cx *NodePath) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalNodePathMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *NodePath) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalNodePathMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *NodePath) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalNodePathMethodBindings.operator_not, lt, rt)
}

// Equal_NodePath operator
func (cx *NodePath) Equal_NodePath(right NodePath) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalNodePathMethodBindings.operator_equal_NodePath, lt, rt)
}

// Not_equal_NodePath operator
func (cx *NodePath) Not_equal_NodePath(right NodePath) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalNodePathMethodBindings.operator_not_equal_NodePath, lt, rt)
}

// In_Dictionary operator
func (cx *NodePath) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalNodePathMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *NodePath) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalNodePathMethodBindings.operator_in_Array, lt, rt)
}

var _ GDBuiltInClass = &RID{}

/*
 * RID
 * indexingReturnType:
 * isKeyed: false
 * hasDestructor: false
 */
type RID [8]uint8

func (c *RID) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *RID) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewRID, index: 0
func NewRID() RID {
	cx := RID{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalRIDMethodBindings.constructor_0, ptr)
	return cx
}

// NewRID, index: 1
func NewRIDWithRID(from RID) RID {
	cx := RID{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// RID
	// RIDEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalRIDMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// copy funuctions
func NewRIDWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) RID {
	ret := RID{}
	typedSrc := (*RID)(src)

	for i := 0; i < 8; i++ {
		ret[i] = typedSrc[i]
	}

	return (RID)(ret)
}
func copyRIDWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*RID)(dst)
	typedSrc := (*RID)(src)

	for i := 0; i < 8; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* IsValid : is_valid
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *RID) IsValid() bool {
	mb := globalRIDMethodBindings.method_is_valid
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* GetId : get_id
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *RID) GetId() int64 {
	mb := globalRIDMethodBindings.method_get_id
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

// members
// Equal_Variant operator
func (cx *RID) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalRIDMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *RID) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalRIDMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *RID) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalRIDMethodBindings.operator_not, lt, rt)
}

// Equal_RID operator
func (cx *RID) Equal_RID(right RID) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalRIDMethodBindings.operator_equal_RID, lt, rt)
}

// Not_equal_RID operator
func (cx *RID) Not_equal_RID(right RID) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalRIDMethodBindings.operator_not_equal_RID, lt, rt)
}

// Less_RID operator
func (cx *RID) Less_RID(right RID) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalRIDMethodBindings.operator_less_RID, lt, rt)
}

// Less_equal_RID operator
func (cx *RID) Less_equal_RID(right RID) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalRIDMethodBindings.operator_less_equal_RID, lt, rt)
}

// Greater_RID operator
func (cx *RID) Greater_RID(right RID) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalRIDMethodBindings.operator_greater_RID, lt, rt)
}

// Greater_equal_RID operator
func (cx *RID) Greater_equal_RID(right RID) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalRIDMethodBindings.operator_greater_equal_RID, lt, rt)
}

var _ GDBuiltInDestroyableClass = &Callable{}

/*
 * Callable
 * indexingReturnType:
 * isKeyed: false
 * hasDestructor: true
 */
type Callable [16]uint8

func (c *Callable) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Callable) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewCallable, index: 0
func NewCallable() Callable {
	cx := Callable{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalCallableMethodBindings.constructor_0, ptr)
	return cx
}

// NewCallable, index: 1
func NewCallableWithCallable(from Callable) Callable {
	cx := Callable{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Callable
	// CallableEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalCallableMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewCallable, index: 2
func NewCallableWithObjectStringName(object Object, method StringName) Callable {
	cx := Callable{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [2]GDExtensionConstTypePtr
	// Object
	arg0 := object.GetGodotObjectOwner()
	args[0] = (GDExtensionConstTypePtr)(unsafe.Pointer(&arg0))
	// StringName
	// StringNameEncoder
	args[1] = method.NativeConstPtr()
	CallBuiltinConstructor(globalCallableMethodBindings.constructor_2, ptr, args[0], args[1])
	return cx
}

func (cx *Callable) Destroy() {
	md := (GDExtensionPtrDestructor)(globalCallableMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewCallableWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Callable {
	ret := Callable{}
	typedSrc := (*Callable)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (Callable)(ret)
}
func copyCallableWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Callable)(dst)
	typedSrc := (*Callable)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Create : create
 * is_vararg = false, is_static = true
 * goReturnType(Callable) -> Callable
 */
func (cx *Callable) Create(variant Variant, method StringName) Callable {
	mb := globalCallableMethodBindings.method_create
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := (GDExtensionTypePtr)(nullptr)
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&variant))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&method))

	ret := CallBuiltinMethodPtrRet[Callable](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Callv : callv
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Callable) Callv(arguments Array) Variant {
	mb := globalCallableMethodBindings.method_callv
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&arguments))

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* IsNull : is_null
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Callable) IsNull() bool {
	mb := globalCallableMethodBindings.method_is_null
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsCustom : is_custom
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Callable) IsCustom() bool {
	mb := globalCallableMethodBindings.method_is_custom
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsStandard : is_standard
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Callable) IsStandard() bool {
	mb := globalCallableMethodBindings.method_is_standard
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsValid : is_valid
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Callable) IsValid() bool {
	mb := globalCallableMethodBindings.method_is_valid
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* GetObject : get_object
 * is_vararg = false, is_static = false
 * goReturnType(Object) -> Object
 */
func (cx *Callable) GetObject() Object {
	mb := globalCallableMethodBindings.method_get_object
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Object](mb, bx, nil)
	return ret
}

/* GetObjectId : get_object_id
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Callable) GetObjectId() int64 {
	mb := globalCallableMethodBindings.method_get_object_id
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* GetMethod : get_method
 * is_vararg = false, is_static = false
 * goReturnType(StringName) -> StringName
 */
func (cx *Callable) GetMethod() StringName {
	mb := globalCallableMethodBindings.method_get_method
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[StringName](mb, bx, nil)
	return ret
}

/* GetArgumentCount : get_argument_count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Callable) GetArgumentCount() int64 {
	mb := globalCallableMethodBindings.method_get_argument_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* GetBoundArgumentsCount : get_bound_arguments_count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Callable) GetBoundArgumentsCount() int64 {
	mb := globalCallableMethodBindings.method_get_bound_arguments_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* GetBoundArguments : get_bound_arguments
 * is_vararg = false, is_static = false
 * goReturnType(Array) -> Array
 */
func (cx *Callable) GetBoundArguments() Array {
	mb := globalCallableMethodBindings.method_get_bound_arguments
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Array](mb, bx, nil)
	return ret
}

/* Hash : hash
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Callable) Hash() int64 {
	mb := globalCallableMethodBindings.method_hash
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* Bindv : bindv
 * is_vararg = false, is_static = false
 * goReturnType(Callable) -> Callable
 */
func (cx *Callable) Bindv(arguments Array) Callable {
	mb := globalCallableMethodBindings.method_bindv
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&arguments))

	ret := CallBuiltinMethodPtrRet[Callable](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Unbind : unbind
 * is_vararg = false, is_static = false
 * goReturnType(Callable) -> Callable
 */
func (cx *Callable) Unbind(argcount int64) Callable {
	mb := globalCallableMethodBindings.method_unbind
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(argcount)

	ret := CallBuiltinMethodPtrRet[Callable](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

// members
// Equal_Variant operator
func (cx *Callable) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalCallableMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Callable) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalCallableMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *Callable) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalCallableMethodBindings.operator_not, lt, rt)
}

// Equal_Callable operator
func (cx *Callable) Equal_Callable(right Callable) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalCallableMethodBindings.operator_equal_Callable, lt, rt)
}

// Not_equal_Callable operator
func (cx *Callable) Not_equal_Callable(right Callable) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalCallableMethodBindings.operator_not_equal_Callable, lt, rt)
}

// In_Dictionary operator
func (cx *Callable) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalCallableMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Callable) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalCallableMethodBindings.operator_in_Array, lt, rt)
}

var _ GDBuiltInDestroyableClass = &Signal{}

/*
 * Signal
 * indexingReturnType:
 * isKeyed: false
 * hasDestructor: true
 */
type Signal [16]uint8

func (c *Signal) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Signal) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewSignal, index: 0
func NewSignal() Signal {
	cx := Signal{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalSignalMethodBindings.constructor_0, ptr)
	return cx
}

// NewSignal, index: 1
func NewSignalWithSignal(from Signal) Signal {
	cx := Signal{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Signal
	// SignalEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalSignalMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewSignal, index: 2
func NewSignalWithObjectStringName(object Object, signal StringName) Signal {
	cx := Signal{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [2]GDExtensionConstTypePtr
	// Object
	arg0 := object.GetGodotObjectOwner()
	args[0] = (GDExtensionConstTypePtr)(unsafe.Pointer(&arg0))
	// StringName
	// StringNameEncoder
	args[1] = signal.NativeConstPtr()
	CallBuiltinConstructor(globalSignalMethodBindings.constructor_2, ptr, args[0], args[1])
	return cx
}

func (cx *Signal) Destroy() {
	md := (GDExtensionPtrDestructor)(globalSignalMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewSignalWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Signal {
	ret := Signal{}
	typedSrc := (*Signal)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (Signal)(ret)
}
func copySignalWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Signal)(dst)
	typedSrc := (*Signal)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* IsNull : is_null
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Signal) IsNull() bool {
	mb := globalSignalMethodBindings.method_is_null
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* GetObject : get_object
 * is_vararg = false, is_static = false
 * goReturnType(Object) -> Object
 */
func (cx *Signal) GetObject() Object {
	mb := globalSignalMethodBindings.method_get_object
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Object](mb, bx, nil)
	return ret
}

/* GetObjectId : get_object_id
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Signal) GetObjectId() int64 {
	mb := globalSignalMethodBindings.method_get_object_id
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* GetName : get_name
 * is_vararg = false, is_static = false
 * goReturnType(StringName) -> StringName
 */
func (cx *Signal) GetName() StringName {
	mb := globalSignalMethodBindings.method_get_name
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[StringName](mb, bx, nil)
	return ret
}

/* Connect : connect
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Signal) Connect(callable Callable, flags int64) int64 {
	mb := globalSignalMethodBindings.method_connect
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&callable))

	args[1] = Int64Encoder.EncodeTypePtr(flags)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Disconnect : disconnect
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Signal) Disconnect(callable Callable) {
	mb := globalSignalMethodBindings.method_disconnect
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&callable))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* IsConnected : is_connected
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Signal) IsConnected(callable Callable) bool {
	mb := globalSignalMethodBindings.method_is_connected
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&callable))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetConnections : get_connections
 * is_vararg = false, is_static = false
 * goReturnType(Array) -> Array
 */
func (cx *Signal) GetConnections() Array {
	mb := globalSignalMethodBindings.method_get_connections
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Array](mb, bx, nil)
	return ret
}

// members
// Equal_Variant operator
func (cx *Signal) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalSignalMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Signal) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalSignalMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *Signal) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalSignalMethodBindings.operator_not, lt, rt)
}

// Equal_Signal operator
func (cx *Signal) Equal_Signal(right Signal) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalSignalMethodBindings.operator_equal_Signal, lt, rt)
}

// Not_equal_Signal operator
func (cx *Signal) Not_equal_Signal(right Signal) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalSignalMethodBindings.operator_not_equal_Signal, lt, rt)
}

// In_Dictionary operator
func (cx *Signal) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalSignalMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Signal) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalSignalMethodBindings.operator_in_Array, lt, rt)
}

var _ GDBuiltInDestroyableClass = &Dictionary{}

/*
 * Dictionary
 * indexingReturnType: Variant
 * isKeyed: true
 * hasDestructor: true
 */
type Dictionary [8]uint8

func (c *Dictionary) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Dictionary) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewDictionary, index: 0
func NewDictionary() Dictionary {
	cx := Dictionary{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalDictionaryMethodBindings.constructor_0, ptr)
	return cx
}

// NewDictionary, index: 1
func NewDictionaryWithDictionary(from Dictionary) Dictionary {
	cx := Dictionary{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Dictionary
	// DictionaryEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalDictionaryMethodBindings.constructor_1, ptr, args[0])
	return cx
}

func (cx *Dictionary) Destroy() {
	md := (GDExtensionPtrDestructor)(globalDictionaryMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewDictionaryWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Dictionary {
	ret := Dictionary{}
	typedSrc := (*Dictionary)(src)

	for i := 0; i < 8; i++ {
		ret[i] = typedSrc[i]
	}

	return (Dictionary)(ret)
}
func copyDictionaryWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Dictionary)(dst)
	typedSrc := (*Dictionary)(src)

	for i := 0; i < 8; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Size : size
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Dictionary) Size() int64 {
	mb := globalDictionaryMethodBindings.method_size
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* IsEmpty : is_empty
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Dictionary) IsEmpty() bool {
	mb := globalDictionaryMethodBindings.method_is_empty
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Clear : clear
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Dictionary) Clear() {
	mb := globalDictionaryMethodBindings.method_clear
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Merge : merge
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Dictionary) Merge(dictionary Dictionary, overwrite bool) {
	mb := globalDictionaryMethodBindings.method_merge
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&dictionary))

	args[1] = BoolEncoder.EncodeTypePtr(overwrite)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Merged : merged
 * is_vararg = false, is_static = false
 * goReturnType(Dictionary) -> Dictionary
 */
func (cx *Dictionary) Merged(dictionary Dictionary, overwrite bool) Dictionary {
	mb := globalDictionaryMethodBindings.method_merged
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&dictionary))

	args[1] = BoolEncoder.EncodeTypePtr(overwrite)

	ret := CallBuiltinMethodPtrRet[Dictionary](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Has : has
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Dictionary) Has(key Variant) bool {
	mb := globalDictionaryMethodBindings.method_has
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&key))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* HasAll : has_all
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Dictionary) HasAll(keys Array) bool {
	mb := globalDictionaryMethodBindings.method_has_all
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&keys))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* FindKey : find_key
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Dictionary) FindKey(value Variant) Variant {
	mb := globalDictionaryMethodBindings.method_find_key
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Erase : erase
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Dictionary) Erase(key Variant) bool {
	mb := globalDictionaryMethodBindings.method_erase
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&key))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Hash : hash
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Dictionary) Hash() int64 {
	mb := globalDictionaryMethodBindings.method_hash
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* Keys : keys
 * is_vararg = false, is_static = false
 * goReturnType(Array) -> Array
 */
func (cx *Dictionary) Keys() Array {
	mb := globalDictionaryMethodBindings.method_keys
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Array](mb, bx, nil)
	return ret
}

/* Values : values
 * is_vararg = false, is_static = false
 * goReturnType(Array) -> Array
 */
func (cx *Dictionary) Values() Array {
	mb := globalDictionaryMethodBindings.method_values
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Array](mb, bx, nil)
	return ret
}

/* Duplicate : duplicate
 * is_vararg = false, is_static = false
 * goReturnType(Dictionary) -> Dictionary
 */
func (cx *Dictionary) Duplicate(deep bool) Dictionary {
	mb := globalDictionaryMethodBindings.method_duplicate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = BoolEncoder.EncodeTypePtr(deep)

	ret := CallBuiltinMethodPtrRet[Dictionary](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Get : get
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Dictionary) Get(key Variant, defaultName Variant) Variant {
	mb := globalDictionaryMethodBindings.method_get
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&key))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&defaultName))

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetOrAdd : get_or_add
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Dictionary) GetOrAdd(key Variant, defaultName Variant) Variant {
	mb := globalDictionaryMethodBindings.method_get_or_add
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&key))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&defaultName))

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* MakeReadOnly : make_read_only
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Dictionary) MakeReadOnly() {
	mb := globalDictionaryMethodBindings.method_make_read_only
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* IsReadOnly : is_read_only
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Dictionary) IsReadOnly() bool {
	mb := globalDictionaryMethodBindings.method_is_read_only
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* RecursiveEqual : recursive_equal
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Dictionary) RecursiveEqual(dictionary Dictionary, recursion_count int64) bool {
	mb := globalDictionaryMethodBindings.method_recursive_equal
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&dictionary))

	args[1] = Int64Encoder.EncodeTypePtr(recursion_count)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *Dictionary) GetKeyed(key string) Variant {
	gdStrKey := NewStringWithUtf8Chars(key)
	vKey := NewVariantString(gdStrKey)
	var ret Variant
	CallFunc_GDExtensionPtrKeyedGetter(
		globalDictionaryMethodBindings.keyed_getter,
		cx.NativeConstPtr(),
		vKey.AsGDExtensionConstTypePtr(),
		ret.AsGDExtensionTypePtr(),
	)
	return ret
}

func (cx *Dictionary) SetKeyed(key string, value Variant) {
	gdStrKey := NewStringWithUtf8Chars(key)
	vKey := NewVariantString(gdStrKey)
	CallFunc_GDExtensionPtrKeyedSetter(
		globalDictionaryMethodBindings.keyed_setter,
		cx.NativePtr(),
		vKey.AsGDExtensionConstTypePtr(),
		value.AsGDExtensionConstTypePtr(),
	)
}
func (cx *Dictionary) GetIndexed(i int64) Variant {
	var ret Variant
	CallFunc_GDExtensionPtrIndexedGetter(
		globalDictionaryMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *Dictionary) SetIndexed(i int64, value Variant) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalDictionaryMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members
// Equal_Variant operator
func (cx *Dictionary) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalDictionaryMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Dictionary) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalDictionaryMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *Dictionary) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalDictionaryMethodBindings.operator_not, lt, rt)
}

// Equal_Dictionary operator
func (cx *Dictionary) Equal_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalDictionaryMethodBindings.operator_equal_Dictionary, lt, rt)
}

// Not_equal_Dictionary operator
func (cx *Dictionary) Not_equal_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalDictionaryMethodBindings.operator_not_equal_Dictionary, lt, rt)
}

// In_Dictionary operator
func (cx *Dictionary) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalDictionaryMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *Dictionary) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalDictionaryMethodBindings.operator_in_Array, lt, rt)
}

var _ GDBuiltInDestroyableClass = &Array{}

/*
 * Array
 * indexingReturnType: Variant
 * isKeyed: false
 * hasDestructor: true
 */
type Array [8]uint8

func (c *Array) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *Array) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewArray, index: 0
func NewArray() Array {
	cx := Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalArrayMethodBindings.constructor_0, ptr)
	return cx
}

// NewArray, index: 1
func NewArrayWithArray(from Array) Array {
	cx := Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Array
	// ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalArrayMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewArray, index: 2
func NewArrayWithArrayInt64StringNameVariant(base Array, typeName int64, class_name StringName, script Variant) Array {
	cx := Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [4]GDExtensionConstTypePtr
	// Array
	// ArrayEncoder
	args[0] = base.NativeConstPtr()
	// int
	args[1] = (GDExtensionConstTypePtr)(Int64Encoder.EncodeTypePtr(typeName))
	// StringName
	// StringNameEncoder
	args[2] = class_name.NativeConstPtr()
	// Variant
	args[3] = (GDExtensionConstTypePtr)(unsafe.Pointer(&script))
	CallBuiltinConstructor(globalArrayMethodBindings.constructor_2, ptr, args[0], args[1], args[2], args[3])
	return cx
}

// NewArray, index: 3
func NewArrayWithPackedByteArray(from PackedByteArray) Array {
	cx := Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedByteArray
	// PackedByteArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalArrayMethodBindings.constructor_3, ptr, args[0])
	return cx
}

// NewArray, index: 4
func NewArrayWithPackedInt32Array(from PackedInt32Array) Array {
	cx := Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedInt32Array
	// PackedInt32ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalArrayMethodBindings.constructor_4, ptr, args[0])
	return cx
}

// NewArray, index: 5
func NewArrayWithPackedInt64Array(from PackedInt64Array) Array {
	cx := Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedInt64Array
	// PackedInt64ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalArrayMethodBindings.constructor_5, ptr, args[0])
	return cx
}

// NewArray, index: 6
func NewArrayWithPackedFloat32Array(from PackedFloat32Array) Array {
	cx := Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedFloat32Array
	// PackedFloat32ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalArrayMethodBindings.constructor_6, ptr, args[0])
	return cx
}

// NewArray, index: 7
func NewArrayWithPackedFloat64Array(from PackedFloat64Array) Array {
	cx := Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedFloat64Array
	// PackedFloat64ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalArrayMethodBindings.constructor_7, ptr, args[0])
	return cx
}

// NewArray, index: 8
func NewArrayWithPackedStringArray(from PackedStringArray) Array {
	cx := Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedStringArray
	// PackedStringArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalArrayMethodBindings.constructor_8, ptr, args[0])
	return cx
}

// NewArray, index: 9
func NewArrayWithPackedVector2Array(from PackedVector2Array) Array {
	cx := Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedVector2Array
	// PackedVector2ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalArrayMethodBindings.constructor_9, ptr, args[0])
	return cx
}

// NewArray, index: 10
func NewArrayWithPackedVector3Array(from PackedVector3Array) Array {
	cx := Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedVector3Array
	// PackedVector3ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalArrayMethodBindings.constructor_10, ptr, args[0])
	return cx
}

// NewArray, index: 11
func NewArrayWithPackedColorArray(from PackedColorArray) Array {
	cx := Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedColorArray
	// PackedColorArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalArrayMethodBindings.constructor_11, ptr, args[0])
	return cx
}

// NewArray, index: 12
func NewArrayWithPackedVector4Array(from PackedVector4Array) Array {
	cx := Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedVector4Array
	// PackedVector4ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalArrayMethodBindings.constructor_12, ptr, args[0])
	return cx
}

func (cx *Array) Destroy() {
	md := (GDExtensionPtrDestructor)(globalArrayMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewArrayWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) Array {
	ret := Array{}
	typedSrc := (*Array)(src)

	for i := 0; i < 8; i++ {
		ret[i] = typedSrc[i]
	}

	return (Array)(ret)
}
func copyArrayWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*Array)(dst)
	typedSrc := (*Array)(src)

	for i := 0; i < 8; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Size : size
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Array) Size() int64 {
	mb := globalArrayMethodBindings.method_size
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* IsEmpty : is_empty
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Array) IsEmpty() bool {
	mb := globalArrayMethodBindings.method_is_empty
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Clear : clear
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Array) Clear() {
	mb := globalArrayMethodBindings.method_clear
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Hash : hash
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Array) Hash() int64 {
	mb := globalArrayMethodBindings.method_hash
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* Assign : assign
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Array) Assign(array Array) {
	mb := globalArrayMethodBindings.method_assign
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&array))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* PushBack : push_back
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Array) PushBack(value Variant) {
	mb := globalArrayMethodBindings.method_push_back
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* PushFront : push_front
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Array) PushFront(value Variant) {
	mb := globalArrayMethodBindings.method_push_front
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Append : append
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Array) Append(value Variant) {
	mb := globalArrayMethodBindings.method_append
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* AppendArray : append_array
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Array) AppendArray(array Array) {
	mb := globalArrayMethodBindings.method_append_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&array))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Resize : resize
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Array) Resize(size int64) int64 {
	mb := globalArrayMethodBindings.method_resize
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(size)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Insert : insert
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Array) Insert(position int64, value Variant) int64 {
	mb := globalArrayMethodBindings.method_insert
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(position)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* RemoveAt : remove_at
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Array) RemoveAt(position int64) {
	mb := globalArrayMethodBindings.method_remove_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(position)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Fill : fill
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Array) Fill(value Variant) {
	mb := globalArrayMethodBindings.method_fill
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Erase : erase
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Array) Erase(value Variant) {
	mb := globalArrayMethodBindings.method_erase
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Front : front
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Array) Front() Variant {
	mb := globalArrayMethodBindings.method_front
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, nil)
	return ret
}

/* Back : back
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Array) Back() Variant {
	mb := globalArrayMethodBindings.method_back
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, nil)
	return ret
}

/* PickRandom : pick_random
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Array) PickRandom() Variant {
	mb := globalArrayMethodBindings.method_pick_random
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, nil)
	return ret
}

/* Find : find
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Array) Find(what Variant, from int64) int64 {
	mb := globalArrayMethodBindings.method_find
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rfind : rfind
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Array) Rfind(what Variant, from int64) int64 {
	mb := globalArrayMethodBindings.method_rfind
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&what))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Count : count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Array) Count(value Variant) int64 {
	mb := globalArrayMethodBindings.method_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Has : has
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Array) Has(value Variant) bool {
	mb := globalArrayMethodBindings.method_has
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* PopBack : pop_back
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Array) PopBack() Variant {
	mb := globalArrayMethodBindings.method_pop_back
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, nil)
	return ret
}

/* PopFront : pop_front
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Array) PopFront() Variant {
	mb := globalArrayMethodBindings.method_pop_front
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, nil)
	return ret
}

/* PopAt : pop_at
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Array) PopAt(position int64) Variant {
	mb := globalArrayMethodBindings.method_pop_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(position)

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Sort : sort
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Array) Sort() {
	mb := globalArrayMethodBindings.method_sort
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* SortCustom : sort_custom
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Array) SortCustom(callbackFunc Callable) {
	mb := globalArrayMethodBindings.method_sort_custom
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&callbackFunc))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Shuffle : shuffle
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Array) Shuffle() {
	mb := globalArrayMethodBindings.method_shuffle
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Bsearch : bsearch
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Array) Bsearch(value Variant, before bool) int64 {
	mb := globalArrayMethodBindings.method_bsearch
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = BoolEncoder.EncodeTypePtr(before)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* BsearchCustom : bsearch_custom
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Array) BsearchCustom(value Variant, callbackFunc Callable, before bool) int64 {
	mb := globalArrayMethodBindings.method_bsearch_custom
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 3
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&callbackFunc))

	args[2] = BoolEncoder.EncodeTypePtr(before)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Reverse : reverse
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Array) Reverse() {
	mb := globalArrayMethodBindings.method_reverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Duplicate : duplicate
 * is_vararg = false, is_static = false
 * goReturnType(Array) -> Array
 */
func (cx *Array) Duplicate(deep bool) Array {
	mb := globalArrayMethodBindings.method_duplicate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = BoolEncoder.EncodeTypePtr(deep)

	ret := CallBuiltinMethodPtrRet[Array](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Slice : slice
 * is_vararg = false, is_static = false
 * goReturnType(Array) -> Array
 */
func (cx *Array) Slice(begin int64, end int64, step int64, deep bool) Array {
	mb := globalArrayMethodBindings.method_slice
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 4
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(begin)

	args[1] = Int64Encoder.EncodeTypePtr(end)

	args[2] = Int64Encoder.EncodeTypePtr(step)

	args[3] = BoolEncoder.EncodeTypePtr(deep)

	ret := CallBuiltinMethodPtrRet[Array](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Filter : filter
 * is_vararg = false, is_static = false
 * goReturnType(Array) -> Array
 */
func (cx *Array) Filter(method Callable) Array {
	mb := globalArrayMethodBindings.method_filter
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&method))

	ret := CallBuiltinMethodPtrRet[Array](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Map : map
 * is_vararg = false, is_static = false
 * goReturnType(Array) -> Array
 */
func (cx *Array) Map(method Callable) Array {
	mb := globalArrayMethodBindings.method_map
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&method))

	ret := CallBuiltinMethodPtrRet[Array](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Reduce : reduce
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Array) Reduce(method Callable, accum Variant) Variant {
	mb := globalArrayMethodBindings.method_reduce
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&method))

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&accum))

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Any : any
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Array) Any(method Callable) bool {
	mb := globalArrayMethodBindings.method_any
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&method))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* All : all
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Array) All(method Callable) bool {
	mb := globalArrayMethodBindings.method_all
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&method))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Max : max
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Array) Max() Variant {
	mb := globalArrayMethodBindings.method_max
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, nil)
	return ret
}

/* Min : min
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Array) Min() Variant {
	mb := globalArrayMethodBindings.method_min
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, nil)
	return ret
}

/* IsTyped : is_typed
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Array) IsTyped() bool {
	mb := globalArrayMethodBindings.method_is_typed
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* IsSameTyped : is_same_typed
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Array) IsSameTyped(array Array) bool {
	mb := globalArrayMethodBindings.method_is_same_typed
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&array))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetTypedBuiltin : get_typed_builtin
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *Array) GetTypedBuiltin() int64 {
	mb := globalArrayMethodBindings.method_get_typed_builtin
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* GetTypedClassName : get_typed_class_name
 * is_vararg = false, is_static = false
 * goReturnType(StringName) -> StringName
 */
func (cx *Array) GetTypedClassName() StringName {
	mb := globalArrayMethodBindings.method_get_typed_class_name
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[StringName](mb, bx, nil)
	return ret
}

/* GetTypedScript : get_typed_script
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *Array) GetTypedScript() Variant {
	mb := globalArrayMethodBindings.method_get_typed_script
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, nil)
	return ret
}

/* MakeReadOnly : make_read_only
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *Array) MakeReadOnly() {
	mb := globalArrayMethodBindings.method_make_read_only
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* IsReadOnly : is_read_only
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *Array) IsReadOnly() bool {
	mb := globalArrayMethodBindings.method_is_read_only
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

func (cx *Array) GetIndexed(i int64) Variant {
	var ret Variant
	CallFunc_GDExtensionPtrIndexedGetter(
		globalArrayMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *Array) SetIndexed(i int64, value Variant) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalArrayMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members
// Equal_Variant operator
func (cx *Array) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalArrayMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *Array) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalArrayMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *Array) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalArrayMethodBindings.operator_not, lt, rt)
}

// In_Dictionary operator
func (cx *Array) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalArrayMethodBindings.operator_in_Dictionary, lt, rt)
}

// Equal_Array operator
func (cx *Array) Equal_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalArrayMethodBindings.operator_equal_Array, lt, rt)
}

// Not_equal_Array operator
func (cx *Array) Not_equal_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalArrayMethodBindings.operator_not_equal_Array, lt, rt)
}

// Less_Array operator
func (cx *Array) Less_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalArrayMethodBindings.operator_less_Array, lt, rt)
}

// Less_equal_Array operator
func (cx *Array) Less_equal_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalArrayMethodBindings.operator_less_equal_Array, lt, rt)
}

// Greater_Array operator
func (cx *Array) Greater_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalArrayMethodBindings.operator_greater_Array, lt, rt)
}

// Greater_equal_Array operator
func (cx *Array) Greater_equal_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalArrayMethodBindings.operator_greater_equal_Array, lt, rt)
}

// Add_Array operator
func (cx *Array) Add_Array(right Array) Array {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[Array](globalArrayMethodBindings.operator_add_Array, lt, rt)
}

// In_Array operator
func (cx *Array) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalArrayMethodBindings.operator_in_Array, lt, rt)
}

var _ GDBuiltInDestroyableClass = &PackedByteArray{}

/*
 * PackedByteArray
 * indexingReturnType: int
 * isKeyed: false
 * hasDestructor: true
 */
type PackedByteArray [16]uint8

func (c *PackedByteArray) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *PackedByteArray) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewPackedByteArray, index: 0
func NewPackedByteArray() PackedByteArray {
	cx := PackedByteArray{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalPackedByteArrayMethodBindings.constructor_0, ptr)
	return cx
}

// NewPackedByteArray, index: 1
func NewPackedByteArrayWithPackedByteArray(from PackedByteArray) PackedByteArray {
	cx := PackedByteArray{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedByteArray
	// PackedByteArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedByteArrayMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewPackedByteArray, index: 2
func NewPackedByteArrayWithArray(from Array) PackedByteArray {
	cx := PackedByteArray{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Array
	// ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedByteArrayMethodBindings.constructor_2, ptr, args[0])
	return cx
}

func (cx *PackedByteArray) Destroy() {
	md := (GDExtensionPtrDestructor)(globalPackedByteArrayMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewPackedByteArrayWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) PackedByteArray {
	ret := PackedByteArray{}
	typedSrc := (*PackedByteArray)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (PackedByteArray)(ret)
}
func copyPackedByteArrayWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*PackedByteArray)(dst)
	typedSrc := (*PackedByteArray)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Size : size
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) Size() int64 {
	mb := globalPackedByteArrayMethodBindings.method_size
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* IsEmpty : is_empty
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedByteArray) IsEmpty() bool {
	mb := globalPackedByteArrayMethodBindings.method_is_empty
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Set : set
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) Set(index int64, value int64) {
	mb := globalPackedByteArrayMethodBindings.method_set
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	args[1] = Int64Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* PushBack : push_back
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedByteArray) PushBack(value int64) bool {
	mb := globalPackedByteArrayMethodBindings.method_push_back
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Append : append
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedByteArray) Append(value int64) bool {
	mb := globalPackedByteArrayMethodBindings.method_append
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* AppendArray : append_array
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) AppendArray(array PackedByteArray) {
	mb := globalPackedByteArrayMethodBindings.method_append_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&array))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* RemoveAt : remove_at
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) RemoveAt(index int64) {
	mb := globalPackedByteArrayMethodBindings.method_remove_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Insert : insert
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) Insert(at_index int64, value int64) int64 {
	mb := globalPackedByteArrayMethodBindings.method_insert
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(at_index)

	args[1] = Int64Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Fill : fill
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) Fill(value int64) {
	mb := globalPackedByteArrayMethodBindings.method_fill
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Resize : resize
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) Resize(new_size int64) int64 {
	mb := globalPackedByteArrayMethodBindings.method_resize
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(new_size)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clear : clear
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) Clear() {
	mb := globalPackedByteArrayMethodBindings.method_clear
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Has : has
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedByteArray) Has(value int64) bool {
	mb := globalPackedByteArrayMethodBindings.method_has
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Reverse : reverse
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) Reverse() {
	mb := globalPackedByteArrayMethodBindings.method_reverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Slice : slice
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *PackedByteArray) Slice(begin int64, end int64) PackedByteArray {
	mb := globalPackedByteArrayMethodBindings.method_slice
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(begin)

	args[1] = Int64Encoder.EncodeTypePtr(end)

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Sort : sort
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) Sort() {
	mb := globalPackedByteArrayMethodBindings.method_sort
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Bsearch : bsearch
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) Bsearch(value int64, before bool) int64 {
	mb := globalPackedByteArrayMethodBindings.method_bsearch
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	args[1] = BoolEncoder.EncodeTypePtr(before)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Duplicate : duplicate
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *PackedByteArray) Duplicate() PackedByteArray {
	mb := globalPackedByteArrayMethodBindings.method_duplicate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* Find : find
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) Find(value int64, from int64) int64 {
	mb := globalPackedByteArrayMethodBindings.method_find
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rfind : rfind
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) Rfind(value int64, from int64) int64 {
	mb := globalPackedByteArrayMethodBindings.method_rfind
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Count : count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) Count(value int64) int64 {
	mb := globalPackedByteArrayMethodBindings.method_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* GetStringFromAscii : get_string_from_ascii
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *PackedByteArray) GetStringFromAscii() String {
	mb := globalPackedByteArrayMethodBindings.method_get_string_from_ascii
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* GetStringFromUtf8 : get_string_from_utf8
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *PackedByteArray) GetStringFromUtf8() String {
	mb := globalPackedByteArrayMethodBindings.method_get_string_from_utf8
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* GetStringFromUtf16 : get_string_from_utf16
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *PackedByteArray) GetStringFromUtf16() String {
	mb := globalPackedByteArrayMethodBindings.method_get_string_from_utf16
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* GetStringFromUtf32 : get_string_from_utf32
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *PackedByteArray) GetStringFromUtf32() String {
	mb := globalPackedByteArrayMethodBindings.method_get_string_from_utf32
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* GetStringFromWchar : get_string_from_wchar
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *PackedByteArray) GetStringFromWchar() String {
	mb := globalPackedByteArrayMethodBindings.method_get_string_from_wchar
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* HexEncode : hex_encode
 * is_vararg = false, is_static = false
 * goReturnType(String) -> String
 */
func (cx *PackedByteArray) HexEncode() String {
	mb := globalPackedByteArrayMethodBindings.method_hex_encode
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[String](mb, bx, nil)
	return ret
}

/* Compress : compress
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *PackedByteArray) Compress(compression_mode int64) PackedByteArray {
	mb := globalPackedByteArrayMethodBindings.method_compress
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(compression_mode)

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Decompress : decompress
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *PackedByteArray) Decompress(buffer_size int64, compression_mode int64) PackedByteArray {
	mb := globalPackedByteArrayMethodBindings.method_decompress
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(buffer_size)

	args[1] = Int64Encoder.EncodeTypePtr(compression_mode)

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DecompressDynamic : decompress_dynamic
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *PackedByteArray) DecompressDynamic(max_output_size int64, compression_mode int64) PackedByteArray {
	mb := globalPackedByteArrayMethodBindings.method_decompress_dynamic
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(max_output_size)

	args[1] = Int64Encoder.EncodeTypePtr(compression_mode)

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DecodeU8 : decode_u8
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) DecodeU8(byte_offset int64) int64 {
	mb := globalPackedByteArrayMethodBindings.method_decode_u8
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DecodeS8 : decode_s8
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) DecodeS8(byte_offset int64) int64 {
	mb := globalPackedByteArrayMethodBindings.method_decode_s8
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DecodeU16 : decode_u16
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) DecodeU16(byte_offset int64) int64 {
	mb := globalPackedByteArrayMethodBindings.method_decode_u16
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DecodeS16 : decode_s16
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) DecodeS16(byte_offset int64) int64 {
	mb := globalPackedByteArrayMethodBindings.method_decode_s16
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DecodeU32 : decode_u32
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) DecodeU32(byte_offset int64) int64 {
	mb := globalPackedByteArrayMethodBindings.method_decode_u32
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DecodeS32 : decode_s32
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) DecodeS32(byte_offset int64) int64 {
	mb := globalPackedByteArrayMethodBindings.method_decode_s32
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DecodeU64 : decode_u64
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) DecodeU64(byte_offset int64) int64 {
	mb := globalPackedByteArrayMethodBindings.method_decode_u64
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DecodeS64 : decode_s64
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) DecodeS64(byte_offset int64) int64 {
	mb := globalPackedByteArrayMethodBindings.method_decode_s64
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DecodeHalf : decode_half
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *PackedByteArray) DecodeHalf(byte_offset int64) float32 {
	mb := globalPackedByteArrayMethodBindings.method_decode_half
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DecodeFloat : decode_float
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *PackedByteArray) DecodeFloat(byte_offset int64) float32 {
	mb := globalPackedByteArrayMethodBindings.method_decode_float
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DecodeDouble : decode_double
 * is_vararg = false, is_static = false
 * goReturnType(float) -> float32
 */
func (cx *PackedByteArray) DecodeDouble(byte_offset int64) float32 {
	mb := globalPackedByteArrayMethodBindings.method_decode_double
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	ret := CallBuiltinMethodPtrRet[float32](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* HasEncodedVar : has_encoded_var
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedByteArray) HasEncodedVar(byte_offset int64, allow_objects bool) bool {
	mb := globalPackedByteArrayMethodBindings.method_has_encoded_var
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	args[1] = BoolEncoder.EncodeTypePtr(allow_objects)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DecodeVar : decode_var
 * is_vararg = false, is_static = false
 * goReturnType(Variant) -> Variant
 */
func (cx *PackedByteArray) DecodeVar(byte_offset int64, allow_objects bool) Variant {
	mb := globalPackedByteArrayMethodBindings.method_decode_var
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	args[1] = BoolEncoder.EncodeTypePtr(allow_objects)

	ret := CallBuiltinMethodPtrRet[Variant](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* DecodeVarSize : decode_var_size
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) DecodeVarSize(byte_offset int64, allow_objects bool) int64 {
	mb := globalPackedByteArrayMethodBindings.method_decode_var_size
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	args[1] = BoolEncoder.EncodeTypePtr(allow_objects)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* ToInt32Array : to_int32_array
 * is_vararg = false, is_static = false
 * goReturnType(PackedInt32Array) -> PackedInt32Array
 */
func (cx *PackedByteArray) ToInt32Array() PackedInt32Array {
	mb := globalPackedByteArrayMethodBindings.method_to_int32_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedInt32Array](mb, bx, nil)
	return ret
}

/* ToInt64Array : to_int64_array
 * is_vararg = false, is_static = false
 * goReturnType(PackedInt64Array) -> PackedInt64Array
 */
func (cx *PackedByteArray) ToInt64Array() PackedInt64Array {
	mb := globalPackedByteArrayMethodBindings.method_to_int64_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedInt64Array](mb, bx, nil)
	return ret
}

/* ToFloat32Array : to_float32_array
 * is_vararg = false, is_static = false
 * goReturnType(PackedFloat32Array) -> PackedFloat32Array
 */
func (cx *PackedByteArray) ToFloat32Array() PackedFloat32Array {
	mb := globalPackedByteArrayMethodBindings.method_to_float32_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedFloat32Array](mb, bx, nil)
	return ret
}

/* ToFloat64Array : to_float64_array
 * is_vararg = false, is_static = false
 * goReturnType(PackedFloat64Array) -> PackedFloat64Array
 */
func (cx *PackedByteArray) ToFloat64Array() PackedFloat64Array {
	mb := globalPackedByteArrayMethodBindings.method_to_float64_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedFloat64Array](mb, bx, nil)
	return ret
}

/* EncodeU8 : encode_u8
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) EncodeU8(byte_offset int64, value int64) {
	mb := globalPackedByteArrayMethodBindings.method_encode_u8
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	args[1] = Int64Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* EncodeS8 : encode_s8
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) EncodeS8(byte_offset int64, value int64) {
	mb := globalPackedByteArrayMethodBindings.method_encode_s8
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	args[1] = Int64Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* EncodeU16 : encode_u16
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) EncodeU16(byte_offset int64, value int64) {
	mb := globalPackedByteArrayMethodBindings.method_encode_u16
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	args[1] = Int64Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* EncodeS16 : encode_s16
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) EncodeS16(byte_offset int64, value int64) {
	mb := globalPackedByteArrayMethodBindings.method_encode_s16
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	args[1] = Int64Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* EncodeU32 : encode_u32
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) EncodeU32(byte_offset int64, value int64) {
	mb := globalPackedByteArrayMethodBindings.method_encode_u32
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	args[1] = Int64Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* EncodeS32 : encode_s32
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) EncodeS32(byte_offset int64, value int64) {
	mb := globalPackedByteArrayMethodBindings.method_encode_s32
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	args[1] = Int64Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* EncodeU64 : encode_u64
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) EncodeU64(byte_offset int64, value int64) {
	mb := globalPackedByteArrayMethodBindings.method_encode_u64
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	args[1] = Int64Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* EncodeS64 : encode_s64
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) EncodeS64(byte_offset int64, value int64) {
	mb := globalPackedByteArrayMethodBindings.method_encode_s64
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	args[1] = Int64Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* EncodeHalf : encode_half
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) EncodeHalf(byte_offset int64, value float32) {
	mb := globalPackedByteArrayMethodBindings.method_encode_half
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	args[1] = Float32Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* EncodeFloat : encode_float
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) EncodeFloat(byte_offset int64, value float32) {
	mb := globalPackedByteArrayMethodBindings.method_encode_float
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	args[1] = Float32Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* EncodeDouble : encode_double
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedByteArray) EncodeDouble(byte_offset int64, value float32) {
	mb := globalPackedByteArrayMethodBindings.method_encode_double
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	args[1] = Float32Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* EncodeVar : encode_var
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedByteArray) EncodeVar(byte_offset int64, value Variant, allow_objects bool) int64 {
	mb := globalPackedByteArrayMethodBindings.method_encode_var
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 3
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(byte_offset)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[2] = BoolEncoder.EncodeTypePtr(allow_objects)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *PackedByteArray) GetIndexed(i int64) int64 {
	var ret int64
	CallFunc_GDExtensionPtrIndexedGetter(
		globalPackedByteArrayMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *PackedByteArray) SetIndexed(i int64, value int64) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalPackedByteArrayMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members
// Equal_Variant operator
func (cx *PackedByteArray) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedByteArrayMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *PackedByteArray) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedByteArrayMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *PackedByteArray) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalPackedByteArrayMethodBindings.operator_not, lt, rt)
}

// In_Dictionary operator
func (cx *PackedByteArray) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedByteArrayMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *PackedByteArray) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedByteArrayMethodBindings.operator_in_Array, lt, rt)
}

// Equal_PackedByteArray operator
func (cx *PackedByteArray) Equal_PackedByteArray(right PackedByteArray) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedByteArrayMethodBindings.operator_equal_PackedByteArray, lt, rt)
}

// Not_equal_PackedByteArray operator
func (cx *PackedByteArray) Not_equal_PackedByteArray(right PackedByteArray) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedByteArrayMethodBindings.operator_not_equal_PackedByteArray, lt, rt)
}

// Add_PackedByteArray operator
func (cx *PackedByteArray) Add_PackedByteArray(right PackedByteArray) PackedByteArray {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[PackedByteArray](globalPackedByteArrayMethodBindings.operator_add_PackedByteArray, lt, rt)
}

var _ GDBuiltInDestroyableClass = &PackedInt32Array{}

/*
 * PackedInt32Array
 * indexingReturnType: int
 * isKeyed: false
 * hasDestructor: true
 */
type PackedInt32Array [16]uint8

func (c *PackedInt32Array) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *PackedInt32Array) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewPackedInt32Array, index: 0
func NewPackedInt32Array() PackedInt32Array {
	cx := PackedInt32Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalPackedInt32ArrayMethodBindings.constructor_0, ptr)
	return cx
}

// NewPackedInt32Array, index: 1
func NewPackedInt32ArrayWithPackedInt32Array(from PackedInt32Array) PackedInt32Array {
	cx := PackedInt32Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedInt32Array
	// PackedInt32ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedInt32ArrayMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewPackedInt32Array, index: 2
func NewPackedInt32ArrayWithArray(from Array) PackedInt32Array {
	cx := PackedInt32Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Array
	// ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedInt32ArrayMethodBindings.constructor_2, ptr, args[0])
	return cx
}

func (cx *PackedInt32Array) Destroy() {
	md := (GDExtensionPtrDestructor)(globalPackedInt32ArrayMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewPackedInt32ArrayWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) PackedInt32Array {
	ret := PackedInt32Array{}
	typedSrc := (*PackedInt32Array)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (PackedInt32Array)(ret)
}
func copyPackedInt32ArrayWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*PackedInt32Array)(dst)
	typedSrc := (*PackedInt32Array)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Size : size
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedInt32Array) Size() int64 {
	mb := globalPackedInt32ArrayMethodBindings.method_size
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* IsEmpty : is_empty
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedInt32Array) IsEmpty() bool {
	mb := globalPackedInt32ArrayMethodBindings.method_is_empty
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Set : set
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedInt32Array) Set(index int64, value int64) {
	mb := globalPackedInt32ArrayMethodBindings.method_set
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	args[1] = Int64Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* PushBack : push_back
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedInt32Array) PushBack(value int64) bool {
	mb := globalPackedInt32ArrayMethodBindings.method_push_back
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Append : append
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedInt32Array) Append(value int64) bool {
	mb := globalPackedInt32ArrayMethodBindings.method_append
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* AppendArray : append_array
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedInt32Array) AppendArray(array PackedInt32Array) {
	mb := globalPackedInt32ArrayMethodBindings.method_append_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&array))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* RemoveAt : remove_at
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedInt32Array) RemoveAt(index int64) {
	mb := globalPackedInt32ArrayMethodBindings.method_remove_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Insert : insert
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedInt32Array) Insert(at_index int64, value int64) int64 {
	mb := globalPackedInt32ArrayMethodBindings.method_insert
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(at_index)

	args[1] = Int64Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Fill : fill
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedInt32Array) Fill(value int64) {
	mb := globalPackedInt32ArrayMethodBindings.method_fill
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Resize : resize
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedInt32Array) Resize(new_size int64) int64 {
	mb := globalPackedInt32ArrayMethodBindings.method_resize
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(new_size)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clear : clear
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedInt32Array) Clear() {
	mb := globalPackedInt32ArrayMethodBindings.method_clear
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Has : has
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedInt32Array) Has(value int64) bool {
	mb := globalPackedInt32ArrayMethodBindings.method_has
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Reverse : reverse
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedInt32Array) Reverse() {
	mb := globalPackedInt32ArrayMethodBindings.method_reverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Slice : slice
 * is_vararg = false, is_static = false
 * goReturnType(PackedInt32Array) -> PackedInt32Array
 */
func (cx *PackedInt32Array) Slice(begin int64, end int64) PackedInt32Array {
	mb := globalPackedInt32ArrayMethodBindings.method_slice
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(begin)

	args[1] = Int64Encoder.EncodeTypePtr(end)

	ret := CallBuiltinMethodPtrRet[PackedInt32Array](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* ToByteArray : to_byte_array
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *PackedInt32Array) ToByteArray() PackedByteArray {
	mb := globalPackedInt32ArrayMethodBindings.method_to_byte_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* Sort : sort
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedInt32Array) Sort() {
	mb := globalPackedInt32ArrayMethodBindings.method_sort
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Bsearch : bsearch
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedInt32Array) Bsearch(value int64, before bool) int64 {
	mb := globalPackedInt32ArrayMethodBindings.method_bsearch
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	args[1] = BoolEncoder.EncodeTypePtr(before)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Duplicate : duplicate
 * is_vararg = false, is_static = false
 * goReturnType(PackedInt32Array) -> PackedInt32Array
 */
func (cx *PackedInt32Array) Duplicate() PackedInt32Array {
	mb := globalPackedInt32ArrayMethodBindings.method_duplicate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedInt32Array](mb, bx, nil)
	return ret
}

/* Find : find
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedInt32Array) Find(value int64, from int64) int64 {
	mb := globalPackedInt32ArrayMethodBindings.method_find
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rfind : rfind
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedInt32Array) Rfind(value int64, from int64) int64 {
	mb := globalPackedInt32ArrayMethodBindings.method_rfind
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Count : count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedInt32Array) Count(value int64) int64 {
	mb := globalPackedInt32ArrayMethodBindings.method_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *PackedInt32Array) GetIndexed(i int64) int64 {
	var ret int64
	CallFunc_GDExtensionPtrIndexedGetter(
		globalPackedInt32ArrayMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *PackedInt32Array) SetIndexed(i int64, value int64) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalPackedInt32ArrayMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members
// Equal_Variant operator
func (cx *PackedInt32Array) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedInt32ArrayMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *PackedInt32Array) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedInt32ArrayMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *PackedInt32Array) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalPackedInt32ArrayMethodBindings.operator_not, lt, rt)
}

// In_Dictionary operator
func (cx *PackedInt32Array) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedInt32ArrayMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *PackedInt32Array) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedInt32ArrayMethodBindings.operator_in_Array, lt, rt)
}

// Equal_PackedInt32Array operator
func (cx *PackedInt32Array) Equal_PackedInt32Array(right PackedInt32Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedInt32ArrayMethodBindings.operator_equal_PackedInt32Array, lt, rt)
}

// Not_equal_PackedInt32Array operator
func (cx *PackedInt32Array) Not_equal_PackedInt32Array(right PackedInt32Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedInt32ArrayMethodBindings.operator_not_equal_PackedInt32Array, lt, rt)
}

// Add_PackedInt32Array operator
func (cx *PackedInt32Array) Add_PackedInt32Array(right PackedInt32Array) PackedInt32Array {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[PackedInt32Array](globalPackedInt32ArrayMethodBindings.operator_add_PackedInt32Array, lt, rt)
}

var _ GDBuiltInDestroyableClass = &PackedInt64Array{}

/*
 * PackedInt64Array
 * indexingReturnType: int
 * isKeyed: false
 * hasDestructor: true
 */
type PackedInt64Array [16]uint8

func (c *PackedInt64Array) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *PackedInt64Array) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewPackedInt64Array, index: 0
func NewPackedInt64Array() PackedInt64Array {
	cx := PackedInt64Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalPackedInt64ArrayMethodBindings.constructor_0, ptr)
	return cx
}

// NewPackedInt64Array, index: 1
func NewPackedInt64ArrayWithPackedInt64Array(from PackedInt64Array) PackedInt64Array {
	cx := PackedInt64Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedInt64Array
	// PackedInt64ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedInt64ArrayMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewPackedInt64Array, index: 2
func NewPackedInt64ArrayWithArray(from Array) PackedInt64Array {
	cx := PackedInt64Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Array
	// ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedInt64ArrayMethodBindings.constructor_2, ptr, args[0])
	return cx
}

func (cx *PackedInt64Array) Destroy() {
	md := (GDExtensionPtrDestructor)(globalPackedInt64ArrayMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewPackedInt64ArrayWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) PackedInt64Array {
	ret := PackedInt64Array{}
	typedSrc := (*PackedInt64Array)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (PackedInt64Array)(ret)
}
func copyPackedInt64ArrayWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*PackedInt64Array)(dst)
	typedSrc := (*PackedInt64Array)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Size : size
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedInt64Array) Size() int64 {
	mb := globalPackedInt64ArrayMethodBindings.method_size
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* IsEmpty : is_empty
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedInt64Array) IsEmpty() bool {
	mb := globalPackedInt64ArrayMethodBindings.method_is_empty
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Set : set
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedInt64Array) Set(index int64, value int64) {
	mb := globalPackedInt64ArrayMethodBindings.method_set
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	args[1] = Int64Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* PushBack : push_back
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedInt64Array) PushBack(value int64) bool {
	mb := globalPackedInt64ArrayMethodBindings.method_push_back
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Append : append
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedInt64Array) Append(value int64) bool {
	mb := globalPackedInt64ArrayMethodBindings.method_append
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* AppendArray : append_array
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedInt64Array) AppendArray(array PackedInt64Array) {
	mb := globalPackedInt64ArrayMethodBindings.method_append_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&array))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* RemoveAt : remove_at
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedInt64Array) RemoveAt(index int64) {
	mb := globalPackedInt64ArrayMethodBindings.method_remove_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Insert : insert
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedInt64Array) Insert(at_index int64, value int64) int64 {
	mb := globalPackedInt64ArrayMethodBindings.method_insert
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(at_index)

	args[1] = Int64Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Fill : fill
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedInt64Array) Fill(value int64) {
	mb := globalPackedInt64ArrayMethodBindings.method_fill
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Resize : resize
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedInt64Array) Resize(new_size int64) int64 {
	mb := globalPackedInt64ArrayMethodBindings.method_resize
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(new_size)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clear : clear
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedInt64Array) Clear() {
	mb := globalPackedInt64ArrayMethodBindings.method_clear
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Has : has
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedInt64Array) Has(value int64) bool {
	mb := globalPackedInt64ArrayMethodBindings.method_has
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Reverse : reverse
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedInt64Array) Reverse() {
	mb := globalPackedInt64ArrayMethodBindings.method_reverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Slice : slice
 * is_vararg = false, is_static = false
 * goReturnType(PackedInt64Array) -> PackedInt64Array
 */
func (cx *PackedInt64Array) Slice(begin int64, end int64) PackedInt64Array {
	mb := globalPackedInt64ArrayMethodBindings.method_slice
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(begin)

	args[1] = Int64Encoder.EncodeTypePtr(end)

	ret := CallBuiltinMethodPtrRet[PackedInt64Array](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* ToByteArray : to_byte_array
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *PackedInt64Array) ToByteArray() PackedByteArray {
	mb := globalPackedInt64ArrayMethodBindings.method_to_byte_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* Sort : sort
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedInt64Array) Sort() {
	mb := globalPackedInt64ArrayMethodBindings.method_sort
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Bsearch : bsearch
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedInt64Array) Bsearch(value int64, before bool) int64 {
	mb := globalPackedInt64ArrayMethodBindings.method_bsearch
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	args[1] = BoolEncoder.EncodeTypePtr(before)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Duplicate : duplicate
 * is_vararg = false, is_static = false
 * goReturnType(PackedInt64Array) -> PackedInt64Array
 */
func (cx *PackedInt64Array) Duplicate() PackedInt64Array {
	mb := globalPackedInt64ArrayMethodBindings.method_duplicate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedInt64Array](mb, bx, nil)
	return ret
}

/* Find : find
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedInt64Array) Find(value int64, from int64) int64 {
	mb := globalPackedInt64ArrayMethodBindings.method_find
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rfind : rfind
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedInt64Array) Rfind(value int64, from int64) int64 {
	mb := globalPackedInt64ArrayMethodBindings.method_rfind
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Count : count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedInt64Array) Count(value int64) int64 {
	mb := globalPackedInt64ArrayMethodBindings.method_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *PackedInt64Array) GetIndexed(i int64) int64 {
	var ret int64
	CallFunc_GDExtensionPtrIndexedGetter(
		globalPackedInt64ArrayMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *PackedInt64Array) SetIndexed(i int64, value int64) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalPackedInt64ArrayMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members
// Equal_Variant operator
func (cx *PackedInt64Array) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedInt64ArrayMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *PackedInt64Array) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedInt64ArrayMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *PackedInt64Array) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalPackedInt64ArrayMethodBindings.operator_not, lt, rt)
}

// In_Dictionary operator
func (cx *PackedInt64Array) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedInt64ArrayMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *PackedInt64Array) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedInt64ArrayMethodBindings.operator_in_Array, lt, rt)
}

// Equal_PackedInt64Array operator
func (cx *PackedInt64Array) Equal_PackedInt64Array(right PackedInt64Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedInt64ArrayMethodBindings.operator_equal_PackedInt64Array, lt, rt)
}

// Not_equal_PackedInt64Array operator
func (cx *PackedInt64Array) Not_equal_PackedInt64Array(right PackedInt64Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedInt64ArrayMethodBindings.operator_not_equal_PackedInt64Array, lt, rt)
}

// Add_PackedInt64Array operator
func (cx *PackedInt64Array) Add_PackedInt64Array(right PackedInt64Array) PackedInt64Array {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[PackedInt64Array](globalPackedInt64ArrayMethodBindings.operator_add_PackedInt64Array, lt, rt)
}

var _ GDBuiltInDestroyableClass = &PackedFloat32Array{}

/*
 * PackedFloat32Array
 * indexingReturnType: float
 * isKeyed: false
 * hasDestructor: true
 */
type PackedFloat32Array [16]uint8

func (c *PackedFloat32Array) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *PackedFloat32Array) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewPackedFloat32Array, index: 0
func NewPackedFloat32Array() PackedFloat32Array {
	cx := PackedFloat32Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalPackedFloat32ArrayMethodBindings.constructor_0, ptr)
	return cx
}

// NewPackedFloat32Array, index: 1
func NewPackedFloat32ArrayWithPackedFloat32Array(from PackedFloat32Array) PackedFloat32Array {
	cx := PackedFloat32Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedFloat32Array
	// PackedFloat32ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedFloat32ArrayMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewPackedFloat32Array, index: 2
func NewPackedFloat32ArrayWithArray(from Array) PackedFloat32Array {
	cx := PackedFloat32Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Array
	// ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedFloat32ArrayMethodBindings.constructor_2, ptr, args[0])
	return cx
}

func (cx *PackedFloat32Array) Destroy() {
	md := (GDExtensionPtrDestructor)(globalPackedFloat32ArrayMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewPackedFloat32ArrayWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) PackedFloat32Array {
	ret := PackedFloat32Array{}
	typedSrc := (*PackedFloat32Array)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (PackedFloat32Array)(ret)
}
func copyPackedFloat32ArrayWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*PackedFloat32Array)(dst)
	typedSrc := (*PackedFloat32Array)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Size : size
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedFloat32Array) Size() int64 {
	mb := globalPackedFloat32ArrayMethodBindings.method_size
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* IsEmpty : is_empty
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedFloat32Array) IsEmpty() bool {
	mb := globalPackedFloat32ArrayMethodBindings.method_is_empty
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Set : set
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedFloat32Array) Set(index int64, value float32) {
	mb := globalPackedFloat32ArrayMethodBindings.method_set
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	args[1] = Float32Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* PushBack : push_back
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedFloat32Array) PushBack(value float32) bool {
	mb := globalPackedFloat32ArrayMethodBindings.method_push_back
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Append : append
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedFloat32Array) Append(value float32) bool {
	mb := globalPackedFloat32ArrayMethodBindings.method_append
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* AppendArray : append_array
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedFloat32Array) AppendArray(array PackedFloat32Array) {
	mb := globalPackedFloat32ArrayMethodBindings.method_append_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&array))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* RemoveAt : remove_at
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedFloat32Array) RemoveAt(index int64) {
	mb := globalPackedFloat32ArrayMethodBindings.method_remove_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Insert : insert
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedFloat32Array) Insert(at_index int64, value float32) int64 {
	mb := globalPackedFloat32ArrayMethodBindings.method_insert
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(at_index)

	args[1] = Float32Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Fill : fill
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedFloat32Array) Fill(value float32) {
	mb := globalPackedFloat32ArrayMethodBindings.method_fill
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Resize : resize
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedFloat32Array) Resize(new_size int64) int64 {
	mb := globalPackedFloat32ArrayMethodBindings.method_resize
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(new_size)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clear : clear
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedFloat32Array) Clear() {
	mb := globalPackedFloat32ArrayMethodBindings.method_clear
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Has : has
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedFloat32Array) Has(value float32) bool {
	mb := globalPackedFloat32ArrayMethodBindings.method_has
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Reverse : reverse
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedFloat32Array) Reverse() {
	mb := globalPackedFloat32ArrayMethodBindings.method_reverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Slice : slice
 * is_vararg = false, is_static = false
 * goReturnType(PackedFloat32Array) -> PackedFloat32Array
 */
func (cx *PackedFloat32Array) Slice(begin int64, end int64) PackedFloat32Array {
	mb := globalPackedFloat32ArrayMethodBindings.method_slice
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(begin)

	args[1] = Int64Encoder.EncodeTypePtr(end)

	ret := CallBuiltinMethodPtrRet[PackedFloat32Array](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* ToByteArray : to_byte_array
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *PackedFloat32Array) ToByteArray() PackedByteArray {
	mb := globalPackedFloat32ArrayMethodBindings.method_to_byte_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* Sort : sort
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedFloat32Array) Sort() {
	mb := globalPackedFloat32ArrayMethodBindings.method_sort
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Bsearch : bsearch
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedFloat32Array) Bsearch(value float32, before bool) int64 {
	mb := globalPackedFloat32ArrayMethodBindings.method_bsearch
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(value)

	args[1] = BoolEncoder.EncodeTypePtr(before)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Duplicate : duplicate
 * is_vararg = false, is_static = false
 * goReturnType(PackedFloat32Array) -> PackedFloat32Array
 */
func (cx *PackedFloat32Array) Duplicate() PackedFloat32Array {
	mb := globalPackedFloat32ArrayMethodBindings.method_duplicate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedFloat32Array](mb, bx, nil)
	return ret
}

/* Find : find
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedFloat32Array) Find(value float32, from int64) int64 {
	mb := globalPackedFloat32ArrayMethodBindings.method_find
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(value)

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rfind : rfind
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedFloat32Array) Rfind(value float32, from int64) int64 {
	mb := globalPackedFloat32ArrayMethodBindings.method_rfind
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(value)

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Count : count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedFloat32Array) Count(value float32) int64 {
	mb := globalPackedFloat32ArrayMethodBindings.method_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *PackedFloat32Array) GetIndexed(i int64) float32 {
	var ret float32
	CallFunc_GDExtensionPtrIndexedGetter(
		globalPackedFloat32ArrayMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *PackedFloat32Array) SetIndexed(i int64, value float32) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalPackedFloat32ArrayMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members
// Equal_Variant operator
func (cx *PackedFloat32Array) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedFloat32ArrayMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *PackedFloat32Array) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedFloat32ArrayMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *PackedFloat32Array) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalPackedFloat32ArrayMethodBindings.operator_not, lt, rt)
}

// In_Dictionary operator
func (cx *PackedFloat32Array) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedFloat32ArrayMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *PackedFloat32Array) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedFloat32ArrayMethodBindings.operator_in_Array, lt, rt)
}

// Equal_PackedFloat32Array operator
func (cx *PackedFloat32Array) Equal_PackedFloat32Array(right PackedFloat32Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedFloat32ArrayMethodBindings.operator_equal_PackedFloat32Array, lt, rt)
}

// Not_equal_PackedFloat32Array operator
func (cx *PackedFloat32Array) Not_equal_PackedFloat32Array(right PackedFloat32Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedFloat32ArrayMethodBindings.operator_not_equal_PackedFloat32Array, lt, rt)
}

// Add_PackedFloat32Array operator
func (cx *PackedFloat32Array) Add_PackedFloat32Array(right PackedFloat32Array) PackedFloat32Array {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[PackedFloat32Array](globalPackedFloat32ArrayMethodBindings.operator_add_PackedFloat32Array, lt, rt)
}

var _ GDBuiltInDestroyableClass = &PackedFloat64Array{}

/*
 * PackedFloat64Array
 * indexingReturnType: float
 * isKeyed: false
 * hasDestructor: true
 */
type PackedFloat64Array [16]uint8

func (c *PackedFloat64Array) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *PackedFloat64Array) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewPackedFloat64Array, index: 0
func NewPackedFloat64Array() PackedFloat64Array {
	cx := PackedFloat64Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalPackedFloat64ArrayMethodBindings.constructor_0, ptr)
	return cx
}

// NewPackedFloat64Array, index: 1
func NewPackedFloat64ArrayWithPackedFloat64Array(from PackedFloat64Array) PackedFloat64Array {
	cx := PackedFloat64Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedFloat64Array
	// PackedFloat64ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedFloat64ArrayMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewPackedFloat64Array, index: 2
func NewPackedFloat64ArrayWithArray(from Array) PackedFloat64Array {
	cx := PackedFloat64Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Array
	// ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedFloat64ArrayMethodBindings.constructor_2, ptr, args[0])
	return cx
}

func (cx *PackedFloat64Array) Destroy() {
	md := (GDExtensionPtrDestructor)(globalPackedFloat64ArrayMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewPackedFloat64ArrayWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) PackedFloat64Array {
	ret := PackedFloat64Array{}
	typedSrc := (*PackedFloat64Array)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (PackedFloat64Array)(ret)
}
func copyPackedFloat64ArrayWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*PackedFloat64Array)(dst)
	typedSrc := (*PackedFloat64Array)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Size : size
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedFloat64Array) Size() int64 {
	mb := globalPackedFloat64ArrayMethodBindings.method_size
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* IsEmpty : is_empty
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedFloat64Array) IsEmpty() bool {
	mb := globalPackedFloat64ArrayMethodBindings.method_is_empty
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Set : set
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedFloat64Array) Set(index int64, value float32) {
	mb := globalPackedFloat64ArrayMethodBindings.method_set
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	args[1] = Float32Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* PushBack : push_back
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedFloat64Array) PushBack(value float32) bool {
	mb := globalPackedFloat64ArrayMethodBindings.method_push_back
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Append : append
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedFloat64Array) Append(value float32) bool {
	mb := globalPackedFloat64ArrayMethodBindings.method_append
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* AppendArray : append_array
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedFloat64Array) AppendArray(array PackedFloat64Array) {
	mb := globalPackedFloat64ArrayMethodBindings.method_append_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&array))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* RemoveAt : remove_at
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedFloat64Array) RemoveAt(index int64) {
	mb := globalPackedFloat64ArrayMethodBindings.method_remove_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Insert : insert
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedFloat64Array) Insert(at_index int64, value float32) int64 {
	mb := globalPackedFloat64ArrayMethodBindings.method_insert
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(at_index)

	args[1] = Float32Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Fill : fill
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedFloat64Array) Fill(value float32) {
	mb := globalPackedFloat64ArrayMethodBindings.method_fill
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(value)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Resize : resize
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedFloat64Array) Resize(new_size int64) int64 {
	mb := globalPackedFloat64ArrayMethodBindings.method_resize
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(new_size)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clear : clear
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedFloat64Array) Clear() {
	mb := globalPackedFloat64ArrayMethodBindings.method_clear
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Has : has
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedFloat64Array) Has(value float32) bool {
	mb := globalPackedFloat64ArrayMethodBindings.method_has
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Reverse : reverse
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedFloat64Array) Reverse() {
	mb := globalPackedFloat64ArrayMethodBindings.method_reverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Slice : slice
 * is_vararg = false, is_static = false
 * goReturnType(PackedFloat64Array) -> PackedFloat64Array
 */
func (cx *PackedFloat64Array) Slice(begin int64, end int64) PackedFloat64Array {
	mb := globalPackedFloat64ArrayMethodBindings.method_slice
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(begin)

	args[1] = Int64Encoder.EncodeTypePtr(end)

	ret := CallBuiltinMethodPtrRet[PackedFloat64Array](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* ToByteArray : to_byte_array
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *PackedFloat64Array) ToByteArray() PackedByteArray {
	mb := globalPackedFloat64ArrayMethodBindings.method_to_byte_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* Sort : sort
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedFloat64Array) Sort() {
	mb := globalPackedFloat64ArrayMethodBindings.method_sort
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Bsearch : bsearch
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedFloat64Array) Bsearch(value float32, before bool) int64 {
	mb := globalPackedFloat64ArrayMethodBindings.method_bsearch
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(value)

	args[1] = BoolEncoder.EncodeTypePtr(before)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Duplicate : duplicate
 * is_vararg = false, is_static = false
 * goReturnType(PackedFloat64Array) -> PackedFloat64Array
 */
func (cx *PackedFloat64Array) Duplicate() PackedFloat64Array {
	mb := globalPackedFloat64ArrayMethodBindings.method_duplicate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedFloat64Array](mb, bx, nil)
	return ret
}

/* Find : find
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedFloat64Array) Find(value float32, from int64) int64 {
	mb := globalPackedFloat64ArrayMethodBindings.method_find
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(value)

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rfind : rfind
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedFloat64Array) Rfind(value float32, from int64) int64 {
	mb := globalPackedFloat64ArrayMethodBindings.method_rfind
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(value)

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Count : count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedFloat64Array) Count(value float32) int64 {
	mb := globalPackedFloat64ArrayMethodBindings.method_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Float32Encoder.EncodeTypePtr(value)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *PackedFloat64Array) GetIndexed(i int64) float32 {
	var ret float32
	CallFunc_GDExtensionPtrIndexedGetter(
		globalPackedFloat64ArrayMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *PackedFloat64Array) SetIndexed(i int64, value float32) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalPackedFloat64ArrayMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members
// Equal_Variant operator
func (cx *PackedFloat64Array) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedFloat64ArrayMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *PackedFloat64Array) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedFloat64ArrayMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *PackedFloat64Array) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalPackedFloat64ArrayMethodBindings.operator_not, lt, rt)
}

// In_Dictionary operator
func (cx *PackedFloat64Array) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedFloat64ArrayMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *PackedFloat64Array) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedFloat64ArrayMethodBindings.operator_in_Array, lt, rt)
}

// Equal_PackedFloat64Array operator
func (cx *PackedFloat64Array) Equal_PackedFloat64Array(right PackedFloat64Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedFloat64ArrayMethodBindings.operator_equal_PackedFloat64Array, lt, rt)
}

// Not_equal_PackedFloat64Array operator
func (cx *PackedFloat64Array) Not_equal_PackedFloat64Array(right PackedFloat64Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedFloat64ArrayMethodBindings.operator_not_equal_PackedFloat64Array, lt, rt)
}

// Add_PackedFloat64Array operator
func (cx *PackedFloat64Array) Add_PackedFloat64Array(right PackedFloat64Array) PackedFloat64Array {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[PackedFloat64Array](globalPackedFloat64ArrayMethodBindings.operator_add_PackedFloat64Array, lt, rt)
}

var _ GDBuiltInDestroyableClass = &PackedStringArray{}

/*
 * PackedStringArray
 * indexingReturnType: String
 * isKeyed: false
 * hasDestructor: true
 */
type PackedStringArray [16]uint8

func (c *PackedStringArray) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *PackedStringArray) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewPackedStringArray, index: 0
func NewPackedStringArray() PackedStringArray {
	cx := PackedStringArray{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalPackedStringArrayMethodBindings.constructor_0, ptr)
	return cx
}

// NewPackedStringArray, index: 1
func NewPackedStringArrayWithPackedStringArray(from PackedStringArray) PackedStringArray {
	cx := PackedStringArray{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedStringArray
	// PackedStringArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedStringArrayMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewPackedStringArray, index: 2
func NewPackedStringArrayWithArray(from Array) PackedStringArray {
	cx := PackedStringArray{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Array
	// ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedStringArrayMethodBindings.constructor_2, ptr, args[0])
	return cx
}

func (cx *PackedStringArray) Destroy() {
	md := (GDExtensionPtrDestructor)(globalPackedStringArrayMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewPackedStringArrayWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) PackedStringArray {
	ret := PackedStringArray{}
	typedSrc := (*PackedStringArray)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (PackedStringArray)(ret)
}
func copyPackedStringArrayWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*PackedStringArray)(dst)
	typedSrc := (*PackedStringArray)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Size : size
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedStringArray) Size() int64 {
	mb := globalPackedStringArrayMethodBindings.method_size
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* IsEmpty : is_empty
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedStringArray) IsEmpty() bool {
	mb := globalPackedStringArrayMethodBindings.method_is_empty
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Set : set
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedStringArray) Set(index int64, value String) {
	mb := globalPackedStringArrayMethodBindings.method_set
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* PushBack : push_back
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedStringArray) PushBack(value String) bool {
	mb := globalPackedStringArrayMethodBindings.method_push_back
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Append : append
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedStringArray) Append(value String) bool {
	mb := globalPackedStringArrayMethodBindings.method_append
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* AppendArray : append_array
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedStringArray) AppendArray(array PackedStringArray) {
	mb := globalPackedStringArrayMethodBindings.method_append_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&array))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* RemoveAt : remove_at
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedStringArray) RemoveAt(index int64) {
	mb := globalPackedStringArrayMethodBindings.method_remove_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Insert : insert
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedStringArray) Insert(at_index int64, value String) int64 {
	mb := globalPackedStringArrayMethodBindings.method_insert
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(at_index)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Fill : fill
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedStringArray) Fill(value String) {
	mb := globalPackedStringArrayMethodBindings.method_fill
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Resize : resize
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedStringArray) Resize(new_size int64) int64 {
	mb := globalPackedStringArrayMethodBindings.method_resize
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(new_size)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clear : clear
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedStringArray) Clear() {
	mb := globalPackedStringArrayMethodBindings.method_clear
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Has : has
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedStringArray) Has(value String) bool {
	mb := globalPackedStringArrayMethodBindings.method_has
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Reverse : reverse
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedStringArray) Reverse() {
	mb := globalPackedStringArrayMethodBindings.method_reverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Slice : slice
 * is_vararg = false, is_static = false
 * goReturnType(PackedStringArray) -> PackedStringArray
 */
func (cx *PackedStringArray) Slice(begin int64, end int64) PackedStringArray {
	mb := globalPackedStringArrayMethodBindings.method_slice
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(begin)

	args[1] = Int64Encoder.EncodeTypePtr(end)

	ret := CallBuiltinMethodPtrRet[PackedStringArray](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* ToByteArray : to_byte_array
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *PackedStringArray) ToByteArray() PackedByteArray {
	mb := globalPackedStringArrayMethodBindings.method_to_byte_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* Sort : sort
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedStringArray) Sort() {
	mb := globalPackedStringArrayMethodBindings.method_sort
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Bsearch : bsearch
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedStringArray) Bsearch(value String, before bool) int64 {
	mb := globalPackedStringArrayMethodBindings.method_bsearch
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = BoolEncoder.EncodeTypePtr(before)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Duplicate : duplicate
 * is_vararg = false, is_static = false
 * goReturnType(PackedStringArray) -> PackedStringArray
 */
func (cx *PackedStringArray) Duplicate() PackedStringArray {
	mb := globalPackedStringArrayMethodBindings.method_duplicate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedStringArray](mb, bx, nil)
	return ret
}

/* Find : find
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedStringArray) Find(value String, from int64) int64 {
	mb := globalPackedStringArrayMethodBindings.method_find
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rfind : rfind
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedStringArray) Rfind(value String, from int64) int64 {
	mb := globalPackedStringArrayMethodBindings.method_rfind
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Count : count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedStringArray) Count(value String) int64 {
	mb := globalPackedStringArrayMethodBindings.method_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *PackedStringArray) GetIndexed(i int64) String {
	var ret String
	CallFunc_GDExtensionPtrIndexedGetter(
		globalPackedStringArrayMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *PackedStringArray) SetIndexed(i int64, value String) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalPackedStringArrayMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members
// Equal_Variant operator
func (cx *PackedStringArray) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedStringArrayMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *PackedStringArray) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedStringArrayMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *PackedStringArray) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalPackedStringArrayMethodBindings.operator_not, lt, rt)
}

// In_Dictionary operator
func (cx *PackedStringArray) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedStringArrayMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *PackedStringArray) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedStringArrayMethodBindings.operator_in_Array, lt, rt)
}

// Equal_PackedStringArray operator
func (cx *PackedStringArray) Equal_PackedStringArray(right PackedStringArray) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedStringArrayMethodBindings.operator_equal_PackedStringArray, lt, rt)
}

// Not_equal_PackedStringArray operator
func (cx *PackedStringArray) Not_equal_PackedStringArray(right PackedStringArray) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedStringArrayMethodBindings.operator_not_equal_PackedStringArray, lt, rt)
}

// Add_PackedStringArray operator
func (cx *PackedStringArray) Add_PackedStringArray(right PackedStringArray) PackedStringArray {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[PackedStringArray](globalPackedStringArrayMethodBindings.operator_add_PackedStringArray, lt, rt)
}

var _ GDBuiltInDestroyableClass = &PackedVector2Array{}

/*
 * PackedVector2Array
 * indexingReturnType: Vector2
 * isKeyed: false
 * hasDestructor: true
 */
type PackedVector2Array [16]uint8

func (c *PackedVector2Array) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *PackedVector2Array) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewPackedVector2Array, index: 0
func NewPackedVector2Array() PackedVector2Array {
	cx := PackedVector2Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalPackedVector2ArrayMethodBindings.constructor_0, ptr)
	return cx
}

// NewPackedVector2Array, index: 1
func NewPackedVector2ArrayWithPackedVector2Array(from PackedVector2Array) PackedVector2Array {
	cx := PackedVector2Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedVector2Array
	// PackedVector2ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedVector2ArrayMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewPackedVector2Array, index: 2
func NewPackedVector2ArrayWithArray(from Array) PackedVector2Array {
	cx := PackedVector2Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Array
	// ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedVector2ArrayMethodBindings.constructor_2, ptr, args[0])
	return cx
}

func (cx *PackedVector2Array) Destroy() {
	md := (GDExtensionPtrDestructor)(globalPackedVector2ArrayMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewPackedVector2ArrayWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) PackedVector2Array {
	ret := PackedVector2Array{}
	typedSrc := (*PackedVector2Array)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (PackedVector2Array)(ret)
}
func copyPackedVector2ArrayWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*PackedVector2Array)(dst)
	typedSrc := (*PackedVector2Array)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Size : size
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector2Array) Size() int64 {
	mb := globalPackedVector2ArrayMethodBindings.method_size
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* IsEmpty : is_empty
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedVector2Array) IsEmpty() bool {
	mb := globalPackedVector2ArrayMethodBindings.method_is_empty
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Set : set
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector2Array) Set(index int64, value Vector2) {
	mb := globalPackedVector2ArrayMethodBindings.method_set
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* PushBack : push_back
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedVector2Array) PushBack(value Vector2) bool {
	mb := globalPackedVector2ArrayMethodBindings.method_push_back
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Append : append
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedVector2Array) Append(value Vector2) bool {
	mb := globalPackedVector2ArrayMethodBindings.method_append
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* AppendArray : append_array
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector2Array) AppendArray(array PackedVector2Array) {
	mb := globalPackedVector2ArrayMethodBindings.method_append_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&array))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* RemoveAt : remove_at
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector2Array) RemoveAt(index int64) {
	mb := globalPackedVector2ArrayMethodBindings.method_remove_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Insert : insert
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector2Array) Insert(at_index int64, value Vector2) int64 {
	mb := globalPackedVector2ArrayMethodBindings.method_insert
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(at_index)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Fill : fill
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector2Array) Fill(value Vector2) {
	mb := globalPackedVector2ArrayMethodBindings.method_fill
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Resize : resize
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector2Array) Resize(new_size int64) int64 {
	mb := globalPackedVector2ArrayMethodBindings.method_resize
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(new_size)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clear : clear
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector2Array) Clear() {
	mb := globalPackedVector2ArrayMethodBindings.method_clear
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Has : has
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedVector2Array) Has(value Vector2) bool {
	mb := globalPackedVector2ArrayMethodBindings.method_has
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Reverse : reverse
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector2Array) Reverse() {
	mb := globalPackedVector2ArrayMethodBindings.method_reverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Slice : slice
 * is_vararg = false, is_static = false
 * goReturnType(PackedVector2Array) -> PackedVector2Array
 */
func (cx *PackedVector2Array) Slice(begin int64, end int64) PackedVector2Array {
	mb := globalPackedVector2ArrayMethodBindings.method_slice
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(begin)

	args[1] = Int64Encoder.EncodeTypePtr(end)

	ret := CallBuiltinMethodPtrRet[PackedVector2Array](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* ToByteArray : to_byte_array
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *PackedVector2Array) ToByteArray() PackedByteArray {
	mb := globalPackedVector2ArrayMethodBindings.method_to_byte_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* Sort : sort
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector2Array) Sort() {
	mb := globalPackedVector2ArrayMethodBindings.method_sort
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Bsearch : bsearch
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector2Array) Bsearch(value Vector2, before bool) int64 {
	mb := globalPackedVector2ArrayMethodBindings.method_bsearch
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = BoolEncoder.EncodeTypePtr(before)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Duplicate : duplicate
 * is_vararg = false, is_static = false
 * goReturnType(PackedVector2Array) -> PackedVector2Array
 */
func (cx *PackedVector2Array) Duplicate() PackedVector2Array {
	mb := globalPackedVector2ArrayMethodBindings.method_duplicate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedVector2Array](mb, bx, nil)
	return ret
}

/* Find : find
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector2Array) Find(value Vector2, from int64) int64 {
	mb := globalPackedVector2ArrayMethodBindings.method_find
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rfind : rfind
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector2Array) Rfind(value Vector2, from int64) int64 {
	mb := globalPackedVector2ArrayMethodBindings.method_rfind
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Count : count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector2Array) Count(value Vector2) int64 {
	mb := globalPackedVector2ArrayMethodBindings.method_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *PackedVector2Array) GetIndexed(i int64) Vector2 {
	var ret Vector2
	CallFunc_GDExtensionPtrIndexedGetter(
		globalPackedVector2ArrayMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *PackedVector2Array) SetIndexed(i int64, value Vector2) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalPackedVector2ArrayMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members
// Equal_Variant operator
func (cx *PackedVector2Array) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedVector2ArrayMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *PackedVector2Array) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedVector2ArrayMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *PackedVector2Array) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalPackedVector2ArrayMethodBindings.operator_not, lt, rt)
}

// Multiply_Transform2D operator
func (cx *PackedVector2Array) Multiply_Transform2D(right Transform2D) PackedVector2Array {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[PackedVector2Array](globalPackedVector2ArrayMethodBindings.operator_multiply_Transform2D, lt, rt)
}

// In_Dictionary operator
func (cx *PackedVector2Array) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedVector2ArrayMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *PackedVector2Array) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedVector2ArrayMethodBindings.operator_in_Array, lt, rt)
}

// Equal_PackedVector2Array operator
func (cx *PackedVector2Array) Equal_PackedVector2Array(right PackedVector2Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedVector2ArrayMethodBindings.operator_equal_PackedVector2Array, lt, rt)
}

// Not_equal_PackedVector2Array operator
func (cx *PackedVector2Array) Not_equal_PackedVector2Array(right PackedVector2Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedVector2ArrayMethodBindings.operator_not_equal_PackedVector2Array, lt, rt)
}

// Add_PackedVector2Array operator
func (cx *PackedVector2Array) Add_PackedVector2Array(right PackedVector2Array) PackedVector2Array {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[PackedVector2Array](globalPackedVector2ArrayMethodBindings.operator_add_PackedVector2Array, lt, rt)
}

var _ GDBuiltInDestroyableClass = &PackedVector3Array{}

/*
 * PackedVector3Array
 * indexingReturnType: Vector3
 * isKeyed: false
 * hasDestructor: true
 */
type PackedVector3Array [16]uint8

func (c *PackedVector3Array) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *PackedVector3Array) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewPackedVector3Array, index: 0
func NewPackedVector3Array() PackedVector3Array {
	cx := PackedVector3Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalPackedVector3ArrayMethodBindings.constructor_0, ptr)
	return cx
}

// NewPackedVector3Array, index: 1
func NewPackedVector3ArrayWithPackedVector3Array(from PackedVector3Array) PackedVector3Array {
	cx := PackedVector3Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedVector3Array
	// PackedVector3ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedVector3ArrayMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewPackedVector3Array, index: 2
func NewPackedVector3ArrayWithArray(from Array) PackedVector3Array {
	cx := PackedVector3Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Array
	// ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedVector3ArrayMethodBindings.constructor_2, ptr, args[0])
	return cx
}

func (cx *PackedVector3Array) Destroy() {
	md := (GDExtensionPtrDestructor)(globalPackedVector3ArrayMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewPackedVector3ArrayWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) PackedVector3Array {
	ret := PackedVector3Array{}
	typedSrc := (*PackedVector3Array)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (PackedVector3Array)(ret)
}
func copyPackedVector3ArrayWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*PackedVector3Array)(dst)
	typedSrc := (*PackedVector3Array)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Size : size
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector3Array) Size() int64 {
	mb := globalPackedVector3ArrayMethodBindings.method_size
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* IsEmpty : is_empty
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedVector3Array) IsEmpty() bool {
	mb := globalPackedVector3ArrayMethodBindings.method_is_empty
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Set : set
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector3Array) Set(index int64, value Vector3) {
	mb := globalPackedVector3ArrayMethodBindings.method_set
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* PushBack : push_back
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedVector3Array) PushBack(value Vector3) bool {
	mb := globalPackedVector3ArrayMethodBindings.method_push_back
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Append : append
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedVector3Array) Append(value Vector3) bool {
	mb := globalPackedVector3ArrayMethodBindings.method_append
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* AppendArray : append_array
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector3Array) AppendArray(array PackedVector3Array) {
	mb := globalPackedVector3ArrayMethodBindings.method_append_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&array))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* RemoveAt : remove_at
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector3Array) RemoveAt(index int64) {
	mb := globalPackedVector3ArrayMethodBindings.method_remove_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Insert : insert
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector3Array) Insert(at_index int64, value Vector3) int64 {
	mb := globalPackedVector3ArrayMethodBindings.method_insert
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(at_index)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Fill : fill
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector3Array) Fill(value Vector3) {
	mb := globalPackedVector3ArrayMethodBindings.method_fill
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Resize : resize
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector3Array) Resize(new_size int64) int64 {
	mb := globalPackedVector3ArrayMethodBindings.method_resize
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(new_size)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clear : clear
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector3Array) Clear() {
	mb := globalPackedVector3ArrayMethodBindings.method_clear
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Has : has
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedVector3Array) Has(value Vector3) bool {
	mb := globalPackedVector3ArrayMethodBindings.method_has
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Reverse : reverse
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector3Array) Reverse() {
	mb := globalPackedVector3ArrayMethodBindings.method_reverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Slice : slice
 * is_vararg = false, is_static = false
 * goReturnType(PackedVector3Array) -> PackedVector3Array
 */
func (cx *PackedVector3Array) Slice(begin int64, end int64) PackedVector3Array {
	mb := globalPackedVector3ArrayMethodBindings.method_slice
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(begin)

	args[1] = Int64Encoder.EncodeTypePtr(end)

	ret := CallBuiltinMethodPtrRet[PackedVector3Array](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* ToByteArray : to_byte_array
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *PackedVector3Array) ToByteArray() PackedByteArray {
	mb := globalPackedVector3ArrayMethodBindings.method_to_byte_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* Sort : sort
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector3Array) Sort() {
	mb := globalPackedVector3ArrayMethodBindings.method_sort
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Bsearch : bsearch
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector3Array) Bsearch(value Vector3, before bool) int64 {
	mb := globalPackedVector3ArrayMethodBindings.method_bsearch
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = BoolEncoder.EncodeTypePtr(before)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Duplicate : duplicate
 * is_vararg = false, is_static = false
 * goReturnType(PackedVector3Array) -> PackedVector3Array
 */
func (cx *PackedVector3Array) Duplicate() PackedVector3Array {
	mb := globalPackedVector3ArrayMethodBindings.method_duplicate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedVector3Array](mb, bx, nil)
	return ret
}

/* Find : find
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector3Array) Find(value Vector3, from int64) int64 {
	mb := globalPackedVector3ArrayMethodBindings.method_find
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rfind : rfind
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector3Array) Rfind(value Vector3, from int64) int64 {
	mb := globalPackedVector3ArrayMethodBindings.method_rfind
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Count : count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector3Array) Count(value Vector3) int64 {
	mb := globalPackedVector3ArrayMethodBindings.method_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *PackedVector3Array) GetIndexed(i int64) Vector3 {
	var ret Vector3
	CallFunc_GDExtensionPtrIndexedGetter(
		globalPackedVector3ArrayMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *PackedVector3Array) SetIndexed(i int64, value Vector3) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalPackedVector3ArrayMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members
// Equal_Variant operator
func (cx *PackedVector3Array) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedVector3ArrayMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *PackedVector3Array) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedVector3ArrayMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *PackedVector3Array) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalPackedVector3ArrayMethodBindings.operator_not, lt, rt)
}

// Multiply_Transform3D operator
func (cx *PackedVector3Array) Multiply_Transform3D(right Transform3D) PackedVector3Array {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[PackedVector3Array](globalPackedVector3ArrayMethodBindings.operator_multiply_Transform3D, lt, rt)
}

// In_Dictionary operator
func (cx *PackedVector3Array) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedVector3ArrayMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *PackedVector3Array) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedVector3ArrayMethodBindings.operator_in_Array, lt, rt)
}

// Equal_PackedVector3Array operator
func (cx *PackedVector3Array) Equal_PackedVector3Array(right PackedVector3Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedVector3ArrayMethodBindings.operator_equal_PackedVector3Array, lt, rt)
}

// Not_equal_PackedVector3Array operator
func (cx *PackedVector3Array) Not_equal_PackedVector3Array(right PackedVector3Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedVector3ArrayMethodBindings.operator_not_equal_PackedVector3Array, lt, rt)
}

// Add_PackedVector3Array operator
func (cx *PackedVector3Array) Add_PackedVector3Array(right PackedVector3Array) PackedVector3Array {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[PackedVector3Array](globalPackedVector3ArrayMethodBindings.operator_add_PackedVector3Array, lt, rt)
}

var _ GDBuiltInDestroyableClass = &PackedColorArray{}

/*
 * PackedColorArray
 * indexingReturnType: Color
 * isKeyed: false
 * hasDestructor: true
 */
type PackedColorArray [16]uint8

func (c *PackedColorArray) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *PackedColorArray) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewPackedColorArray, index: 0
func NewPackedColorArray() PackedColorArray {
	cx := PackedColorArray{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalPackedColorArrayMethodBindings.constructor_0, ptr)
	return cx
}

// NewPackedColorArray, index: 1
func NewPackedColorArrayWithPackedColorArray(from PackedColorArray) PackedColorArray {
	cx := PackedColorArray{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedColorArray
	// PackedColorArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedColorArrayMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewPackedColorArray, index: 2
func NewPackedColorArrayWithArray(from Array) PackedColorArray {
	cx := PackedColorArray{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Array
	// ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedColorArrayMethodBindings.constructor_2, ptr, args[0])
	return cx
}

func (cx *PackedColorArray) Destroy() {
	md := (GDExtensionPtrDestructor)(globalPackedColorArrayMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewPackedColorArrayWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) PackedColorArray {
	ret := PackedColorArray{}
	typedSrc := (*PackedColorArray)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (PackedColorArray)(ret)
}
func copyPackedColorArrayWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*PackedColorArray)(dst)
	typedSrc := (*PackedColorArray)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Size : size
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedColorArray) Size() int64 {
	mb := globalPackedColorArrayMethodBindings.method_size
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* IsEmpty : is_empty
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedColorArray) IsEmpty() bool {
	mb := globalPackedColorArrayMethodBindings.method_is_empty
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Set : set
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedColorArray) Set(index int64, value Color) {
	mb := globalPackedColorArrayMethodBindings.method_set
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* PushBack : push_back
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedColorArray) PushBack(value Color) bool {
	mb := globalPackedColorArrayMethodBindings.method_push_back
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Append : append
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedColorArray) Append(value Color) bool {
	mb := globalPackedColorArrayMethodBindings.method_append
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* AppendArray : append_array
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedColorArray) AppendArray(array PackedColorArray) {
	mb := globalPackedColorArrayMethodBindings.method_append_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&array))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* RemoveAt : remove_at
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedColorArray) RemoveAt(index int64) {
	mb := globalPackedColorArrayMethodBindings.method_remove_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Insert : insert
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedColorArray) Insert(at_index int64, value Color) int64 {
	mb := globalPackedColorArrayMethodBindings.method_insert
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(at_index)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Fill : fill
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedColorArray) Fill(value Color) {
	mb := globalPackedColorArrayMethodBindings.method_fill
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Resize : resize
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedColorArray) Resize(new_size int64) int64 {
	mb := globalPackedColorArrayMethodBindings.method_resize
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(new_size)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clear : clear
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedColorArray) Clear() {
	mb := globalPackedColorArrayMethodBindings.method_clear
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Has : has
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedColorArray) Has(value Color) bool {
	mb := globalPackedColorArrayMethodBindings.method_has
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Reverse : reverse
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedColorArray) Reverse() {
	mb := globalPackedColorArrayMethodBindings.method_reverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Slice : slice
 * is_vararg = false, is_static = false
 * goReturnType(PackedColorArray) -> PackedColorArray
 */
func (cx *PackedColorArray) Slice(begin int64, end int64) PackedColorArray {
	mb := globalPackedColorArrayMethodBindings.method_slice
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(begin)

	args[1] = Int64Encoder.EncodeTypePtr(end)

	ret := CallBuiltinMethodPtrRet[PackedColorArray](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* ToByteArray : to_byte_array
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *PackedColorArray) ToByteArray() PackedByteArray {
	mb := globalPackedColorArrayMethodBindings.method_to_byte_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* Sort : sort
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedColorArray) Sort() {
	mb := globalPackedColorArrayMethodBindings.method_sort
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Bsearch : bsearch
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedColorArray) Bsearch(value Color, before bool) int64 {
	mb := globalPackedColorArrayMethodBindings.method_bsearch
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = BoolEncoder.EncodeTypePtr(before)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Duplicate : duplicate
 * is_vararg = false, is_static = false
 * goReturnType(PackedColorArray) -> PackedColorArray
 */
func (cx *PackedColorArray) Duplicate() PackedColorArray {
	mb := globalPackedColorArrayMethodBindings.method_duplicate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedColorArray](mb, bx, nil)
	return ret
}

/* Find : find
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedColorArray) Find(value Color, from int64) int64 {
	mb := globalPackedColorArrayMethodBindings.method_find
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rfind : rfind
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedColorArray) Rfind(value Color, from int64) int64 {
	mb := globalPackedColorArrayMethodBindings.method_rfind
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Count : count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedColorArray) Count(value Color) int64 {
	mb := globalPackedColorArrayMethodBindings.method_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *PackedColorArray) GetIndexed(i int64) Color {
	var ret Color
	CallFunc_GDExtensionPtrIndexedGetter(
		globalPackedColorArrayMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *PackedColorArray) SetIndexed(i int64, value Color) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalPackedColorArrayMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members
// Equal_Variant operator
func (cx *PackedColorArray) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedColorArrayMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *PackedColorArray) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedColorArrayMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *PackedColorArray) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalPackedColorArrayMethodBindings.operator_not, lt, rt)
}

// In_Dictionary operator
func (cx *PackedColorArray) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedColorArrayMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *PackedColorArray) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedColorArrayMethodBindings.operator_in_Array, lt, rt)
}

// Equal_PackedColorArray operator
func (cx *PackedColorArray) Equal_PackedColorArray(right PackedColorArray) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedColorArrayMethodBindings.operator_equal_PackedColorArray, lt, rt)
}

// Not_equal_PackedColorArray operator
func (cx *PackedColorArray) Not_equal_PackedColorArray(right PackedColorArray) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedColorArrayMethodBindings.operator_not_equal_PackedColorArray, lt, rt)
}

// Add_PackedColorArray operator
func (cx *PackedColorArray) Add_PackedColorArray(right PackedColorArray) PackedColorArray {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[PackedColorArray](globalPackedColorArrayMethodBindings.operator_add_PackedColorArray, lt, rt)
}

var _ GDBuiltInDestroyableClass = &PackedVector4Array{}

/*
 * PackedVector4Array
 * indexingReturnType: Vector4
 * isKeyed: false
 * hasDestructor: true
 */
type PackedVector4Array [16]uint8

func (c *PackedVector4Array) NativeConstPtr() GDExtensionConstTypePtr {
	return (GDExtensionConstTypePtr)(unsafe.Pointer(c))
}

func (c *PackedVector4Array) NativePtr() GDExtensionTypePtr {
	return (GDExtensionTypePtr)(unsafe.Pointer(c))
}

// constructors
// NewPackedVector4Array, index: 0
func NewPackedVector4Array() PackedVector4Array {
	cx := PackedVector4Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	CallBuiltinConstructor(globalPackedVector4ArrayMethodBindings.constructor_0, ptr)
	return cx
}

// NewPackedVector4Array, index: 1
func NewPackedVector4ArrayWithPackedVector4Array(from PackedVector4Array) PackedVector4Array {
	cx := PackedVector4Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// PackedVector4Array
	// PackedVector4ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedVector4ArrayMethodBindings.constructor_1, ptr, args[0])
	return cx
}

// NewPackedVector4Array, index: 2
func NewPackedVector4ArrayWithArray(from Array) PackedVector4Array {
	cx := PackedVector4Array{}
	ptr := (GDExtensionUninitializedTypePtr)(unsafe.Pointer(cx.NativePtr()))
	var args [1]GDExtensionConstTypePtr
	// Array
	// ArrayEncoder
	args[0] = from.NativeConstPtr()
	CallBuiltinConstructor(globalPackedVector4ArrayMethodBindings.constructor_2, ptr, args[0])
	return cx
}

func (cx *PackedVector4Array) Destroy() {
	md := (GDExtensionPtrDestructor)(globalPackedVector4ArrayMethodBindings.destructor)
	bx := cx.NativePtr()
	CallFunc_GDExtensionPtrDestructor(md, bx)
}

// copy funuctions
func NewPackedVector4ArrayWithGDExtensionConstTypePtr(src GDExtensionConstTypePtr) PackedVector4Array {
	ret := PackedVector4Array{}
	typedSrc := (*PackedVector4Array)(src)

	for i := 0; i < 16; i++ {
		ret[i] = typedSrc[i]
	}

	return (PackedVector4Array)(ret)
}
func copyPackedVector4ArrayWithGDExtensionTypePtr(dst GDExtensionTypePtr, src GDExtensionConstTypePtr) {
	typedDst := (*PackedVector4Array)(dst)
	typedSrc := (*PackedVector4Array)(src)

	for i := 0; i < 16; i++ {
		typedDst[i] = typedSrc[i]
	}
}

// methods

/* Size : size
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector4Array) Size() int64 {
	mb := globalPackedVector4ArrayMethodBindings.method_size
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, nil)
	return ret
}

/* IsEmpty : is_empty
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedVector4Array) IsEmpty() bool {
	mb := globalPackedVector4ArrayMethodBindings.method_is_empty
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, nil)
	return ret
}

/* Set : set
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector4Array) Set(index int64, value Vector4) {
	mb := globalPackedVector4ArrayMethodBindings.method_set
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* PushBack : push_back
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedVector4Array) PushBack(value Vector4) bool {
	mb := globalPackedVector4ArrayMethodBindings.method_push_back
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Append : append
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedVector4Array) Append(value Vector4) bool {
	mb := globalPackedVector4ArrayMethodBindings.method_append
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* AppendArray : append_array
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector4Array) AppendArray(array PackedVector4Array) {
	mb := globalPackedVector4ArrayMethodBindings.method_append_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = PackedVector4ArrayEncoder.EncodeTypePtr(array)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* RemoveAt : remove_at
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector4Array) RemoveAt(index int64) {
	mb := globalPackedVector4ArrayMethodBindings.method_remove_at
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(index)

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Insert : insert
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector4Array) Insert(at_index int64, value Vector4) int64 {
	mb := globalPackedVector4ArrayMethodBindings.method_insert
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(at_index)

	args[1] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Fill : fill
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector4Array) Fill(value Vector4) {
	mb := globalPackedVector4ArrayMethodBindings.method_fill
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	CallBuiltinMethodPtrNoRet(mb, bx, args...)
	runtime.KeepAlive(args)

}

/* Resize : resize
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector4Array) Resize(new_size int64) int64 {
	mb := globalPackedVector4ArrayMethodBindings.method_resize
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(new_size)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Clear : clear
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector4Array) Clear() {
	mb := globalPackedVector4ArrayMethodBindings.method_clear
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Has : has
 * is_vararg = false, is_static = false
 * goReturnType(bool) -> bool
 */
func (cx *PackedVector4Array) Has(value Vector4) bool {
	mb := globalPackedVector4ArrayMethodBindings.method_has
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[bool](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Reverse : reverse
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector4Array) Reverse() {
	mb := globalPackedVector4ArrayMethodBindings.method_reverse
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Slice : slice
 * is_vararg = false, is_static = false
 * goReturnType(PackedVector4Array) -> PackedVector4Array
 */
func (cx *PackedVector4Array) Slice(begin int64, end int64) PackedVector4Array {
	mb := globalPackedVector4ArrayMethodBindings.method_slice
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = Int64Encoder.EncodeTypePtr(begin)

	args[1] = Int64Encoder.EncodeTypePtr(end)

	ret := CallBuiltinMethodPtrRet[PackedVector4Array](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* ToByteArray : to_byte_array
 * is_vararg = false, is_static = false
 * goReturnType(PackedByteArray) -> PackedByteArray
 */
func (cx *PackedVector4Array) ToByteArray() PackedByteArray {
	mb := globalPackedVector4ArrayMethodBindings.method_to_byte_array
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedByteArray](mb, bx, nil)
	return ret
}

/* Sort : sort
 * is_vararg = false, is_static = false
 * goReturnType() ->
 */
func (cx *PackedVector4Array) Sort() {
	mb := globalPackedVector4ArrayMethodBindings.method_sort
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	CallBuiltinMethodPtrNoRet(mb, bx, nil)

}

/* Bsearch : bsearch
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector4Array) Bsearch(value Vector4, before bool) int64 {
	mb := globalPackedVector4ArrayMethodBindings.method_bsearch
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = BoolEncoder.EncodeTypePtr(before)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Duplicate : duplicate
 * is_vararg = false, is_static = false
 * goReturnType(PackedVector4Array) -> PackedVector4Array
 */
func (cx *PackedVector4Array) Duplicate() PackedVector4Array {
	mb := globalPackedVector4ArrayMethodBindings.method_duplicate
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}

	ret := CallBuiltinMethodPtrRet[PackedVector4Array](mb, bx, nil)
	return ret
}

/* Find : find
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector4Array) Find(value Vector4, from int64) int64 {
	mb := globalPackedVector4ArrayMethodBindings.method_find
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Rfind : rfind
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector4Array) Rfind(value Vector4, from int64) int64 {
	mb := globalPackedVector4ArrayMethodBindings.method_rfind
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 2
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	args[1] = Int64Encoder.EncodeTypePtr(from)

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

/* Count : count
 * is_vararg = false, is_static = false
 * goReturnType(int) -> int64
 */
func (cx *PackedVector4Array) Count(value Vector4) int64 {
	mb := globalPackedVector4ArrayMethodBindings.method_count
	if mb == nil {
		log.Panic("method bind cannot be nil")
	}
	bx := cx.NativePtr()
	if bx == nil {
		log.Panic("object cannot be nil")
	}
	sz := 1
	args := make([]GDExtensionTypePtr, sz, sz)
	args[0] = (GDExtensionTypePtr)(unsafe.Pointer(&value))

	ret := CallBuiltinMethodPtrRet[int64](mb, bx, args...)
	runtime.KeepAlive(args)
	return ret
}

func (cx *PackedVector4Array) GetIndexed(i int64) Vector4 {
	var ret Vector4
	CallFunc_GDExtensionPtrIndexedGetter(
		globalPackedVector4ArrayMethodBindings.indexed_getter,
		cx.NativeConstPtr(),
		(GDExtensionInt)(i),
		(GDExtensionTypePtr)(unsafe.Pointer(&ret)),
	)
	return ret
}

func (cx *PackedVector4Array) SetIndexed(i int64, value Vector4) {
	CallFunc_GDExtensionPtrIndexedSetter(
		globalPackedVector4ArrayMethodBindings.indexed_setter,
		cx.NativePtr(),
		(GDExtensionInt)(i),
		(GDExtensionConstTypePtr)(unsafe.Pointer(&value)),
	)
}

// members
// Equal_Variant operator
func (cx *PackedVector4Array) Equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedVector4ArrayMethodBindings.operator_equal_Variant, lt, rt)
}

// Not_equal_Variant operator
func (cx *PackedVector4Array) Not_equal_Variant(right Variant) bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(right.NativeConstPtr())
	return CallBuiltinOperatorPtr[bool](globalPackedVector4ArrayMethodBindings.operator_not_equal_Variant, lt, rt)
}

// Not operator
func (cx *PackedVector4Array) Not() bool {
	lt := cx.NativeConstPtr()
	rt := (GDExtensionConstTypePtr)(nullptr)
	return CallBuiltinOperatorPtr[bool](globalPackedVector4ArrayMethodBindings.operator_not, lt, rt)
}

// In_Dictionary operator
func (cx *PackedVector4Array) In_Dictionary(right Dictionary) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedVector4ArrayMethodBindings.operator_in_Dictionary, lt, rt)
}

// In_Array operator
func (cx *PackedVector4Array) In_Array(right Array) bool {
	lt := cx.NativeConstPtr()
	rt := right.NativeConstPtr()
	return CallBuiltinOperatorPtr[bool](globalPackedVector4ArrayMethodBindings.operator_in_Array, lt, rt)
}

// Equal_PackedVector4Array operator
func (cx *PackedVector4Array) Equal_PackedVector4Array(right PackedVector4Array) bool {
	lt := cx.NativeConstPtr()
	eRight := PackedVector4ArrayEncoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[bool](globalPackedVector4ArrayMethodBindings.operator_equal_PackedVector4Array, lt, rt)
}

// Not_equal_PackedVector4Array operator
func (cx *PackedVector4Array) Not_equal_PackedVector4Array(right PackedVector4Array) bool {
	lt := cx.NativeConstPtr()
	eRight := PackedVector4ArrayEncoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[bool](globalPackedVector4ArrayMethodBindings.operator_not_equal_PackedVector4Array, lt, rt)
}

// Add_PackedVector4Array operator
func (cx *PackedVector4Array) Add_PackedVector4Array(right PackedVector4Array) PackedVector4Array {
	lt := cx.NativeConstPtr()
	eRight := PackedVector4ArrayEncoder.EncodeTypePtr(right)
	rt := (GDExtensionConstTypePtr)(unsafe.Pointer(eRight))
	return CallBuiltinOperatorPtr[PackedVector4Array](globalPackedVector4ArrayMethodBindings.operator_add_PackedVector4Array, lt, rt)
}
