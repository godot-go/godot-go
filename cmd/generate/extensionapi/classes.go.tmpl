{{ $view := . -}}
package gdextension

/*------------------------------------------------------------------------------
//   This code was generated by template classes.go.tmpl.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "classes.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

//revive:disable

// #include <godot/gdextension_interface.h>
// #include "classes.callbacks.gen.h"
// #include <stdio.h>
// #include <stdlib.h>
import "C"
import (
	"unsafe"

	. "github.com/godot-go/godot-go/pkg/gdextensionffi"
	"github.com/godot-go/godot-go/pkg/log"
	"go.uber.org/zap"
)

// classes
{{ range $i, $c := $view.Classes -}}

type {{ goClassStructName $c.Name }} struct {
	{{ if $c.Inherits }}
	{{ goClassStructName $c.Inherits }}
	{{ else }}
	WrappedImpl
	{{ end }}
}

func NewGDExtensionClassFrom{{ $c.Name }}Owner(owner *GodotObject) GDExtensionClass {
	inst := &{{ goClassStructName $c.Name }}{}
	inst.Owner = owner
	return (GDExtensionClass)(inst)
}

func New{{ $c.Name }}WithGodotOwnerObject(owner *GodotObject) {{ $c.Name }} {
	inst := &{{ goClassStructName $c.Name }}{}
	inst.Owner = owner
	return inst
}

{{ if $c.Methods -}}

// section: methods
func (cx *{{ goClassStructName $c.Name }}) GetClassName() string {
	return "{{ $c.Name }}"
}

func (cx *{{ goClassStructName $c.Name }}) GetParentClassName() string {
	return "{{ $c.Inherits }}"
}

{{ range $j, $m := $c.Methods -}}
{{ $fnReturnType := goReturnType (coalesce $m.ReturnValue.Meta $m.ReturnValue.Type) }}
{{ $hasSomeArguments := (or $m.Arguments $m.IsVararg) }}

{{ if $m.IsVirtual -}}
{{/* TODO: deal with virtual functions */}}
{{ else -}}
/* {{ goMethodName $m.Name }} implements {{ $c.Name }}.{{ $m.Name }}:
 * is_vararg = {{ $m.IsVararg }}, is_static = {{ $m.IsStatic }}, is_virtual = {{ $m.IsVirtual }},
 * return_type = {{ $m.ReturnValue.Type }}, return_meta = {{ $m.ReturnValue.Meta }}
 */
func (cx *{{ goClassStructName $c.Name }}) {{ goMethodName $m.Name }}(
{{range $k, $a := $m.Arguments -}}
{{ goArgumentName $a.Name }} {{ goArgumentType (coalesce $a.Meta $a.Type) }},
{{end -}}
{{- if $m.IsVararg }}varargs ...Variant,{{ end -}}
) {{ $fnReturnType }} {
    {{/* TODO: refactor for static instantiation */}}
	className := NewStringNameWithLatin1Chars("{{ $c.Name }}")
	defer className.Destroy()
	methodName := NewStringNameWithLatin1Chars("{{ $m.Name }}")
	defer methodName.Destroy()
	fn := CallFunc_GDExtensionInterfaceClassdbGetMethodBind(
		className.AsGDExtensionConstStringNamePtr(),
		methodName.AsGDExtensionConstStringNamePtr(),
		{{ $m.Hash }},
	)

	if fn == nil {
		panic("could not find method function {{ $c.Name }}.{{ $m.Name }} ({{ $m.Hash }})")
	}

	{{/* init return type */}}
	{{ if $fnReturnType -}}
	{{ if $view.ContainsClassName $fnReturnType -}}
	var ret {{ goClassStructName $fnReturnType }}
	{{ else -}}
	var ret {{ $fnReturnType }}
	{{ end -}}
	{{ if $m.IsVararg}}
	retPtr := (GDExtensionUninitializedVariantPtr)(unsafe.Pointer(&ret))
	{{ else -}}
	retPtr := (GDExtensionTypePtr)(unsafe.Pointer(&ret))
	{{ end -}}
	{{- else -}}
	{{ if $m.IsVararg}}
	retPtr := (GDExtensionUninitializedVariantPtr)(nullptr)
	{{ else -}}
	retPtr := (GDExtensionTypePtr)(nullptr)
	{{ end -}}
	{{- end }}

	{{ if $m.IsVararg -}}
	callArgCount := {{ len $m.Arguments }} + len(varargs)
	{{ else -}}
	callArgCount := {{ len $m.Arguments }}
	{{ end -}}

	argsPtr := AllocArrayPtr[GDExtensionConstVariantPtr](int(callArgCount))

	{{ if or $m.IsVararg (gt (len $m.Arguments) 0) -}}
	argsPtrSlice := unsafe.Slice(argsPtr, int(callArgCount))
	{{ end -}}

	{{ if $m.IsVararg -}}
	{{ range $j, $a := $m.Arguments -}}
	arg{{ $j }} := {{ goVariantConstructor $a.Type (goArgumentName $a.Name) }}
	{{ if $a.HasDestroy }}
	defer arg{{ $j }}.Destroy()
	{{ end -}}
	argsPtrSlice[{{ $j }}] = (GDExtensionConstVariantPtr)(unsafe.Pointer(&arg{{ $j }}))
	{{ end -}}
	{{ else -}}
	{{ range $j, $a := $m.Arguments -}}
		{{ if and (eq $j 0) (and (isSetterMethodName (goMethodName $m.Name)) ($view.IsRefcountedClassName (goArgumentType (coalesce $a.Meta $a.Type)))) -}}
		{{ goArgumentName $a.Name }}.Reference()
		{{ end -}}
		argsPtrSlice[{{ $j }}] = (GDExtensionConstVariantPtr)(unsafe.Pointer(&{{ goArgumentName $a.Name }}))
	{{ end -}}
	{{ end -}}

    {{ if $m.IsVararg -}}
    for i := range varargs {
		argsPtrSlice[i + {{ len $m.Arguments }}] = (GDExtensionConstVariantPtr)(unsafe.Pointer(&varargs[i])) // variant
    }
    {{ end -}}

	cOwner := (GDExtensionObjectPtr)(unsafe.Pointer(cx.GetGodotObjectOwner()))

	{{ if $m.IsVararg -}}
	var err GDExtensionCallError

	CallFunc_GDExtensionInterfaceObjectMethodBindCall(fn, cOwner, (*GDExtensionConstVariantPtr)(unsafe.Pointer(argsPtr)), (GDExtensionInt)(callArgCount), retPtr, &err)

	if !err.Ok() {
		log.Panic("method bind call error", zap.Error(&err))
	}
	{{ else -}}
	cArgs := (*GDExtensionConstTypePtr)(unsafe.Pointer(argsPtr))

	CallFunc_GDExtensionInterfaceObjectMethodBindPtrcall(fn, cOwner, cArgs, retPtr)
	{{ end -}}

	{{ with $fnReturnType -}}

	Free(unsafe.Pointer(argsPtr))

	{{ if $view.IsRefcountedClassName $fnReturnType -}}
	ret.Reference()
	return &ret
	{{ else if $view.ContainsClassName $fnReturnType -}}
	return &ret
	{{ else -}}
	return ret
	{{ end -}}
	{{- end }}
}
{{ end -}}
{{ end -}} {{/* if $m.IsVirtual */}}

{{ end -}} {{/* range $j, $m := $c.Methods */}}

{{ end -}}
