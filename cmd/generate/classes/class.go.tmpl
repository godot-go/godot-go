package {{ .PackageName }}

//revive:disable

/*
#include <stdlib.h>
#include <gdnative.wrapper.gen.h>
#include <nativescript.wrapper.gen.h>
#include <cgo_gateway_register_class.h>
#include <cgo_gateway_class.h>
*/
import "C"
import (
	"unsafe"
	"errors"
	"fmt"
	"reflect"
	"runtime"
	"github.com/godot-go/godot-go/pkg/log"
	"sync"
)

/*------------------------------------------------------------------------------
//   This code was generated by template {{ .TemplateName }}.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "{{ .TemplateName }}" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/
func init() {
	{{ range $j, $api := .Apis -}}
	registerMethodBinds(Init{{ $api.PrefixName }}MethodBinds)
	registerTypeTag(Init{{ $api.PrefixName }}TypeTag)
	{{ end -}}
}

{{ range $j, $api := .Apis -}}

	{{ template "TYPEDEF_INTERFACE" $api }}

	type {{ $api.PrefixName }}Impl struct {
		{{ if eq $api.BaseClass "" }}
			WrappedImpl
		{{ else }}
			{{ $api.BaseClass }}Impl
		{{ end }}
	}

	var sizeof{{ $api.PrefixName }} = int32(unsafe.Sizeof({{ $api.PrefixName }}Impl{}))
	// var typeTag{{ $api.PrefixName }} = NewTypeTagFromString("{{ $api.Name }}")

	{{ template "CONSTRUCTOR" $api }}

	func (o *{{ $api.PrefixName }}Impl) ClassName() string {
		return "{{ $api.Name }}"
	}

	func (o *{{ $api.PrefixName }}Impl) BaseClass() string {
		return "{{ $api.BaseClass }}"
	}

	{{ if eq $api.BaseClass "" -}}
	func (o *{{ $api.PrefixName }}Impl) Destroy() {
		if o.Owner == nil {
			log.Error("Object.Destroy already called")
			return
		}

		RegisterState.Stats.NativeScriptFrees["{{ .PrefixName }}"]++

		ObjectDestroy(o.Owner)
		o.Owner = nil
	}

	func (o *{{ $api.PrefixName }}Impl) GetOwnerObject() *GodotObject {
		return o.Owner
	}

	func (o *{{ $api.PrefixName }}Impl) GetTypeTag() TypeTag {
		return o.TypeTag
	}
	{{ end }}

	{{ template "CLASS_METHODS" $api }}

	{{ template "CONSTANTS" $api }}

	{{ template "ENUMS" $api }}

{{ end -}}
//revive:enable

{{ define "CONSTRUCTOR" }}
	{{ if .Singleton }}

		var _{{ .PrefixName }}Once sync.Once
		var _{{ .PrefixName }}Singleton {{ .PrefixName }}

		func GetSingleton{{ .PrefixName }}() {{ .PrefixName }} {
			_{{ .PrefixName }}Once.Do(func() {
				 _{{ .PrefixName }}Singleton = new{{ .PrefixName }}()
			})

			return _{{ .PrefixName }}Singleton
		}

		func new{{ .PrefixName }}() {{ .PrefixName }} {
			cname := C.CString("{{ .SingletonName }}")
			defer C.free(unsafe.Pointer(cname))

			owner := (*Object)(unsafe.Pointer(C.go_godot_global_get_singleton(CoreApi, cname)))
			wrapped := *(*WrappedImpl)(C.go_godot_nativescript_get_instance_binding_data(Nativescript11Api, RegisterState.LanguageIndex, unsafe.Pointer(owner)))

			m := &{{ .PrefixName }}Impl{}
			m.WrappedImpl = wrapped

			if m.Owner == nil {
				log.Panic("owner should not be null")
			}

			if m.TypeTag == EmptyTypeTag {
				log.Panic("type tag should not be zero")
			}

			{{/* runtime.SetFinalizer(m, func(m *{{ .PrefixName }}Impl) {
				m.Destroy()
			}) */}}

			RegisterState.Stats.NativeScriptAllocs["{{ .PrefixName }}"]++

			return m
		}
	{{ else }}
		// New{{ .PrefixName }} creates a new {{ .PrefixName }}.
		func New{{ .PrefixName }}() {{ .PrefixName }} {
			cname := C.CString("{{ .Name }}")
			defer C.free(unsafe.Pointer(cname))
			owner := (*GodotObject)(C.go_godot_get_class_constructor_new(CoreApi, cname))

			return New{{ .PrefixName }}WithOwner(owner)
		}

		// New{{ .PrefixName }}WithOwner wraps the GodotObject.
		func New{{ .PrefixName }}WithOwner(owner *GodotObject) {{ .PrefixName }} {
		    wrapped := *(*WrappedImpl)(C.go_godot_nativescript_get_instance_binding_data(Nativescript11Api, RegisterState.LanguageIndex, unsafe.Pointer(owner)))

			m := &{{ .PrefixName }}Impl{}
			m.WrappedImpl = wrapped

			if m.Owner == nil {
				log.Panic("owner should not be null")
			}

			if m.TypeTag == EmptyTypeTag {
				log.Panic("type tag should not be zero")
			}

			return m
		}

		func new{{ .PrefixName }}AsClass() Class {
			return New{{ .PrefixName }}()
		}
	{{ end }}
{{ end }}

{{ define "TYPEDEF_INTERFACE" }}
	type {{ .PrefixName }} interface {
		{{ if eq .ParentInterface "Class" }}
		{{ .ParentInterface }}
		{{ else }}
		{{ .ParentInterface }}
		{{ end }}

		// methods
		{{ range $j, $method := .GoMethods -}}
			{{ $goReturnType := GoType $method.ReturnType }}
			{{ $goReturnUsage := GoTypeUsage $method.ReturnType -}}
			/* {{ .Name }} */
			{{ $method.GoName }}({{ range $k, $arg := $method.Arguments }}{{ $arg.GoName }} {{ GoType $arg.Type }},{{ end }}{{ if $method.HasVarargs }} varargs ...*Variant{{ end }}) {{ if not (eq $goReturnUsage USAGE_VOID) -}}{{ $goReturnType }}{{ end }}
		{{ end -}}
	}
{{ end }}

{{ define "CONSTANTS" }}
	// constants
	{{ if gt (len .Constants) 0 }}
		{{ $typeDefName := .Name -}}
		{{ $ConstantPrefixName := .ConstantPrefixName }}

		type {{ $typeDefName }}Constant int32

		const (
		{{ range $name, $value := .Constants -}}
			{{ $ConstantPrefixName}}_{{ $name }} {{ $typeDefName }}Constant = {{ $value }}
		{{ end -}}
		)
	{{ end }}
{{ end }}

{{ define "ENUMS" }}
	// enums
	{{ $ConstantPrefixName := .ConstantPrefixName }}
	{{ $prefixName := .PrefixName -}}
	{{ range $i, $enum := .Enums -}}
		{{ if gt (len $enum.Values) 0 }}
			{{ $enumName := printf "%s%s" $prefixName $enum.Name }}
			type {{ $enumName }} int32

			const (
			{{ range $name, $value := $enum.Values -}}
				{{ $enumName | ToSnakeCase | ToUpper }}_{{ $name }} {{ $prefixName }}{{ $enum.Name }} = {{ $value }}
			{{ end -}}
			)

		{{ end -}}
	{{ end -}}
{{ end }}

{{ define "CLASS_METHODS" }}
	{{ $className := .Name }}
	{{ $classPrefix := .PrivatePrefixName }}
	{{ $receiverName := .PrefixName }}
	{{ $typeDefName := .Name -}}

	{{ if gt (len .GoMethods) 0 }}
		var (
		{{ range $j, $method := .GoMethods }}
			{{ $classPrefix }}{{ $method.MethodBindName }} *MethodBind
		{{ end }}
		)
	{{ end }}

	func Init{{ .PrefixName }}TypeTag() {
		if CoreApi == nil {
			log.Panic("godot core api not initialized")
		}

		RegisterState.TagDB.RegisterGlobalType("{{ .Name }}", "{{ .PrefixName }}", "{{ .BaseClass }}")
		RegisterState.Stats.NativeScriptAllocs["{{ .PrefixName }}"] = 0
		RegisterState.Stats.NativeScriptFrees["{{ .PrefixName }}"] = 0
	}

	func Init{{ .PrefixName }}MethodBinds() {
		if CoreApi == nil {
			log.Panic("godot core api not initialized")
		}

		cClassName{{ $className }} := C.CString("{{ $className }}")
		defer C.free(unsafe.Pointer(cClassName{{ $className }}))

		{{ range $j, $method := .GoMethods }}
			cMethodName{{ $method.Name }} := C.CString("{{ $method.Name }}")
			defer C.free(unsafe.Pointer(cMethodName{{ $method.Name }}))

			{{ $classPrefix }}{{ $method.MethodBindName }} = (*MethodBind)(unsafe.Pointer(C.go_godot_method_bind_get_method(CoreApi, cClassName{{ $className }}, cMethodName{{ $method.Name }})))

			if {{ $classPrefix }}{{ $method.MethodBindName }} == nil {
				log.Debug("failed to initialize method bind {{ $classPrefix }}{{ $method.MethodBindName }}")
			}
		{{ end }}
	}

	{{ if gt (len .GoMethods) 0 }}
		// begin methods
		{{ range $j, $method := .GoMethods }}
			{{ $goReturnType := GoType $method.ReturnType }}
			{{ $goReturnUsage := GoTypeUsage $method.ReturnType -}}

			/* CLASS_METHOD
			{{ $method.Name }} Args: {{ $method.Arguments }}, Returns: {{ $goReturnType }}
			*/
			func (o {{ $receiverName }}Impl) {{ $method.GoName }}({{ range $k, $arg := $method.Arguments }}{{ $arg.GoName }} {{ GoType $arg.Type }},{{ end }}{{ if $method.HasVarargs }} varargs ...*Variant{{ end }}) {{ if not (eq $goReturnUsage USAGE_VOID) -}}{{ $goReturnType }}{{ end }} {
			{{ if $method.HasVarargs }}
				// Build null-terminated method arguments array
				// We cannot just use make() to create the slice because cgo
				// prohibits passing nested go pointers to C.
				ptrCArrSize := {{ len $method.Arguments }}{{ if $method.HasVarargs }} + len(varargs){{ end }}

				ptrArguments, ptrCArr := AllocNewVariantPtrSlice(ptrCArrSize)

				{{ range $k, $arg := $method.Arguments -}}
					ra{{ $k }} := GoTypeToVariant(reflect.ValueOf({{ $arg.GoName }}))
					ptrArguments[{{ $k }}] = &ra{{ $k }}
				{{ end }}

				for i, varg := range varargs {
					ptrArguments[i+{{ len $method.Arguments }}] = varg
				}

				godotErr := VariantCallError{}

				// Call the parent method. {{ $method.ReturnType }} / {{ $goReturnType }}
				{{ if eq $goReturnUsage USAGE_VOID -}}
					{{ $classPrefix }}{{ $method.MethodBindName }}.Call(o.Owner, ptrArguments, int32(ptrCArrSize), godotErr)

					{{/* {{ range $k, $arg := $method.Arguments -}}
						ra{{ $k }}.Destroy()
					{{ end }} */}}

					defer Free(ptrCArr)
				{{ else }}
					ret := {{ $classPrefix }}{{ $method.MethodBindName }}.Call(o.Owner, ptrArguments, int32(ptrCArrSize), godotErr)

					{{/* {{ range $k, $arg := $method.Arguments -}}
						ra{{ $k }}.Destroy()
					{{ end }} */}}

					defer Free(ptrCArr)

					return ret;
				{{ end }}
			{{ else }}
				// Build null-terminated method arguments array
				// We cannot just use make() to create the slice because cgo
				// prohibits passing nested go pointers to C.
				ptrCArrSize := {{ len $method.Arguments }} + 1

				ptrArguments, ptrCArr := AllocNewSlice(ptrCArrSize)

				ptrArguments[ptrCArrSize - 1] = nil

				{{ range $k, $arg := $method.Arguments -}}
					{{ $goType := GoType $arg.Type -}}
					{{ $usage := GoTypeUsage $arg.Type -}}
					{{ if eq $usage USAGE_GO_PRIMATIVE -}}
						{{ if eq $arg.Type "float" -}}
						/* USAGE_GO_PRIMATIVE ({{ $arg.Type }} -> double / {{ $goType }}) */
						var _arg{{ $k }} C.double  = (C.double)({{ $arg.GoName }})
						{{ else -}}
						/* USAGE_GO_PRIMATIVE ({{ $arg.Type }} / {{ $goType }}) */
						var _arg{{ $k }} C.{{ $arg.Type }}  = (C.{{ $arg.Type }})({{ $arg.GoName }})
						{{ end -}}
						ptrArguments[{{ $k }}] = unsafe.Pointer(&_arg{{ $k }})
					{{ else if eq $usage USAGE_GODOT_CONST_OR_ENUM -}}
						/* USAGE_GODOT_CONST_OR_ENUM ({{ $arg.Type }} / {{ $goType }}) */
						var _arg{{ $k }} C.{{ $arg.Type }} = (C.{{ $arg.Type }})({{ $arg.GoName }})
						ptrArguments[{{ $k }}] = unsafe.Pointer(&_arg{{ $k }})
					{{ else if eq $usage USAGE_GODOT_CLASS -}}
						/* USAGE_GODOT_CLASS ({{ $arg.Type }} / {{ $goType }}) */
						var _arg{{ $k }} *C.godot_object = (*C.godot_object)(unsafe.Pointer({{ $arg.GoName }}.GetOwnerObject()))
						ptrArguments[{{ $k }}] = unsafe.Pointer(_arg{{ $k }})
					{{ else if eq $usage USAGE_GODOT_STRING }}
						/* USAGE_GODOT_STRING ({{ $arg.Type }} / {{ $goType }}) */
						_arg{{ $k }} := internWithGoString({{ $arg.GoName }})
						{{/* defer _arg{{ $k }}.Destroy() */}}
						ptrArguments[{{ $k }}] = unsafe.Pointer(&_arg{{ $k }})
					{{ else if eq $usage USAGE_GODOT_STRING_NAME }}
						/* USAGE_GODOT_STRING_NAME ({{ $arg.Type }} / {{ $goType }}) */
						_arg{{ $k }} := internNameWithGoString({{ $arg.GoName }})
						{{/* defer _arg{{ $k }}.Destroy() */}}
						ptrArguments[{{ $k }}] = unsafe.Pointer(&_arg{{ $k }})
					{{ else if eq $usage USAGE_GDNATIVE_REF }}
						/* USAGE_GDNATIVE_REF ({{ $arg.Type }} / {{ $goType }}) */
						_arg{{ $k }} := {{ $arg.GoName }}
						ptrArguments[{{ $k }}] = unsafe.Pointer(&_arg{{ $k }})
					{{ else -}}
						/* Else {{ $usage }} ({{ $arg.Type }} / {{ $goType }}) */
						// TODO: This should never happen
						fail
					{{ end -}}
				{{ end }}

				{{ if eq $goReturnUsage USAGE_VOID -}}
					/* USAGE_VOID ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					var ret unsafe.Pointer
				{{ else if eq $goReturnUsage USAGE_GO_PRIMATIVE -}}
					/* USAGE_GO_PRIMATIVE ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					var ret C.{{ $method.CReturnType }}
				{{ else if eq $goReturnUsage USAGE_GODOT_CLASS -}}
					/* USAGE_GODOT_CLASS ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					var ret *GodotObject
				{{ else if eq $goReturnUsage USAGE_GDNATIVE_CONST_OR_ENUM -}}
					/* USAGE_GDNATIVE_CONST_OR_ENUM ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					var ret {{ $goReturnType }}
				{{ else if eq $goReturnUsage USAGE_GDNATIVE_REF -}}
					/* USAGE_GDNATIVE_REF ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					var ret {{ $method.ReturnType }}
				{{ else if eq $goReturnUsage USAGE_GODOT_STRING -}}
					/* USAGE_GODOT_STRING ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					var ret {{ $method.ReturnType }}
				{{ else if eq $goReturnUsage USAGE_GODOT_STRING_NAME -}}
					/* USAGE_GODOT_STRING_NAME ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					var ret {{ $method.ReturnType }}
				{{ else if eq $goReturnUsage USAGE_GODOT_CONST_OR_ENUM -}}
					/* USAGE_GODOT_CONST_OR_ENUM ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					var ret {{ $goReturnType }}
				{{ else -}}
					/* Else {{ $goReturnUsage }} ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					// TODO: This should never happen
					fail
				{{ end }}

				// Call the parent method. {{ $method.ReturnType }} / {{ $goReturnType }}
				{{ $classPrefix }}{{ $method.MethodBindName }}.Ptrcall(o.Owner, ptrArguments, unsafe.Pointer(&ret))

				defer Free(unsafe.Pointer(ptrCArr))

				{{ range $k, $arg := $method.Arguments -}}
					runtime.KeepAlive(_arg{{ $k }})
				{{ end }}

				runtime.KeepAlive(ptrArguments)

				{{ if eq $goReturnUsage USAGE_VOID }}
					/* USAGE_VOID ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					// NOOP
				{{ else if eq $goReturnType "bool" }}
					/* bool ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					return ret != 0
				{{ else if eq $goReturnUsage USAGE_GO_PRIMATIVE -}}
					/* USAGE_GO_PRIMATIVE ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					return {{ $goReturnType }}(ret)
				{{ else if eq $goReturnUsage USAGE_GDNATIVE_CONST_OR_ENUM -}}
					/* USAGE_GDNATIVE_CONST_OR_ENUM ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					return ret
				{{ else if eq $goReturnUsage USAGE_GODOT_STRING -}}
					/* USAGE_GODOT_STRING ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					return internWithGodotString(ret)
				{{ else if eq $goReturnUsage USAGE_GODOT_STRING_NAME -}}
					/* USAGE_GODOT_STRING_NAME ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					return internWithGodotStringName(ret)
				{{ else if eq $goReturnUsage USAGE_GDNATIVE_REF -}}
					/* USAGE_GDNATIVE_REF ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					return ret
				{{ else if eq $goReturnUsage USAGE_GODOT_CONST_OR_ENUM -}}
					/* USAGE_GODOT_CONST_OR_ENUM ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					return {{ $goReturnType }}(ret)
				{{ else if eq $goReturnUsage USAGE_GODOT_CLASS -}}
					if ret == nil {
						return nil
					}

					/* USAGE_GODOT_CLASS ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					return New{{ $method.ReturnType }}WithOwner(ret)
				{{ else -}}
					/* Else {{ $goReturnUsage }} ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					// TODO: This should never happen
					fail
				{{ end -}}
			{{end}}
			}
		{{ end -}} // end methods
	{{ end -}} // end if gt (len .GoMethods) 0
{{ end }}
