package {{ .PackageName }}

/*
#cgo pkg-config: --define-variable=PROJECTDIR=${SRCDIR}/../.. ${SRCDIR}/../../godot.pc
#include <stdlib.h>
#include <gdnative.gen.h>
#include <cgo_gateway_register_class.h>
#include <cgo_gateway_class.h>
#include <nativescript.gen.h>
*/
import "C"
import (
	"unsafe"
	"errors"
	"fmt"
	"reflect"
	"runtime"
	"github.com/pcting/godot-go/pkg/log"
	{{ if .Api.Singleton -}}
	"sync"
	{{- end }}
)

/*------------------------------------------------------------------------------
//   This code was generated by template {{ .TemplateName }}.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "{{ .TemplateName }}" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

{{ template "TYPEDEF_INTERFACE" .Api }}

type {{ .Api.PrefixName }}Impl struct {
	{{ if eq .Api.BaseClass "" }}
    	Wrapped
	{{ else }}
		{{ .Api.BaseClass }}Impl
	{{ end }}
}

var sizeof{{ .Api.PrefixName }} = int32(unsafe.Sizeof({{ .Api.PrefixName }}Impl{}))
// var typeTag{{ .Api.PrefixName }} = NewTypeTagFromString("{{ .Api.Name }}")

{{ template "CONSTRUCTOR" .Api }}

func (o *{{ .Api.PrefixName }}Impl) ClassName() string {
	return "{{ .Api.Name }}"
}

func (o *{{ .Api.PrefixName }}Impl) BaseClass() string {
	return "{{ .Api.BaseClass }}"
}

{{ if eq .Api.BaseClass "" -}}
func (o *{{ .Api.PrefixName }}Impl) Free() {
	if o != nil {
		Free(unsafe.Pointer(o))
		o = nil
	}
}

func (o *{{ .Api.PrefixName }}Impl) GetOwnerObject() *GodotObject {
	return o.Owner
}

func (o *{{ .Api.PrefixName }}Impl) GetTypeTag() TypeTag {
	return o.TypeTag
}

{{/* func (o *{{ .Api.PrefixName }}Impl) GetUserData() UserData {
	return UserData(fmt.Sprintf("{{ .Api.Name }}::%p", o.Owner))
} */}}
{{ end }}

{{ template "CLASS_METHODS" .Api }}

{{ template "CONSTANTS" .Api }}

{{ template "ENUMS" .Api }}

{{ define "CONSTRUCTOR" }}
	{{ if .Singleton }}

		var _{{ .PrefixName }}Once sync.Once
		var _{{ .PrefixName }}Singleton {{ .PrefixName }}
		
		func GetSingleton{{ .PrefixName }}() {{ .PrefixName }} {
			_{{ .PrefixName }}Once.Do(func() {
				 _{{ .PrefixName }}Singleton = new{{ .PrefixName }}()
			})

			return _{{ .PrefixName }}Singleton
		}

		func new{{ .PrefixName }}() {{ .PrefixName }} {
			cname := C.CString("{{ .SingletonName }}")
			defer C.free(unsafe.Pointer(cname))

			owner := (*Object)(unsafe.Pointer(C.go_godot_global_get_singleton(CoreApi, cname)))
			wrapped := *(*Wrapped)(C.go_godot_nativescript_get_instance_binding_data(Nativescript11Api, RegisterState.LanguageIndex, unsafe.Pointer(owner)))
			
			m := (*{{ .PrefixName }}Impl)(AllocZeros(int32(sizeof{{ .PrefixName }})))
			m.Wrapped = wrapped

			if m.Owner == nil {
				log.Panic("owner should not be null")
			}

			if m.TypeTag == EmptyTypeTag {
				log.Panic("type tag should not be zero")
			}

			return m
		}
	{{ else }}
		func New{{ .PrefixName }}() {{ .PrefixName }} {
			cname := C.CString("{{ .Name }}")
			defer C.free(unsafe.Pointer(cname))
			owner := (*GodotObject)(C.go_godot_get_class_constructor_new(CoreApi, cname))
		    wrapped := *(*Wrapped)(C.go_godot_nativescript_get_instance_binding_data(Nativescript11Api, RegisterState.LanguageIndex, unsafe.Pointer(owner)))

			m := (*{{ .PrefixName }}Impl)(AllocZeros(int32(sizeof{{ .PrefixName }})))
			m.Wrapped = wrapped

			if m.Owner == nil {
				log.Panic("owner should not be null")
			}

			if m.TypeTag == EmptyTypeTag {
				log.Panic("type tag should not be zero")
			}

			return m
		}

		func New{{ .PrefixName }}WithOwner(owner *GodotObject) {{ .PrefixName }} {
		    wrapped := *(*Wrapped)(C.go_godot_nativescript_get_instance_binding_data(Nativescript11Api, RegisterState.LanguageIndex, unsafe.Pointer(owner)))

			m := (*{{ .PrefixName }}Impl)(AllocZeros(int32(sizeof{{ .PrefixName }})))
			m.Wrapped = wrapped

			if m.Owner == nil {
				log.Panic("owner should not be null")
			}

			if m.TypeTag == EmptyTypeTag {
				log.Panic("type tag should not be zero")
			}

			return m
		}

		{{/* func New{{ .PrefixName }}WithWrapped(wrapped Wrapped) Class {
			m := (*{{ .PrefixName }}Impl)(AllocZeros(int32(sizeof{{ .PrefixName }})))
			m.Wrapped = wrapped

			if m.Owner == nil {
				log.Panic("owner should not be null")
			}

			if m.TypeTag == EmptyTypeTag {
				log.Panic("type tag should not be zero")
			}

			return m
		} */}}

		func New{{ .PrefixName }}WithRef(owner *GodotObject, typeTag TypeTag) {{ .PrefixName }} {
			m := (*{{ .PrefixName }}Impl)(AllocZeros(int32(sizeof{{ .PrefixName }})))
			m.Owner = owner
			m.TypeTag = typeTag

			if m.Owner == nil {
				log.Panic("owner should not be null")
			}

			if m.TypeTag == EmptyTypeTag {
				log.Panic("type tag should not be zero")
			}

			return m
		}

		func New{{ .PrefixName }}WithRefAsClass(owner *GodotObject, typeTag TypeTag) Class {
			return New{{ .PrefixName }}WithRef(owner, typeTag)
		}

		func new{{ .PrefixName }}AsClass() Class {
			return New{{ .PrefixName }}()
		}
	{{ end }}
{{ end }}

{{ define "TYPEDEF_INTERFACE" }}
	type {{ .PrefixName }} interface {
		{{ if eq .ParentInterface "Class" }}
		{{ .ParentInterface }}
		{{ else }}
		{{ .ParentInterface }}
		{{ end }}

		// methods
		{{ range $j, $method := .GoMethods -}}
			{{ $goReturnType := GoType $method.ReturnType }}
			{{ $goReturnUsage := GoTypeUsage $method.ReturnType -}}
			/* {{ .Name }} */
			{{ $method.GoName }}({{ range $k, $arg := $method.Arguments }}{{ $arg.GoName }} {{ GoType $arg.Type }},{{ end }}{{ if $method.HasVarargs }} varargs ...*Variant{{ end }}) {{ if not (eq $goReturnUsage USAGE_VOID) -}}{{ $goReturnType }}{{ end }}
		{{ end -}}
	}
{{ end }}

{{ define "CONSTANTS" }}
	// constants
	{{ if gt (len .Constants) 0 }}
		{{ $typeDefName := .Name -}}
		{{ $ConstantPrefixName := .ConstantPrefixName }}

		type {{ $typeDefName }}Constant int32

		const (
		{{ range $name, $value := .Constants -}}
			{{ $ConstantPrefixName}}_{{ $name }} {{ $typeDefName }}Constant = {{ $value }}
		{{ end -}}
		)
	{{ end }}
{{ end }}

{{ define "ENUMS" }}
	// enums
	{{ $ConstantPrefixName := .ConstantPrefixName }}
	{{ $prefixName := .PrefixName -}}
	{{ range $i, $enum := .Enums -}}
		{{ if gt (len $enum.Values) 0 }}
			{{ $enumName := printf "%s%s" $prefixName $enum.Name }}
			type {{ $enumName }} int32

			const (
			{{ range $name, $value := $enum.Values -}}
				{{ $enumName | ToSnakeCase | ToUpper }}_{{ $name }} {{ $prefixName }}{{ $enum.Name }} = {{ $value }}
			{{ end -}}
			)

		{{ end -}}
	{{ end -}}
{{ end }}

{{ define "CLASS_METHODS" }}
	{{ $className := .Name }}
	{{ $classPrefix := .PrivatePrefixName }}
	{{ $receiverName := .PrefixName }}
	{{ $typeDefName := .Name -}}

	{{ if gt (len .GoMethods) 0 }}
		var (
		{{ range $j, $method := .GoMethods }}
			{{ $classPrefix }}{{ $method.MethodBindName }} *MethodBind
		{{ end }}
		)
	{{ end }}

	func init() {
		registerMethodBinds(Init{{ .PrefixName }}MethodBinds)
		registerTypeTag(Init{{ .PrefixName }}TypeTag)

		{{ if not .Singleton }}
		if _, ok := ConstructorMap["{{ .PrefixName }}"]; ok {
			log.WithField("class", "{{ .PrefixName }}").Panic("class already in map")
		}

		constructor := New{{ .PrefixName }}WithRefAsClass

		ConstructorMap["{{ .PrefixName }}"] = constructor
		{{ end }}

		// satisfy import reflect
		_ = reflect.ValueOf(1)

		// satisfy import runtime
		runtime.KeepAlive(1)

		// satisfy import fmt
		fmt.Sprintf("test")
	}

	func Init{{ .PrefixName }}TypeTag() {
		if CoreApi == nil {
			log.Panic(errors.New("godot core api not initialized"))
		}

		RegisterState.TagDB.RegisterGlobalType("{{ .Name }}", "{{ .PrefixName }}", "{{ .BaseClass }}")
	}

	func Init{{ .PrefixName }}MethodBinds() {
		if CoreApi == nil {
			log.Panic(errors.New("godot core api not initialized"))
		}

		cClassName{{ $className }} := C.CString("{{ $className }}")
		defer C.free(unsafe.Pointer(cClassName{{ $className }}))

		{{ range $j, $method := .GoMethods }}
			cMethodName{{ $method.Name }} := C.CString("{{ $method.Name }}")
			defer C.free(unsafe.Pointer(cMethodName{{ $method.Name }}))

			{{ $classPrefix }}{{ $method.MethodBindName }} = (*MethodBind)(unsafe.Pointer(C.go_godot_method_bind_get_method(CoreApi, cClassName{{ $className }}, cMethodName{{ $method.Name }})))

			if {{ $classPrefix }}{{ $method.MethodBindName }} == nil {
				log.Debug(errors.New("failed to initialize method bind {{ $classPrefix }}{{ $method.MethodBindName }}"))
			}
		{{ end }}
	}

	{{ if gt (len .GoMethods) 0 }}
		// begin methods
		{{ range $j, $method := .GoMethods }}
			{{ $goReturnType := GoType $method.ReturnType }}
			{{ $goReturnUsage := GoTypeUsage $method.ReturnType -}}
			
			/* CLASS_METHOD
			{{ $method.Name }} Args: {{ $method.Arguments }}, Returns: {{ $goReturnType }}
			*/
			func (o {{ $receiverName }}Impl) {{ $method.GoName }}({{ range $k, $arg := $method.Arguments }}{{ $arg.GoName }} {{ GoType $arg.Type }},{{ end }}{{ if $method.HasVarargs }} varargs ...*Variant{{ end }}) {{ if not (eq $goReturnUsage USAGE_VOID) -}}{{ $goReturnType }}{{ end }} {
			{{ if $method.HasVarargs }}
				// Build null-terminated method arguments array
				// We cannot just use make() to create the slice because cgo
				// prohibits passing nested go pointers to C.
				ptrCArrSize := {{ len $method.Arguments }}{{ if $method.HasVarargs }} + len(varargs){{ end }}

				ptrArguments, ptrCArr := NewVariantPtrSliceFromAlloc(ptrCArrSize)

				{{ range $k, $arg := $method.Arguments -}}
					ra{{ $k }} := GoTypeToVariant(reflect.ValueOf({{ $arg.GoName }}))
					ptrArguments[{{ $k }}] = &ra{{ $k }}
				{{ end }}

				for i, varg := range varargs {
					ptrArguments[i+{{ len $method.Arguments }}] = varg
				}

				godotErr := VariantCallError{}

				// Call the parent method. {{ $method.ReturnType }} / {{ $goReturnType }}
				{{ if eq $goReturnUsage USAGE_VOID -}}
					{{ $classPrefix }}{{ $method.MethodBindName }}.Call(o.Owner, ptrArguments, int32(ptrCArrSize), godotErr)

					{{ range $k, $arg := $method.Arguments -}}
						ra{{ $k }}.Destroy()
					{{ end }}

					defer Free(ptrCArr)
				{{ else }}
					ret := {{ $classPrefix }}{{ $method.MethodBindName }}.Call(o.Owner, ptrArguments, int32(ptrCArrSize), godotErr)

					{{ range $k, $arg := $method.Arguments -}}
						ra{{ $k }}.Destroy()
					{{ end }}

					defer Free(ptrCArr)

					return ret;
				{{ end }}
			{{ else }}
				// Build null-terminated method arguments array
				// We cannot just use make() to create the slice because cgo
				// prohibits passing nested go pointers to C.
				ptrCArrSize := {{ len $method.Arguments }} + 1

				ptrArguments, ptrCArr := NewSliceFromAlloc(ptrCArrSize)

				ptrArguments[ptrCArrSize - 1] = nil

				{{ range $k, $arg := $method.Arguments -}}
					{{ $goType := GoType $arg.Type -}}
					{{ $usage := GoTypeUsage $arg.Type -}}
					{{ if eq $usage USAGE_GO_PRIMATIVE -}}
						{{ if eq $arg.Type "float" -}}
						/* USAGE_GO_PRIMATIVE ({{ $arg.Type }} -> double / {{ $goType }}) */
						var _arg{{ $k }} C.double  = (C.double)({{ $arg.GoName }})
						{{ else -}}
						/* USAGE_GO_PRIMATIVE ({{ $arg.Type }} / {{ $goType }}) */
						var _arg{{ $k }} C.{{ $arg.Type }}  = (C.{{ $arg.Type }})({{ $arg.GoName }})
						{{ end -}}
						ptrArguments[{{ $k }}] = unsafe.Pointer(&_arg{{ $k }})
					{{ else if eq $usage USAGE_GODOT_CONST_OR_ENUM -}}
						/* USAGE_GODOT_CONST_OR_ENUM ({{ $arg.Type }} / {{ $goType }}) */
						var _arg{{ $k }} C.{{ $arg.Type }} = (C.{{ $arg.Type }})({{ $arg.GoName }})
						ptrArguments[{{ $k }}] = unsafe.Pointer(&_arg{{ $k }})
					{{ else if eq $usage USAGE_GODOT_CLASS -}}
						/* USAGE_GODOT_CLASS ({{ $arg.Type }} / {{ $goType }}) */
						var _arg{{ $k }} *C.godot_object = (*C.godot_object)(unsafe.Pointer({{ $arg.GoName }}.GetOwnerObject()))
						ptrArguments[{{ $k }}] = unsafe.Pointer(_arg{{ $k }})
					{{ else if eq $usage USAGE_GDNATIVE_RAW }}
						/* USAGE_GDNATIVE_RAW ({{ $arg.Type }} / {{ $goType }}) */
						_arg{{ $k }} := {{ $arg.GoName }}
						ptrArguments[{{ $k }}] = unsafe.Pointer(&_arg{{ $k }})
					{{ else if eq $usage USAGE_GDNATIVE_REF }}
						/* USAGE_GDNATIVE_REF ({{ $arg.Type }} / {{ $goType }}) */
						_arg{{ $k }} := {{ $arg.GoName }}
						ptrArguments[{{ $k }}] = unsafe.Pointer(&_arg{{ $k }})
					{{ else -}}
						/* Else {{ $usage }} ({{ $arg.Type }} / {{ $goType }}) */
						// TODO: This should never happen
						fail
					{{ end -}}
				{{ end }}
				
				{{ if eq $goReturnUsage USAGE_VOID -}}
					/* USAGE_VOID ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					var ret unsafe.Pointer
				{{ else if eq $goReturnUsage USAGE_GO_PRIMATIVE -}}
					/* USAGE_GO_PRIMATIVE ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					var ret C.{{ $method.CReturnType }}
				{{ else if eq $goReturnUsage USAGE_GODOT_CLASS -}}
					/* USAGE_GODOT_CLASS ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					var ret *GodotObject
				{{ else if eq $goReturnUsage USAGE_GDNATIVE_CONST_OR_ENUM -}}
					/* USAGE_GDNATIVE_CONST_OR_ENUM ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					var ret {{ $goReturnType }}
				{{ else if eq $goReturnUsage USAGE_GDNATIVE_REF -}}
					/* USAGE_GDNATIVE_REF ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					var ret {{ $method.ReturnType }}
				{{ else if eq $goReturnUsage USAGE_GDNATIVE_RAW -}}
					/* USAGE_GDNATIVE_RAW ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					var ret {{ $method.ReturnType }}
				{{ else if eq $goReturnUsage USAGE_GODOT_CONST_OR_ENUM -}}
					/* USAGE_GODOT_CONST_OR_ENUM ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					var ret {{ $goReturnType }}
				{{ else -}}
					/* Else {{ $goReturnUsage }} ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					// TODO: This should never happen
					fail
				{{ end }}

				// Call the parent method. {{ $method.ReturnType }} / {{ $goReturnType }}
				{{ $classPrefix }}{{ $method.MethodBindName }}.Ptrcall(o.Owner, ptrArguments, unsafe.Pointer(&ret))

				defer Free(unsafe.Pointer(ptrCArr))

				{{ range $k, $arg := $method.Arguments -}}
					runtime.KeepAlive(_arg{{ $k }})
				{{ end }}

				{{ if eq $goReturnUsage USAGE_VOID }}
					/* USAGE_VOID ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					// NOOP
				{{ else if eq $goReturnType "bool" }}
					/* bool ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					return ret != 0
				{{ else if eq $goReturnUsage USAGE_GO_PRIMATIVE -}}
					/* USAGE_GO_PRIMATIVE ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					return {{ $goReturnType }}(ret)
				{{ else if eq $goReturnUsage USAGE_GDNATIVE_CONST_OR_ENUM -}}
					/* USAGE_GDNATIVE_CONST_OR_ENUM ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					return ret
				{{ else if eq $goReturnUsage USAGE_GDNATIVE_RAW -}}
					/* USAGE_GDNATIVE_RAW ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					return ret
				{{ else if eq $goReturnUsage USAGE_GDNATIVE_REF -}}
					/* USAGE_GDNATIVE_REF ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					return ret
				{{ else if eq $goReturnUsage USAGE_GODOT_CONST_OR_ENUM -}}
					/* USAGE_GODOT_CONST_OR_ENUM ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					return {{ $goReturnType }}(ret)
				{{ else if eq $goReturnUsage USAGE_GODOT_CLASS -}}
					/* USAGE_GODOT_CLASS ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					return New{{ $method.ReturnType }}WithOwner(ret) 
				{{ else -}}
					/* Else {{ $goReturnUsage }} ({{ $method.ReturnType }} / {{ $goReturnType }}) */
					// TODO: This should never happen
					fail
				{{ end -}}
			{{end}}
			}
		{{ end -}} // end methods
	{{ end -}} // end if gt (len .GoMethods) 0
{{ end }}
