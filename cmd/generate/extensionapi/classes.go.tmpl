{{ $view := . -}}
package gdextension

/*------------------------------------------------------------------------------
//   This code was generated by template classes.go.tmpl.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "classes.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

//revive:disable

// #include <godot/gdextension_interface.h>
// #include "classes.callbacks.gen.h"
// #include <stdio.h>
// #include <stdlib.h>
import "C"
import (
	"unsafe"

	. "github.com/godot-go/godot-go/pkg/gdextensionffi"
	"github.com/godot-go/godot-go/pkg/log"
	"go.uber.org/zap"
)

// classes
{{ range $i, $c := $view.Classes -}}

type {{ goClassStructName $c.Name }} struct {
	{{ if $c.Inherits }}
	{{ goClassStructName $c.Inherits }}
	{{ else }}
	WrappedImpl
	{{ end }}
}

func NewGDExtensionClassFrom{{ $c.Name }}Owner(owner *GodotObject) GDExtensionClass {
	inst := &{{ goClassStructName $c.Name }}{}
	inst.Owner = owner
	return (GDExtensionClass)(inst)
}

func New{{ $c.Name }}WithGodotOwnerObject(owner *GodotObject) {{ if $view.IsRefcountedClassName $c.Name }}Ref{{ $c.Name }}{{ else }}{{ $c.Name }}{{ end }} {
	inst := &{{ goClassStructName $c.Name }}{}
	inst.Owner = owner

	{{ if $view.IsRefcountedClassName $c.Name -}}
	return newRef{{ $c.Name }}GDExtensionIternalConstructor(inst)
	{{ else -}}
	return inst
	{{ end -}}
}

{{ if $c.Methods -}}

// section: methods
func (cx *{{ goClassStructName $c.Name }}) GetClassName() string {
	return "{{ $c.Name }}"
}

func (cx *{{ goClassStructName $c.Name }}) GetParentClassName() string {
	return "{{ $c.Inherits }}"
}

{{ range $j, $m := $c.Methods -}}
{{ $fnReturnType := goReturnType (coalesce $m.ReturnValue.Meta $m.ReturnValue.Type) }}
{{ $hasSomeArguments := (or $m.Arguments $m.IsVararg) }}

{{ if $m.IsVirtual -}}
{{/* TODO: deal with virtual functions */}}
{{ else -}}
/* {{ goMethodName $m.Name }} implements {{ $c.Name }}.{{ $m.Name }}:
 * is_vararg = {{ $m.IsVararg }}, is_static = {{ $m.IsStatic }}, is_virtual = {{ $m.IsVirtual }},
 * return_type = {{ $m.ReturnValue.Type }}, return_meta = {{ $m.ReturnValue.Meta }}
 */
func (cx *{{ goClassStructName $c.Name }}) {{ goMethodName $m.Name }}(
{{range $k, $a := $m.Arguments -}}
{{ $fnArgType := goArgumentType (coalesce $a.Meta $a.Type) -}}
{{ goArgumentName $a.Name }} {{ if $view.IsRefcountedClassName $fnArgType }}Ref{{ $fnArgType }}{{ else }}{{ $fnArgType }}{{ end -}},
{{end -}}
{{- if $m.IsVararg }}varargs ...Variant,{{ end -}}
) {{ if $view.IsRefcountedClassName $fnReturnType }}Ref{{ $fnReturnType }}{{ else }}{{ $fnReturnType }}{{ end }} {
    {{/* TODO: refactor for static instantiation */}}
	className := NewStringNameWithLatin1Chars("{{ $c.Name }}")
	defer className.Destroy()
	methodName := NewStringNameWithLatin1Chars("{{ $m.Name }}")
	defer methodName.Destroy()
	fn := CallFunc_GDExtensionInterfaceClassdbGetMethodBind(
		className.AsGDExtensionConstStringNamePtr(),
		methodName.AsGDExtensionConstStringNamePtr(),
		{{ $m.Hash }},
	)
	if fn == nil {
		panic("could not find method function {{ $c.Name }}.{{ $m.Name }} ({{ $m.Hash }})")
	}
	{{/* init return type */}}
	{{ if $fnReturnType -}}
	{{ if $view.ContainsClassName $fnReturnType -}}
	var ret {{ goClassStructName $fnReturnType }}
	{{ else -}}
	var ret {{ $fnReturnType }}
	{{ end -}}
	{{ if $m.IsVararg}}
	retPtr := (GDExtensionUninitializedVariantPtr)(unsafe.Pointer(&ret))
	{{ else -}}
	retPtr := (GDExtensionTypePtr)(unsafe.Pointer(&ret))
	{{ end -}}
	{{- else -}}
	{{ if $m.IsVararg}}
	retPtr := (GDExtensionUninitializedVariantPtr)(nullptr)
	{{ else -}}
	retPtr := (GDExtensionTypePtr)(nullptr)
	{{ end -}}
	{{- end -}}
	cOwner := cx.AsGDExtensionObjectPtr()
	{{ if $m.IsVararg -}}
	callArgCount := {{ len $m.Arguments }} + len(varargs)
	argPtrSlice := make([]GDExtensionConstVariantPtr, int(callArgCount))
	cArgs := (*GDExtensionConstVariantPtr)(unsafe.SliceData(argPtrSlice))
	{{ range $j, $a := $m.Arguments -}}
	v{{ $j }} := {{ (goVariantFunc $a.Type (goArgumentName $a.Name) $view.Classes) }}
	argPtrSlice[{{ $j }}] = v{{ $j }}.nativeConstPtr()
	{{ end -}}
	for i := range varargs {
		argPtrSlice[i + {{ len $m.Arguments }}] = (GDExtensionConstVariantPtr)(unsafe.Pointer(&varargs[i])) // variant
    }
	var err GDExtensionCallError
	CallFunc_GDExtensionInterfaceObjectMethodBindCall(fn, cOwner, cArgs, (GDExtensionInt)(callArgCount), retPtr, &err)
	if !err.Ok() {
		log.Panic("method bind call error", zap.Error(&err))
	}
	{{ else -}}
	callArgCount := {{ len $m.Arguments }}
	argPtrSlice := make([]GDExtensionConstTypePtr, int(callArgCount))
	cArgs := (*GDExtensionConstTypePtr)(unsafe.SliceData(argPtrSlice))
	{{ range $j, $a := $m.Arguments -}}
		{{ if $view.ContainsClassName (goArgumentType (coalesce $a.Meta $a.Type)) -}}
		{{ if and (eq $j 0) (and (isSetterMethodName (goMethodName $m.Name)) ($view.IsRefcountedClassName (goArgumentType (coalesce $a.Meta $a.Type)))) -}}
		{{/* {{ goArgumentName $a.Name }}.Reference() */}}
		{{ end -}}
		argPtrSlice[{{ $j }}] = (GDExtensionConstTypePtr)(unsafe.Pointer(&{{ goArgumentName $a.Name }}))
		{{ else -}}
		argPtrSlice[{{ $j }}] = (GDExtensionConstTypePtr)(unsafe.Pointer(&{{ goArgumentName $a.Name }}))
		{{ end -}}
	{{- end -}}
	CallFunc_GDExtensionInterfaceObjectMethodBindPtrcall(fn, cOwner, cArgs, retPtr)
	{{ end -}}
	{{ with $fnReturnType -}}
	{{ if $view.IsRefcountedClassName $fnReturnType -}}
	return newRef{{ $fnReturnType }}GDExtensionIternalConstructor(&ret)
	{{ else if $view.ContainsClassName $fnReturnType -}}
	return &ret
	{{ else -}}
	return ret
	{{ end -}}
	{{- end -}}
}
{{ end -}}
{{ end -}} {{/* if $m.IsVirtual */}}

{{ end -}} {{/* range $j, $m := $c.Methods */}}

{{ end -}}
